---
tags: [design-pattern, kotlin, structural]
---

# 브리지 패턴

## 한 줄 요약

추상화와 구현을 분리하여 상속 남용을 방지하고 클래스 계층을 얇게 만드는 패턴

## 핵심 정리

- 상속 남용을 방지
- 클래스 계층 구조를 얇게 만들어 구체 클래스를 줄임
- 인터페이스 함수가 추가되어도 모든 구현체를 수정할 필요 없음
- 구성(Composition)을 통해 기능 조합

## 상세 내용

### 문제 상황

인터페이스를 직접 구현하면 함수가 추가될 때마다 모든 구현체를 수정해야 한다:

```kotlin
interface Trooper {
    fun move(x: Long, y: Long)
    fun attackRebel(x: Long, y: Long)
}

class StormTrooper : Trooper {
    override fun move(x: Long, y: Long) {
        // 보통 속도로 이동
    }
    override fun attackRebel(x: Long, y: Long) {
        // 대부분 빗나감
    }
}

class ShockTrooper: Trooper {
    override fun move(x: Long, y: Long) {
        // 일반적인 StormTrooper보다는 느리게 이동
    }
    override fun attackRebel(x: Long, y: Long) {
        // 명중할 때도
    }
}
```

인터페이스 함수가 추가되면 다른 모든 구현체에 추가해야 된다.

### 브리지 패턴 적용

클래스 계층 구조를 얇게 만들어 구체 클래스를 줄인다. move와 attack을 위해 속성으로 스펙을 만든다:

```kotlin
data class StormTrooper(
    private val weapon: Weapon,
    private val legs: Legs
) : Trooper {
    override fun move(x: Long, y: Long) {
        legs.move(x, y)
    }
    override fun attackRebel(x: Long, y: Long) {
        weapon.attack(x, y)
    }
}
```

구현 예제:

```kotlin
class Rifle: Weapon {
    override fun attack(x: Long, y: Long) = RIFLE_DAMAGE
}

class Flamethrower: Weapon {
    override fun attack(x: Long, y: Long) = RIFLE_DAMAGE * 2
}

class Batton: Weapon {
    override fun attack(x: Long, y: Long) = RIFLE_DAMAGE * 3
}

class RegularLegs : Legs {
    override fun move() = REGULAR_SPEED
}

class AthleticLegs : Legs {
    override fun move() = REGULAR_SPEED * 2
}

val stormTrooper = StormTrooper(Rifle(), RegularLegs())
val flameTrooper = StormTrooper(Flamethrower(), RegularLegs())
val scoutTrooper = StormTrooper(Rifle(), AthleticLegs())
```

### 특징

- 상속 대신 구성(Composition) 사용
- 기능을 독립적인 계층으로 분리 (Weapon, Legs)
- 기능 조합으로 다양한 변형 생성
- 새로운 기능 추가 시 영향 범위 최소화

---

**출처**
- 코틀린 디자인 패턴
