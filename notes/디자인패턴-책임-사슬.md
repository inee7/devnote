---
tags: [design-pattern, kotlin, behavioral]
---

# 책임 사슬 패턴

## 한 줄 요약

요청을 여러 핸들러 체인으로 전달하여 각 단계에서 처리 또는 다음 단계로 전달하는 패턴

## 핵심 정리

- 복잡한 로직을 여러 개의 작은 단계로 쪼갬
- 각 단계의 결과에 따라 계속 진행할지 또는 처리하고 끝낼지 결정
- 웹 서버 프레임워크에서 인증, 인가, 로깅 등 횡단 관심사를 다룰 때 많이 사용

## 상세 내용

### 구현 예제

```kotlin
fun main() {
    val req = Request(
        "developer@company.com",
        "Why do we need Software Architects?"
    )

    val chain = basicValidation(authentication(finalResponse()))

    val res = chain(req)

    println(res)
}

data class Request(val email: String, val question: String) {
    fun isKnownEmail(): Boolean {
        return true
    }

    fun isFromJuniorDeveloper(): Boolean {
        return false
    }
}

// 잘못된 구현 예시 - if문 중첩
fun handleRequest(r: Request) {
    // Validate
    if (r.email.isEmpty() || r.question.isEmpty()) {
        return
    }

    // Authenticate
    if (r.isKnownEmail()) {
        return
    }

    // Authorize
    if (r.isFromJuniorDeveloper()) {
        return
    }

    println("I don't know. Did you check StackOverflow?")
}

// 책임 사슬 패턴을 사용한 올바른 구현
val authentication = fun(next: Handler) =
    fun(request: Request): Response {
        if (!request.isKnownEmail()) {
            throw IllegalArgumentException()
        }
        return next(request)
    }

val basicValidation = fun(next: Handler) =
    fun(request: Request): Response {
        if (request.email.isEmpty() || request.question.isEmpty()) {
            throw IllegalArgumentException()
        }
        return next(request)
    }

val finalResponse = fun() =
    fun(request: Request): Response {
        return Response("I don't know")
    }

data class Response(val answer: String)

typealias Handler = (request: Request) -> Response
```

### 특징

- 고차 함수를 사용하여 핸들러 체인 구성
- 각 핸들러는 다음 핸들러를 받아 새로운 핸들러를 반환
- 함수 합성을 통한 체인 구성
- 각 단계가 독립적이어서 테스트와 재사용이 용이

### 실무 활용

웹 서버 프레임워크에서 인증, 인가, 로깅 등 횡단 관심사를 다룰 때 많이 쓴다.

---

**출처**
- 코틀린 디자인 패턴
