---
tags: [kotlin, immutable, effective-kotlin, best-practices]
---

## 한 줄 요약

가변 상태는 추적이 어렵고 멀티스레드 동기화 문제를 야기하므로, val과 immutable 객체를 사용하고 데이터 클래스의 copy로 변경을 관리하는 것이 안전하다.

## 핵심 정리

**가변 상태의 문제점**
- 추적하기 힘들고 예기치 못한 오류 발생
- 멀티스레드에서 동기화 필요
- 테스트가 어려움
- 변경이 다른 부분에 영향을 줄 수 있음

**가변성 제한 방법**
- var보다는 val 사용 (단, getter는 스마트캐스트 불가)
- mutable보다는 immutable 컬렉션 사용
- 데이터 클래스의 copy로 변경 관리
- mutable 객체를 외부로 리턴 금지

## 상세 내용

### 가변 상태가 일으키는 문제

모듈에서 가변 상태를 가지면 다음과 같은 문제가 발생한다:

1. **추적하기 힘들어짐**: 상태가 언제 어디서 변경되었는지 추적이 어려움
2. **예기치 못한 오류**: 수정 시 의도하지 않은 부작용 발생
3. **멀티스레드 동기화 필요**: 여러 스레드에서 접근 시 동기화 처리 필요
4. **테스트 어려움**: 상태 조합이 많아져 테스트 케이스 증가
5. **변경의 파급 효과**: 한 곳의 변경이 다른 부분에 영향을 줄 수 있음

### var보다는 val

**기본 원칙**

```kotlin
// ❌ 가변
var count = 0
count++  // 언제든 변경 가능

// ✅ 불변
val count = 0
// count++  // 컴파일 에러
```

**getter 주의사항**

val이라도 getter를 사용하면 호출 시점에 값을 계산하므로 스마트캐스트를 사용할 수 없다.

```kotlin
val name: String?
    get() = computeName()  // 매번 다른 값을 반환할 수 있음

if (name != null) {
    // 스마트캐스트 불가
    // println(name.length)  // 컴파일 에러
}
```

이유: getter는 호출할 때마다 다른 값을 반환할 수 있어서, 첫 번째 검사 후 두 번째 접근 시 값이 달라질 수 있음

### mutable보다는 immutable

**컬렉션 불변성**

```kotlin
// ❌ 가변 리스트
val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)  // 외부에서 변경 가능

// ✅ 불변 리스트
val immutableList = listOf(1, 2, 3)
// immutableList.add(4)  // 컴파일 에러
```

**읽기 전용 vs 불변**

Kotlin의 `List`는 읽기 전용(read-only)이지 완전한 불변(immutable)은 아니다.

```kotlin
val list = mutableListOf(1, 2, 3)
val readOnly: List<Int> = list  // 읽기 전용 인터페이스

list.add(4)  // mutableList를 통해서는 변경 가능
println(readOnly)  // [1, 2, 3, 4] - 변경이 반영됨
```

진정한 불변을 위해서는 방어적 복사를 사용:

```kotlin
val list = mutableListOf(1, 2, 3)
val immutable = list.toList()  // 방어적 복사
```

### 데이터 클래스의 copy

불변 객체에서 값을 변경하려면 새 인스턴스를 생성해야 한다. 데이터 클래스의 `copy` 메서드를 활용한다.

```kotlin
data class User(
    val name: String,
    val age: Int
)

val user = User("김철수", 25)
val updatedUser = user.copy(age = 26)  // 새 인스턴스 생성

// user는 그대로 (25)
// updatedUser는 새로운 인스턴스 (26)
```

**장점**
- 원본 데이터가 보존됨
- 변경 이력 추적 용이
- 스레드 안전

### mutable 객체를 외부로 리턴 금지

가변 객체를 그대로 반환하면 외부에서 내부 상태를 변경할 수 있다.

```kotlin
// ❌ 나쁜 예
class OrderService {
    private val orders = mutableListOf<Order>()

    fun getOrders(): MutableList<Order> = orders  // 내부 상태 노출
}

// ✅ 좋은 예 1: 읽기 전용 리스트 반환
class OrderService {
    private val orders = mutableListOf<Order>()

    fun getOrders(): List<Order> = orders  // 읽기 전용
}

// ✅ 좋은 예 2: 방어적 복사
class OrderService {
    private val orders = mutableListOf<Order>()

    fun getOrders(): List<Order> = orders.toList()  // 복사본 반환
}
```

### 순수 함수형 언어와의 비교

Haskell 같은 순수 함수형 언어는 모든 값이 불변이다. Kotlin은 멀티 패러다임 언어로 불변성을 권장하지만 강제하지는 않는다.

```kotlin
// Kotlin: 불변 권장
val numbers = listOf(1, 2, 3)
val doubled = numbers.map { it * 2 }  // 새 리스트 생성

// 가변도 가능 (비권장)
val mutableNumbers = mutableListOf(1, 2, 3)
mutableNumbers.replaceAll { it * 2 }  // 원본 변경
```

## 실무 적용

### Spring에서의 불변 객체

```kotlin
// DTO는 불변으로
data class OrderRequest(
    val productId: Long,
    val quantity: Int,
    val customerId: Long
)

// Entity는 프레임워크 제약으로 var 사용 가능
@Entity
class Order(
    @Id @GeneratedValue
    var id: Long? = null,

    var productId: Long,
    var quantity: Int,
    var customerId: Long
)
```

### 불변 컬렉션 활용

```kotlin
@Service
class ProductService {
    // 내부 상태는 mutable
    private val _products = mutableListOf<Product>()

    // 외부 노출은 immutable
    val products: List<Product>
        get() = _products.toList()

    fun addProduct(product: Product) {
        _products.add(product)
    }
}
```

### 상태 변경 추적

```kotlin
data class Account(
    val balance: Long,
    val version: Int = 0
) {
    fun deposit(amount: Long): Account {
        return copy(
            balance = balance + amount,
            version = version + 1
        )
    }

    fun withdraw(amount: Long): Account {
        require(balance >= amount) { "잔액 부족" }
        return copy(
            balance = balance - amount,
            version = version + 1
        )
    }
}

// 사용
var account = Account(balance = 10000)
account = account.deposit(5000)  // 새 인스턴스
account = account.withdraw(3000)  // 새 인스턴스
```

## 금융권에서의 고려사항

**거래 금액 불변성**
- 거래 금액, 계좌 잔액은 반드시 불변 객체로 관리
- 상태 변경은 새 인스턴스 생성으로 처리
- 감사 로그에서 변경 이력 추적 용이

**멀티스레드 안전성**
- 불변 객체는 동기화 없이 스레드 간 공유 가능
- 대용량 트래픽 환경에서 성능 이점

**예측 가능성**
- 불변 객체는 생성 후 상태가 변하지 않아 디버깅 쉬움
- 의도치 않은 상태 변경 방지

**주의사항**
- 성능이 중요한 부분은 가변 객체 고려 (예: 대용량 배치)
- JPA Entity는 프레임워크 제약으로 가변 필드 필요

---

**출처**
- Effective Kotlin (마르친 모스칼라)

## 관련 노트

- [[객체지향-설계-원칙]] - 불변성 섹션
- [[코틀린-타입-시스템]]
