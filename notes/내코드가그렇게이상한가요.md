---
tags: [book, oop, design, good-code]
---

# 내 코드가 그렇게 이상한가요

좋은 코드를 만드는 설계 원칙과 패턴

## 한 줄 요약

객체지향 설계 원칙(SRP, DRY, 응집도)과 실무 패턴(불변, 일급 컬렉션, 전략 패턴)을 통해 유지보수하기 좋은 코드를 작성하는 방법

## 책 정보

- **저자**: 마츠오카 켄타로 (Kentaro Matsuoka)
- **원제**: 良いコード/悪いコードで学ぶ設計入門
- **출판**: 2022년
- **주제**: 객체지향 설계, 리팩토링, 클린 코드

## 핵심 개념

### 데이터와 로직의 관계

- [[로직과 떨어진 데이터 클래스]] - 데이터 클래스의 문제점
- [[성숙한 클래스로 성장시키기]] - Value Object 패턴으로 개선
- [[불변]] - 부수효과 방지와 불변 객체
- [[응집도]] - 데이터와 로직의 결합 강도

### 설계 패턴과 원칙

- [[조건분기]] - 전략 패턴, 정책 패턴, LSP
- [[일급 컬렉션]] - 컬렉션 캡슐화 패턴
- [[결합도와 단일 책임]] - 느슨한 결합과 SRP

### 관련 설계 원칙

- [[단일 책임 원칙]] - SRP (Single Responsibility Principle)
- [[DRY 잘못된 적용으로 깨지는 SRP]] - DRY 원칙 과도 적용 주의

## 핵심 메시지

### 1. 데이터와 로직은 함께

클래스 밖에서 데이터를 조작하지 말고, 데이터를 가진 클래스 내부에 로직을 배치한다.

### 2. 불변 객체로 설계

- 인스턴스 변수는 `final`로 선언
- 변경이 필요하면 새 인스턴스 반환
- 부수효과 방지

### 3. 작은 클래스, 높은 응집도

- 클래스는 100-200줄 이내
- 하나의 관심사에만 집중
- 조기 리턴, 전략 패턴으로 복잡도 감소

### 4. 조건분기는 전략 패턴으로

- `if`/`switch` 대신 인터페이스와 Map 활용
- 새로운 타입 추가 시 기존 코드 수정 불필요 (OCP)

### 5. 컬렉션도 캡슐화

- 일급 컬렉션으로 컬렉션 로직 응집
- 유효성 검증, 불변성 보장

## 실무 적용

### Spring Boot 환경에서

```kotlin
// Value Object
data class Money(val amount: Int, val currency: Currency) {
    init {
        require(amount >= 0) { "amount must be positive" }
    }

    fun add(other: Money): Money {
        require(currency == other.currency)
        return Money(amount + other.amount, currency)
    }
}

// 일급 컬렉션
class OrderItems(items: List<OrderItem>) {
    private val _items = items.toList()

    fun calculateTotal(): Money {
        return _items
            .map { it.amount }
            .reduce { acc, money -> acc.add(money) }
    }
}

// 전략 패턴
interface PaymentStrategy {
    fun pay(amount: Money)
}

class PaymentService(
    private val strategies: Map<PaymentType, PaymentStrategy>
) {
    fun pay(type: PaymentType, amount: Money) {
        strategies[type]?.pay(amount)
    }
}
```

## 관련 책

- [[클린 코드]] (로버트 C. 마틴)
- [[리팩토링]] (마틴 파울러)
- [[오브젝트]] (조영호)

#book #oop #design
