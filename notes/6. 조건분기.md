# 6. 조건분기 

조기 리턴하고 중첩을 없애자.
else 없애자. 
----
SRP 에 따라 switch 조건 하나에 묶어야한다. 

그런데 너무 많은 로직이 들어가면 거대 클래스가 된다. 
인터페이스를 쓰서 ==전략패턴==으로 분기 자체를 쓰지 않는다. 
`magics.get(magicType)`
전략패턴은 인터페이스로 스펙을 정하기에 로직 실수 하기가 줄어든다. 
----
정책을 분기로 사용하면 같은 정책 로직이 중복이 될수 있다. 
그럴땐 정책 패턴을 사용한다. 
Rule들을 구현한 구현체의 집합을 가지고 Policy를 구성한다. 
![](6.%20%EC%A1%B0%EA%B1%B4%EB%B6%84%EA%B8%B0/image.JPG)<!-- {"width":420} -->
---
위에서 인터페이스로 조건문을 없앴는데 
만약 호텔 요금을 예로들어 
일반호텔, 프리미엄호텔을 각각 금액이 정해졌다 쳤을때 성수기 요금을 추가하려한다. 
```java
Money busySeasonFee;
if(hotelRates instanceOf RegularRates) {
  busySeasonFee = hotelRates.fee().add(new Money(30000));
}
else if(hotelRates instanceOf PremiumRates) {
  busySeasonFee = hotelRates.fee().add(new Money(50000));
}
```
인터페이스를 썼는데도 조건문을 사용한다. 
이는 LSP를 위반하는 것. 
LSP는 클래스의 기반 자료형을 하위 자료형으로 변경해도 코드는 문제없이 동작해야한다. 라는 의미
위 코드에서 hotelRates는 다른 하위 자료형으로 변경하면 로직이 깨진다. 그래서 instanceOf로 판별하는것이다.
이렇게 되는 이유는 인터페이스의 의미를 충분히 이해하지 못하고 사용해서 그런것. 
```java
interface HotelRates { 
  Money fee();
  Money busySeasonFee(); // 추가한다.
} 
```
이제 instanceof없이  사용가능. 
instanceof 있으면 LSP 위반 의심해보자. 
---
한 함수의 매개변수로 boolean인 플래그 매개변수를 넣지 말자.
true일때와 false일때 각 두가지 일을 할 확률이 높다. 
그럼 함수 예측이 어려워져서 개발 생산성이 저하된다. 
boolean 뿐 아니라 숫자도! 
이럴땐 메소드를 분리하자.
분리한 메소드들을 각 상황에 맞게 전환해야할때가 있다.
이럴땐 인터페이스로 각각 구현하여 처리한다. 
```java
a(){member.update(1)}
b(){member.update(2)}
->
interface Spec{ void execute();}
class A implements Spec {
	@Override
	public void execute(){member.update(1)}
}
class B implements Spec {
	@Override
	public void execute(){member.update(2)}
}

voidd applyDamage(SpecType type) {
  Spec spec = specs.get(type)
  spec.execute()
}

```
#dev/book/내코드가그렇게이상한가요