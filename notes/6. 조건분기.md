---
tags: [oop, design-pattern, strategy-pattern, policy-pattern]
---

# 조건분기

## 한 줄 요약

조기 리턴으로 중첩을 제거하고, 전략 패턴과 정책 패턴으로 분기문 자체를 없애 SRP를 지킨다

## 핵심 정리

- 조기 리턴으로 중첩과 else 제거
- SRP에 따라 switch 조건은 하나로 묶기
- 전략 패턴: 인터페이스로 분기 제거 (`magics.get(magicType)`)
- 정책 패턴: Rule 구현체의 집합으로 Policy 구성
- LSP 위반 징후: instanceof 사용
- 플래그 매개변수 금지: boolean/int로 분기하지 말고 메서드 분리

## 상세 내용

### 기본 원칙

**조기 리턴하고 중첩을 없애자**
- else를 없애자
- 가드 절(Guard Clause)로 조기 리턴

### SRP와 조건분기

SRP에 따라 switch 조건은 하나로 묶어야 한다.

**문제:** 너무 많은 로직이 들어가면 거대 클래스가 된다.

**해결:** 인터페이스를 사용한 **전략 패턴**으로 분기 자체를 없앤다.

```java
magics.get(magicType)  // Map에서 전략 객체 꺼내기
```

**장점:**
- 인터페이스로 스펙을 정하기에 로직 실수가 줄어듦
- 새로운 타입 추가 시 기존 코드 수정 불필요

### 전략 패턴 vs 정책 패턴

정책을 분기로 사용하면 같은 정책 로직이 중복될 수 있다.

**해결:** 정책 패턴(Policy Pattern)
- Rule들을 구현한 구현체의 집합으로 Policy를 구성
- 여러 Rule을 조합하여 복잡한 정책 표현

![](resources/images/conditional-branching-example.jpg)<!-- {"width":420} -->

### LSP(Liskov Substitution Principle) 위반 주의

**문제 상황:**

호텔 요금에 성수기 요금을 추가하려 할 때:

```java
Money busySeasonFee;
if(hotelRates instanceOf RegularRates) {
  busySeasonFee = hotelRates.fee().add(new Money(30000));
}
else if(hotelRates instanceOf PremiumRates) {
  busySeasonFee = hotelRates.fee().add(new Money(50000));
}
```

인터페이스를 썼는데도 조건문을 사용한다. 이는 **LSP 위반**이다.

**LSP란?**
클래스의 기반 자료형을 하위 자료형으로 변경해도 코드는 문제없이 동작해야 한다.

위 코드에서 hotelRates는 다른 하위 자료형으로 변경하면 로직이 깨진다. 그래서 instanceof로 판별하는 것이다.

**해결:**

```java
interface HotelRates {
  Money fee();
  Money busySeasonFee();  // 인터페이스에 추가
}
```

이제 instanceof 없이 사용 가능하다.

**원칙:** instanceof가 있으면 LSP 위반을 의심해보자.

### 플래그 매개변수 금지

한 함수의 매개변수로 boolean이나 int 같은 플래그 매개변수를 넣지 말자.

**문제:**
```java
void process(boolean flag) {
  if (flag) {
    // 작업 A
  } else {
    // 작업 B
  }
}
```

true일 때와 false일 때 각각 다른 일을 할 확률이 높다. 함수 예측이 어려워져 개발 생산성이 저하된다.

**해결 1: 메서드 분리**

```java
void processA() { /* 작업 A */ }
void processB() { /* 작업 B */ }
```

**해결 2: 전략 패턴으로 전환**

분리한 메서드들을 상황에 맞게 전환해야 할 때는 인터페이스로 구현:

```java
// Before
void a() { member.update(1); }
void b() { member.update(2); }

// After
interface Spec {
  void execute();
}

class A implements Spec {
  @Override
  public void execute() { member.update(1); }
}

class B implements Spec {
  @Override
  public void execute() { member.update(2); }
}

void applyDamage(SpecType type) {
  Spec spec = specs.get(type);
  spec.execute();
}
```

## 실무 적용

### Spring에서의 전략 패턴

```java
@Component
public class PaymentStrategyFactory {
    private final Map<PaymentType, PaymentStrategy> strategies;

    public PaymentStrategyFactory(List<PaymentStrategy> strategyList) {
        strategies = strategyList.stream()
            .collect(Collectors.toMap(
                PaymentStrategy::getType,
                Function.identity()
            ));
    }

    public PaymentStrategy getStrategy(PaymentType type) {
        return strategies.get(type);
    }
}
```

### 주의사항

- 전략이 너무 많아지면 관리가 어려워질 수 있음
- 간단한 분기는 그냥 if문이 더 명확할 수 있음
- 과도한 패턴 적용보다 상황에 맞는 판단이 중요

## 관련 노트

- [[단일 책임 원칙]]
- [[디자인패턴]]
- [[5장. 응집도]]

#design-pattern #strategy-pattern #srp