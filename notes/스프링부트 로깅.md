---
tags: [spring-boot, logging, logback, slf4j, log-level, appender, mdc, async-logging]
---
# Spring Boot 로깅

## 한 줄 요약

Spring Boot는 SLF4J를 추상화 계층으로, Logback을 기본 구현체로 사용하며, logback-spring.xml을 통해 Appender, Logger, 로그 레벨을 설정하여 다양한 출력 대상과 포맷을 제어한다.

## 핵심 정리

- **SLF4J**: 로깅 추상화 인터페이스 (Simple Logging Facade for Java)
- **Logback**: Spring Boot의 기본 로깅 구현체 (spring-boot-starter-logging에 포함)
- **3개 모듈**: logback-core(기반), logback-classic(Logger), logback-access(HTTP 로깅)
- **주요 구성 요소**: Logger(로그 생성), Appender(출력 대상), Encoder(포맷), Filter(필터링)
- **로그 레벨**: TRACE < DEBUG < INFO < WARN < ERROR (숫자가 클수록 심각)
- **설정 파일**: logback-spring.xml (Spring 확장 기능 지원)
- **환경별 설정**: `<springProfile>` 태그로 dev/prod 분리
- **성능**: AsyncAppender로 비동기 로깅, MDC는 ThreadLocal 사용

## 상세 내용

### SLF4J와 Logback의 관계

**SLF4J (Simple Logging Facade for Java)**
- 로깅 추상화 인터페이스
- 실제 로깅 구현체(Logback, Log4j2 등)와 분리
- 코드에서는 SLF4J API만 사용

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class UserService {
    // SLF4J Logger 선언
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    public void createUser(User user) {
        log.info("Creating user: {}", user.getName());  // SLF4J API 사용
    }
}
```

**Logback**
- SLF4J의 구현체
- Spring Boot의 기본 로깅 프레임워크
- `spring-boot-starter-web`에 자동 포함 (별도 의존성 불필요)

**의존성 관계**

```
spring-boot-starter-web
  └─ spring-boot-starter-logging
      ├─ logback-classic (Logback 구현)
      │   └─ logback-core (핵심 모듈)
      ├─ slf4j-api (SLF4J 인터페이스)
      └─ jul-to-slf4j, log4j-to-slf4j (브릿지)
```

### Logback 3개 모듈

| 모듈 | 역할 | 포함 클래스 |
|------|------|------------|
| **logback-core** | 기반 모듈 | Appender, Layout 인터페이스 |
| **logback-classic** | 확장 모듈 | Logger 클래스, SLF4J API 구현 |
| **logback-access** | HTTP 로깅 | Servlet Container 통합 (컨테이너 레벨) |

**logback-access 특징**
- 웹 애플리케이션이 아닌 **컨테이너 레벨**에서 설치
- HTTP 요청/응답 로깅 (Tomcat, Jetty 등)
- logback-classic과 독립적

### Logback 아키텍처

**핵심 구성 요소**

```
Logger (로그 생성)
  └─> Appender (출력 대상)
        └─> Encoder (포맷 변환)
              └─> Layout (패턴 정의)
```

1. **Logger**: 로그 메시지 생성 및 레벨 판단
2. **Appender**: 로그를 어디에 출력할지 결정 (콘솔, 파일, DB 등)
3. **Encoder**: 로그를 특정 포맷으로 변환
4. **Filter**: 로그 필터링 조건 정의

### 로그 레벨 (Log Level)

**5가지 레벨 (중요도 순)**

| 레벨 | 용도 | 예시 |
|------|------|------|
| **TRACE** | 가장 상세한 정보 | 루프의 각 반복, 모든 변수값 |
| **DEBUG** | 디버깅 정보 | 메서드 진입/종료, 파라미터값 |
| **INFO** | 일반 정보 | 서비스 시작/종료, 주요 비즈니스 로직 실행 |
| **WARN** | 경고 (잠재적 문제) | deprecated API 사용, 느린 쿼리 |
| **ERROR** | 에러 (기능 동작 불가) | 예외 발생, DB 연결 실패 |

**레벨 설정 원칙**
- 설정한 레벨 이상만 출력
- INFO 설정 시: INFO, WARN, ERROR만 출력 (TRACE, DEBUG 무시)
- Production: INFO 이상 권장
- Development: DEBUG 이상 권장

**코드 예시**

```kotlin
log.trace("매우 상세한 디버그 정보: userId={}, step={}", userId, step)
log.debug("메서드 진입: createOrder(userId={})", userId)
log.info("주문 생성 완료: orderId={}", orderId)
log.warn("주문 처리 시간 초과: {}ms", elapsedTime)
log.error("결제 처리 실패: orderId={}", orderId, exception)
```

### logback-spring.xml 설정

**기본 구조**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 속성 정의 -->
    <property name="LOG_PATH" value="./logs"/>
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>

    <!-- Appender 정의 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- Logger 설정 -->
    <logger name="com.example.myapp" level="DEBUG"/>

    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

### Appender 종류

#### 1. ConsoleAppender

콘솔(표준 출력)에 로그 출력

```xml
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
        <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>
```

#### 2. FileAppender

파일에 로그 출력

```xml
<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>${LOG_PATH}/application.log</file>
    <append>true</append>
    <encoder>
        <pattern>${LOG_PATTERN}</pattern>
    </encoder>
</appender>
```

#### 3. RollingFileAppender

**파일을 롤링하며 출력** (가장 많이 사용)

```xml
<appender name="ROLLING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/application.log</file>

    <!-- 롤링 정책: 날짜 기반 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>${LOG_PATH}/application-%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>30</maxHistory>  <!-- 30일 보관 -->
        <totalSizeCap>3GB</totalSizeCap>  <!-- 전체 로그 파일 최대 크기 -->
    </rollingPolicy>

    <!-- 롤링 정책: 크기 기반 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
        <maxFileSize>100MB</maxFileSize>
    </triggeringPolicy>

    <encoder>
        <pattern>${LOG_PATTERN}</pattern>
    </encoder>
</appender>
```

**롤링 정책 조합**

```xml
<!-- 날짜 + 크기 기반 롤링 -->
<rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
    <fileNamePattern>${LOG_PATH}/app-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
    <maxFileSize>100MB</maxFileSize>
    <maxHistory>30</maxHistory>
</rollingPolicy>
```

#### 4. AsyncAppender

**비동기 로깅으로 성능 향상**

```xml
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <queueSize>512</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <appender-ref ref="ROLLING_FILE"/>
</appender>
```

### Filter 활용

**ThresholdFilter: 로그 레벨 제한**

```xml
<appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/error.log</file>

    <!-- ERROR 레벨 이상만 기록 -->
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
        <level>ERROR</level>
    </filter>

    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>${LOG_PATH}/error-%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>90</maxHistory>
    </rollingPolicy>

    <encoder>
        <pattern>${LOG_PATTERN}</pattern>
    </encoder>
</appender>
```

**LevelFilter: 특정 레벨만 허용/거부**

```xml
<filter class="ch.qos.logback.classic.filter.LevelFilter">
    <level>INFO</level>
    <onMatch>ACCEPT</onMatch>
    <onMismatch>DENY</onMismatch>
</filter>
```

### Logger 설정

**패키지별 로그 레벨 지정**

```xml
<!-- 애플리케이션 패키지 -->
<logger name="com.example.myapp" level="DEBUG"/>

<!-- 특정 클래스 -->
<logger name="com.example.myapp.service.PaymentService" level="TRACE"/>

<!-- 외부 라이브러리 -->
<logger name="org.springframework.web" level="INFO"/>
<logger name="org.hibernate.SQL" level="DEBUG"/>
<logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>

<!-- Root Logger: 기본 레벨 -->
<root level="INFO">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="ROLLING_FILE"/>
</root>
```

**additivity 속성**

```xml
<!-- additivity=true (기본값): 상위 로거로 전파 -->
<logger name="com.example.myapp.service" level="DEBUG" additivity="true">
    <appender-ref ref="SERVICE_FILE"/>
</logger>
<!-- service 로그가 SERVICE_FILE + root의 appender에 모두 기록됨 -->

<!-- additivity=false: 상위 로거로 전파 안 함 -->
<logger name="com.example.myapp.service" level="DEBUG" additivity="false">
    <appender-ref ref="SERVICE_FILE"/>
</logger>
<!-- service 로그가 SERVICE_FILE에만 기록됨 (중복 방지) -->
```

### Spring Boot 통합 기능

#### springProfile: 환경별 설정

```xml
<!-- 개발 환경 -->
<springProfile name="dev">
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="DEBUG">
        <appender-ref ref="CONSOLE"/>
    </root>
</springProfile>

<!-- 운영 환경 -->
<springProfile name="prod">
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 파일 설정 -->
    </appender>

    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</springProfile>
```

#### springProperty: application.yml 속성 가져오기

```yaml
# application.yml
logging:
  file:
    path: /var/log/myapp
    name: application.log
  level:
    root: INFO
```

```xml
<!-- logback-spring.xml -->
<springProperty scope="context" name="logPath" source="logging.file.path"/>
<springProperty scope="context" name="logName" source="logging.file.name"/>

<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>${logPath}/${logName}</file>
    <encoder>
        <pattern>${LOG_PATTERN}</pattern>
    </encoder>
</appender>
```

### Log Pattern 옵션

**주요 패턴**

| 패턴 | 설명 | 예시 |
|------|------|------|
| `%d{pattern}` | 날짜/시간 | `%d{yyyy-MM-dd HH:mm:ss.SSS}` |
| `%thread` | 스레드 이름 | `http-nio-8080-exec-1` |
| `%-5level` | 로그 레벨 (좌측 정렬, 5자리) | `INFO `, `ERROR` |
| `%logger{length}` | 로거 이름 (축약) | `c.e.m.UserService` |
| `%msg` | 로그 메시지 | `User created` |
| `%n` | 줄바꿈 | |
| `%class` | 클래스명 | `UserService` |
| `%method` | 메서드명 | `createUser` |
| `%line` | 라인 번호 | `42` |
| `%ex` | 예외 스택 트레이스 | |

**색상 지원**

```xml
<pattern>
    %d{HH:mm:ss.SSS}
    %highlight(%-5level)
    %cyan(%logger{36})
    %magenta([%thread])
    - %msg%n
</pattern>
```

**실용적인 패턴 예시**

```xml
<!-- 개발 환경: 간결 + 색상 -->
<pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>

<!-- 운영 환경: 상세 정보 -->
<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} [%method:%line] - %msg%n</pattern>

<!-- JSON 형식 (ELK 스택 연동) -->
<encoder class="net.logstash.logback.encoder.LogstashEncoder"/>
```

## 실무 적용

### 1. 환경별 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property name="LOG_PATH" value="./logs"/>
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>

    <!-- 개발 환경: 콘솔만 -->
    <springProfile name="dev,local">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
            </encoder>
        </appender>

        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>

        <logger name="org.springframework" level="INFO"/>
        <logger name="com.zaxxer.hikari" level="INFO"/>
    </springProfile>

    <!-- 운영 환경: 파일 + 비동기 -->
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>${LOG_PATH}/application.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                <fileNamePattern>${LOG_PATH}/application-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>10GB</totalSizeCap>
            </rollingPolicy>
            <encoder>
                <pattern>${LOG_PATTERN}</pattern>
            </encoder>
        </appender>

        <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
            <queueSize>512</queueSize>
            <appender-ref ref="FILE"/>
        </appender>

        <root level="INFO">
            <appender-ref ref="ASYNC"/>
        </root>
    </springProfile>
</configuration>
```

### 2. 레벨별 파일 분리

```xml
<!-- INFO 레벨 -->
<appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/info.log</file>
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
        <level>INFO</level>
        <onMatch>ACCEPT</onMatch>
        <onMismatch>DENY</onMismatch>
    </filter>
    <!-- 롤링 정책 -->
</appender>

<!-- ERROR 레벨 -->
<appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/error.log</file>
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
        <level>ERROR</level>
    </filter>
    <!-- 롤링 정책 -->
</appender>

<root level="INFO">
    <appender-ref ref="INFO_FILE"/>
    <appender-ref ref="ERROR_FILE"/>
</root>
```

### 3. MDC (Mapped Diagnostic Context) 활용

**요청별 추적 ID 추가**

```kotlin
@Component
class RequestIdFilter : OncePerRequestFilter() {
    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val requestId = UUID.randomUUID().toString()
        MDC.put("requestId", requestId)

        try {
            filterChain.doFilter(request, response)
        } finally {
            MDC.clear()
        }
    }
}
```

**로그 패턴에 MDC 포함**

```xml
<pattern>%d{HH:mm:ss.SSS} [%X{requestId}] %-5level %logger{36} - %msg%n</pattern>
```

**출력 예시**

```
12:34:56.789 [a1b2c3d4-e5f6-7890] INFO  c.e.m.UserService - Creating user: Alice
12:34:56.801 [a1b2c3d4-e5f6-7890] INFO  c.e.m.OrderService - Creating order for user: Alice
```

### 4. SQL 로깅 (Hibernate)

```xml
<!-- SQL 쿼리 -->
<logger name="org.hibernate.SQL" level="DEBUG"/>

<!-- SQL 파라미터 바인딩 -->
<logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>

<!-- 쿼리 결과 -->
<logger name="org.hibernate.type.descriptor.sql.BasicExtractor" level="TRACE"/>
```

**또는 application.yml**

```yaml
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

### 5. 성능 최적화: 비동기 로깅

```xml
<appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
    <!-- 큐 크기 -->
    <queueSize>512</queueSize>

    <!-- 큐가 80% 차면 TRACE/DEBUG/INFO 버림 (0으로 설정하면 버리지 않음) -->
    <discardingThreshold>0</discardingThreshold>

    <!-- 큐가 가득 차면 블로킹 여부 -->
    <neverBlock>false</neverBlock>

    <!-- 실제 로그를 기록할 Appender -->
    <appender-ref ref="ROLLING_FILE"/>
</appender>
```

## 주의사항 및 트러블슈팅

### 1. 로그 파일 권한 문제

**문제**: 로그 파일 쓰기 권한 없음

**해결**:
```bash
# 로그 디렉토리 생성 및 권한 부여
mkdir -p /var/log/myapp
chown -R app-user:app-group /var/log/myapp
chmod 755 /var/log/myapp
```

### 2. 로그 파일 누적

**문제**: 로그 파일이 계속 쌓여 디스크 부족

**해결**: 롤링 정책에 maxHistory 설정

```xml
<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <fileNamePattern>${LOG_PATH}/app-%d{yyyy-MM-dd}.log</fileNamePattern>
    <maxHistory>30</maxHistory>  <!-- 30일 이후 자동 삭제 -->
    <totalSizeCap>10GB</totalSizeCap>  <!-- 전체 10GB 초과 시 오래된 것부터 삭제 -->
</rollingPolicy>
```

### 3. MDC 메모리 누수

**문제**: MDC 값을 clear하지 않아 ThreadLocal 메모리 누수

**해결**: 반드시 finally에서 clear

```kotlin
try {
    MDC.put("key", "value")
    // 로직
} finally {
    MDC.clear()  // 필수!
}
```

### 4. 과도한 로깅으로 성능 저하

**문제**: DEBUG 레벨 로그가 너무 많아 성능 저하

**해결**:
- 운영 환경은 INFO 이상으로 제한
- 비동기 Appender 사용
- 조건부 로깅

```kotlin
// ❌ 나쁜 예: 항상 문자열 연산 수행
log.debug("User data: " + user.toString())

// ✅ 좋은 예: 로그 레벨이 DEBUG일 때만 연산
if (log.isDebugEnabled) {
    log.debug("User data: {}", user)
}

// ✅ 더 좋은 예: SLF4J의 파라미터 치환 활용
log.debug("User data: {}", user)  // DEBUG 아니면 toString() 호출 안 함
```

### 5. 민감 정보 로깅

**문제**: 로그에 비밀번호, 카드번호 등 민감 정보 노출

**해결**:
- 민감 정보는 절대 로깅 금지
- 필요시 마스킹 처리

```kotlin
data class User(
    val id: Long,
    val email: String,
    @JsonIgnore  // JSON 직렬화 제외
    val password: String
) {
    override fun toString(): String {
        return "User(id=$id, email=$email, password=***)"
    }
}
```

## 금융권에서의 고려사항

- **감사 로그 분리**: 비즈니스 로그와 감사 로그 별도 Appender로 분리
- **장기 보관**: 금융 거래 로그는 최소 5년 이상 보관 (규제 준수)
- **민감 정보 마스킹**: 카드번호, 계좌번호, 주민번호 등 반드시 마스킹
- **무결성 보장**: 로그 파일 변조 방지 (읽기 전용, 체크섬)
- **실시간 모니터링**: ERROR 로그 발생 시 즉시 알림 (Slack, 이메일)
- **성능 영향 최소화**: 비동기 로깅 필수, 운영은 INFO 이상
- **로그 중앙화**: ELK Stack 등으로 로그 수집 및 분석

**예시: 감사 로그 분리**

```xml
<!-- 감사 로그 전용 Appender -->
<appender name="AUDIT_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/audit.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>${LOG_PATH}/audit-%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>1825</maxHistory>  <!-- 5년 보관 -->
    </rollingPolicy>
    <encoder>
        <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{userId}] [%X{txId}] - %msg%n</pattern>
    </encoder>
</appender>

<!-- 감사 로그 전용 Logger -->
<logger name="AUDIT" level="INFO" additivity="false">
    <appender-ref ref="AUDIT_FILE"/>
</logger>
```

```kotlin
// 사용 예시
class AuditLogger {
    private val auditLog = LoggerFactory.getLogger("AUDIT")

    fun logTransaction(userId: String, txId: String, action: String, amount: Money) {
        MDC.put("userId", userId)
        MDC.put("txId", txId)
        try {
            auditLog.info("action={}, amount={}, currency={}",
                action, amount.value, amount.currency)
        } finally {
            MDC.clear()
        }
    }
}
```

## 관련 노트

- [[API requestresponse 로깅]]

---

**출처**
- Spring Boot Reference Documentation
- Logback Manual
