---
tags: [design-pattern, kotlin, behavioral]
---

# 기억 패턴 (메멘토 패턴)

## 한 줄 요약

객체의 이전 상태를 저장하고 복원할 수 있게 하는 패턴

## 핵심 정리

- 이전 상태를 복원할 필요가 있는 애플리케이션에서 유용
- 실무에서 볼 일은 많지 않음
- 내부 클래스를 사용하여 바깥 클래스의 비공개 필드에 접근

## 상세 내용

### 구현 예제

```kotlin
fun main() {
    val michael = Manager()
    michael.think("Need to implement Coconut Cannon")
    michael.think("Should get some coffee")
    val memento = michael.saveThatThought()
    with(michael) {
        think("Or maybe tea?")
        think("No, actually, let's implement Pineapple Launcher")
    }
    michael.printThoughts()
    michael.`what was I thinking back then?`(memento)
    michael.printThoughts()
}

class Manager {
    private var thoughts = mutableListOf<String>()

    fun printThoughts() {
        println(thoughts)
    }

    // 정적 중첩 클래스와 다르게 내부 클래스는 바깥쪽 클래스의 비공개 필드에 접근할 수 있다.
    inner class Memory(private val mindState: List<String>) {
        fun restore() {
            thoughts = mindState.toMutableList()
        }
    }

    fun saveThatThought(): Memory {
        return Memory(thoughts.toList())
    }

    fun `what was I thinking back then?`(memory: Memory) {
        memory.restore()
    }

    fun think(thought: String) {
        thoughts.add(thought)
        if (thoughts.size > 2) {
            thoughts.removeFirst()
        }
    }
}
```

### 특징

- `inner class`를 사용하여 외부 클래스의 private 필드에 접근
- 상태의 스냅샷을 생성하고 복원
- 캡슐화를 유지하면서 상태 저장
- Undo/Redo 기능 구현에 활용 가능

### 주의사항

실무에서 볼 일은 많지 않지만, 이전의 상태를 복원할 필요가 있는 애플리케이션에서는 유용하다.

---

**출처**
- 코틀린 디자인 패턴
