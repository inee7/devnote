---
tags: [design-pattern, kotlin, structural]
---

# 데코레이터 패턴

## 한 줄 요약

상속 대신 구성을 사용하여 객체에 동적으로 기능을 추가하는 패턴

## 핵심 정리

- 수정하면 안 되는 클래스에 기능을 추가할 때 사용
- 상속을 사용하면 기능이 추가될 때마다 새로운 클래스를 만들어야 하는 문제 해결
- 추가되는 기능들을 클래스로 만들고 조합하는 방식
- 인터페이스를 구현하면서 추가 동작을 하는 클래스들
- 인터페이스 구현체를 가진 데코레이터로 계속 붙일 수 있음

## 상세 내용

### 프로토타입 패턴과의 차이
- 프로토타입 패턴: 속성을 조금씩 다르게 여럿 만들 수 있음
- 데코레이터 패턴: 동작을 조금씩 다르게 여럿 만들 수 있음

### 구현 방법

기능을 추가하고 싶은 객체를 인자로 받아 인터페이스로 위임한다. 상속하지 않기 때문에 super를 사용하지 않는다.

```kotlin
class LoggingGetCaptain(private val repository: StarTrekRepository): StarTrekRepository by repository {
    override fun getCaptain(starshipName: String): String {
        println("$starshipName 함선의 선장을 조회 중입니다.")
        return repository.getCaptain(starshipName)
    }
}
```

### 프록시 패턴과의 차이

- 데코레이터: 추가 동작을 하지만 요청한 동작은 항상 그대로 수행
- 프록시: 프록시를 모르게 하기 위해 실제 구현체를 가진 클래스. 완전히 다른 식으로 동작할 수 있음

---

**출처**
- 코틀린 디자인 패턴
