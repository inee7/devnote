---
tags: [oop, design, immutable, value-object]
---

# 성숙한 클래스로 성장시키기

## 한 줄 요약

생성자 유효성 검증, 로직 포함, 불변 설계를 통해 데이터 클래스를 성숙한 Value Object로 성장시킨다

## 핵심 정리

- 생성자에서 유효성 검증으로 잘못된 상태 방지
- 데이터를 조작하는 로직을 같은 클래스에 배치
- `final` 키워드로 불변 필드 만들기
- 변경이 필요하면 새 인스턴스 반환
- 매개변수도 타입 안전하게 (int 대신 Money)
- 의미 없는 메서드는 미리 만들지 않기

## 상세 내용

### 출발점: 전형적인 데이터 클래스

```java
class Money {
	int amount;
	Currency currency;
}
```

인스턴스 변수만 갖고 있는 전형적인 데이터 클래스

### 1단계: 생성자로 정상적인 값 설정

```java
Money(int amount, Currency currency) {
	if(amount < 0) {
		throw new IllegalArgumentException("amount must be positive");
	}
	if(currency == null) {
		throw new IllegalArgumentException("currency must not be null");
	}

	this.amount = amount;
	this.currency = currency;
}
```

**효과:**
- 인스턴스 변수가 무조건 초기화됨
- 유효성 검사로 잘못된 상태 방지

### 2단계: 로직도 포함시키기

```java
class Money {
	void add(int other) {
		amount += other;
	}
}
```

데이터를 조작하는 로직을 같은 클래스에 배치하여 응집도를 높인다.

### 3단계: 불변 변수로 예상하지 못한 동작 막기

**문제 상황:**
```java
money.amount = xxx
money.add(xxx)
money.amount = xxx
```

변수의 값이 계속 바뀌면 예상치 못한 부수효과가 발생할 수 있다.

**해결:**
```java
class Money {
	final int amount;
	final Currency currency;
}
```

`final`을 붙여 한 번만 할당할 수 있게 한다.

### 4단계: 변경하고 싶다면 새로운 인스턴스 만들기

```java
Money add(int other) {
	int added = amount + other;
	return new Money(added, currency);
}
```

로직이 변경을 하는 로직이라면 인스턴스가 변하지 않게 **새로운 인스턴스를 만들어 반환**한다.

### 5단계: 메서드 매개변수와 지역 변수도 불변으로 만들기

메서드 매개변수에도 `final`을 붙여 재할당을 방지한다.

### 6단계: 엉뚱한 값을 전달하지 않도록 하기

**문제:**
```java
money.add(ticketCount)  // int를 받으면 실수 가능
```

**해결:**
```java
Money add(final Money other) {
	int added = amount + other.amount;
	return new Money(added, currency);
}
```

타입을 명확하게 하여 실수를 컴파일 타임에 방지한다.

### 7단계: 의미 없는 메서드 추가하지 않기

"나중에 사용할 것 같아서" 선의로 메서드를 미리 만들면 버그가 될 수 있다.

**원칙:** 필요할 때 만든다 (YAGNI - You Aren't Gonna Need It)

## 실무 적용

### Value Object 패턴

이렇게 성장시킨 클래스는 DDD의 **Value Object** 패턴과 일치한다:
- 불변성
- 동등성 비교 (값 비교)
- 유효성 자체 검증
- 부수효과 없음

### Kotlin에서의 구현

```kotlin
data class Money(
	val amount: Int,
	val currency: Currency
) {
	init {
		require(amount >= 0) { "amount must be positive" }
	}

	fun add(other: Money): Money {
		require(currency == other.currency) { "currency must match" }
		return Money(amount + other.amount, currency)
	}
}
```

Kotlin의 `data class`와 `val`로 더 간결하게 구현 가능하다.

## 관련 노트

- [[데이터-클래스-안티패턴]]
- [[불변]]
- [[응집도]]

---

**출처**
- 내 코드가 그렇게 이상한가요 (마츠오카 켄타로), 3.2장

#oop #value-object #immutable