---
tags: [kotlin, operator-overloading, convention, DSL]
---

## 한 줄 요약

코틀린의 연산자 오버로딩과 관례를 통해 자연스럽고 직관적인 DSL 스타일 코드를 작성할 수 있다.

## 핵심 정리

- `operator` 키워드로 연산자 오버로딩 구현 (`plus`, `minus`, `times` 등)
- 비교 연산자 (`compareTo`), 동등성 (`equals`), 인덱스 접근 (`get`/`set`) 지원
- 구조 분해 선언으로 여러 변수 동시 초기화 (`component1`, `component2` 등)
- 위임 프로퍼티 (`by`)로 프로퍼티 접근 로직 재사용
- `in` 관례, `rangeTo`, `iterator` 등으로 컬렉션 처리 간소화

## 상세 내용

### 산술 연산자 오버로딩

#### 이항 산술 연산

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2)  /* Point(x=40, y=60) */

/* 확장 함수로 정의 */
operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```

오버로딩 가능한 이항 산술 연산자:

| 식 | 함수 이름 |
|----|---------|
| `a + b` | `plus` |
| `a - b` | `minus` |
| `a * b` | `times` |
| `a / b` | `div` |
| `a % b` | `mod` (1.1부터 `rem`) |

```kotlin
/* 다른 타입과의 연산 */
operator fun Point.times(scale: Double): Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}

val p = Point(10, 20)
println(p * 1.5)  /* Point(x=15, y=30) */
```

#### 복합 대입 연산자

```kotlin
var p = Point(1, 2)
p += Point(3, 4)
println(p)  /* Point(x=4, y=6) */

/* plusAssign 정의 */
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}

val numbers = ArrayList<Int>()
numbers += 42
println(numbers[0])  /* 42 */
```

#### 단항 연산자

```kotlin
operator fun Point.unaryMinus(): Point {
    return Point(-x, -y)
}

val p = Point(10, 20)
println(-p)  /* Point(x=-10, y=-20) */
```

단항 연산자:

| 식 | 함수 이름 |
|----|---------|
| `+a` | `unaryPlus` |
| `-a` | `unaryMinus` |
| `!a` | `not` |
| `++a`, `a++` | `inc` |
| `--a`, `a--` | `dec` |

### 비교 연산자 오버로딩

#### 동등성 연산자: equals

```kotlin
class Point(val x: Int, val y: Int) {
    override fun equals(obj: Any?): Boolean {
        if (obj === this) return true
        if (obj !is Point) return false
        return obj.x == x && obj.y == y
    }
}

println(Point(10, 20) == Point(10, 20))  /* true */
println(Point(10, 20) != Point(5, 5))  /* true */
println(null == Point(5, 5))  /* false */
```

#### 순서 연산자: compareTo

```kotlin
class Person(
    val firstName: String,
    val lastName: String
) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValuesBy(this, other,
            Person::lastName, Person::firstName)
    }
}

val p1 = Person("Alice", "Smith")
val p2 = Person("Bob", "Johnson")
println(p1 < p2)  /* false */
```

### 컬렉션과 범위 관례

#### 인덱스 연산자: get과 set

```kotlin
operator fun Point.get(index: Int): Int {
    return when(index) {
        0 -> x
        1 -> y
        else -> throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

val p = Point(10, 20)
println(p[1])  /* 20 */

/* 변경 가능한 인덱스 접근 */
data class MutablePoint(var x: Int, var y: Int)

operator fun MutablePoint.set(index: Int, value: Int) {
    when(index) {
        0 -> x = value
        1 -> y = value
        else -> throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

val p = MutablePoint(10, 20)
p[1] = 42
println(p)  /* MutablePoint(x=10, y=42) */
```

#### in 관례

```kotlin
data class Rectangle(val upperLeft: Point, val lowerRight: Point)

operator fun Rectangle.contains(p: Point): Boolean {
    return p.x in upperLeft.x until lowerRight.x &&
           p.y in upperLeft.y until lowerRight.y
}

val rect = Rectangle(Point(10, 20), Point(50, 50))
println(Point(20, 30) in rect)  /* true */
println(Point(5, 5) in rect)  /* false */
```

#### rangeTo 관례

```kotlin
val now = LocalDate.now()
val vacation = now..now.plusDays(10)
println(now.plusWeeks(1) in vacation)  /* true */

/* for 루프 */
for (i in 0..n) {
    println(i)
}

(0..n).forEach { println(it) }
```

#### iterator 관례

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> =
    object : Iterator<LocalDate> {
        var current = start

        override fun hasNext() =
            current <= endInclusive

        override fun next() = current.apply {
            current = plusDays(1)
        }
    }

val newYear = LocalDate.ofYearDay(2017, 1)
val daysOff = newYear.minusDays(1)..newYear

for (dayOff in daysOff) {
    println(dayOff)
}
/* 2016-12-31
   2017-01-01 */
```

### 구조 분해 선언

```kotlin
val p = Point(10, 20)
val (x, y) = p
println(x)  /* 10 */
println(y)  /* 20 */

/* data 클래스가 아닌 경우 */
class Point(val x: Int, val y: Int) {
    operator fun component1() = x
    operator fun component2() = y
}

/* Map 이터레이션 */
fun printEntries(map: Map<String, String>) {
    for ((key, value) in map) {
        println("$key -> $value")
    }
}

val map = mapOf("Oracle" to "Java", "JetBrains" to "Kotlin")
printEntries(map)
/* Oracle -> Java
   JetBrains -> Kotlin */
```

### 위임 프로퍼티

#### by lazy()

```kotlin
class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
}

val p = Person("Alice")
p.emails  /* Load emails for Alice (최초 1회만 로드) */
p.emails  /* 캐시된 값 사용 */
```

#### 위임 프로퍼티 구현

```kotlin
class ObservableProperty(
    var propValue: Int,
    val changeSupport: PropertyChangeSupport
) {
    operator fun getValue(p: Person, prop: KProperty<*>): Int = propValue

    operator fun setValue(p: Person, prop: KProperty<*>, newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        changeSupport.firePropertyChange(prop.name, oldValue, newValue)
    }
}

class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    var age: Int by ObservableProperty(age, changeSupport)
    var salary: Int by ObservableProperty(salary, changeSupport)
}
```

#### 프로퍼티 값을 맵에 저장

```kotlin
class Person {
    private val _attributes = hashMapOf<String, String>()

    fun setAttribute(attrName: String, value: String) {
        _attributes[attrName] = value
    }

    val name: String by _attributes
}
```

## 관련 노트

- [[코틀린-클래스와-상속]] - 클래스 정의와 메소드
- [[코틀린-기본-문법]] - 연산자와 식

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 7장
