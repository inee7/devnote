---
tags: [design-pattern, kotlin, behavioral]
---

# 중개인 패턴 (미디에이터 패턴)

## 한 줄 요약

객체 간 직접 통신 대신 중개자를 통해 통신하도록 하여 결합도를 낮추는 패턴

## 핵심 정리

- 객체들 간의 복잡한 통신을 중개자가 관리
- 객체 간 직접 참조를 제거하여 결합도 감소
- 관찰자 패턴과 다르게 런타임에 구독/구독 취소가 불가능

## 상세 내용

### 구현 예제

```kotlin
fun main() {
    val productManager = Michael
    val company = MyCompany(productManager)
    company.taskCompleted(true)
}

interface ProductManager {
    fun isAllGood(majorRelease: Boolean): Boolean
}

object Michael : Canary, ProductManager {
    private val kenny = Kenny(this)
    private val brad = Brad(this)

    override fun isAllGood(majorRelease: Boolean): Boolean {
        if (!kenny.isEating() && !kenny.isSleeping()) {
            println(kenny.doesMyCodeWork())
        } else if (!brad.isEating() && !brad.isSleeping()) {
            println(brad.doesMyCodeWork())
        }
        return true
    }
}

interface Canary {

}

interface QA {
    fun doesMyCodeWork(): Boolean
}

interface Parrot {
    fun isEating(): Boolean
    fun isSleeping(): Boolean
}

class Kenny(private val productManager: ProductManager) : QA, Parrot {
    override fun isSleeping(): Boolean {
        return false
    }

    override fun isEating(): Boolean {
        return false
    }

    override fun doesMyCodeWork(): Boolean {
        return true
    }
}

class Brad(private val productManager: ProductManager) : QA, Parrot {
    override fun isSleeping(): Boolean {
        return false
    }

    override fun isEating(): Boolean {
        return false
    }

    override fun doesMyCodeWork(): Boolean {
        return true
    }
}

object Me

class MyCompany(private val productManager: ProductManager) {
    fun taskCompleted(isMajorRelease: Boolean) {
        println(productManager.isAllGood(isMajorRelease))
    }
}
```

### 특징

- 중개자(ProductManager)가 여러 객체 간의 상호작용을 조정
- 각 객체는 중개자만 알고 다른 객체를 직접 알 필요 없음
- 복잡한 통신 로직을 중개자에 집중

### 관찰자 패턴과의 차이

중개인 패턴은 관찰자 패턴과 다르게 구독자가 런타임에 구독 및 구독 취소가 불가능하다.

## 관련 노트

- [[디자인패턴-관찰자]] - 일대다 알림 패턴 (중개인은 다대다 통신 조정)

---

**출처**
- 코틀린 디자인 패턴
