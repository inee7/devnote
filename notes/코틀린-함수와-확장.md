---
tags: [kotlin, function, extension-function, collection]
---

## 한 줄 요약

코틀린은 확장 함수, 디폴트 파라미터, 중위 함수 등을 통해 자바보다 유연하고 표현력 있는 함수 정의를 제공한다.

## 핵심 정리

- 확장 함수로 기존 클래스에 메소드를 추가할 수 있음
- 디폴트 파라미터와 이름 붙인 인자로 함수 오버로딩 없이 유연한 호출 가능
- 최상위 함수와 프로퍼티로 정적 유틸리티 클래스 불필요
- 가변 인자(vararg)와 중위 함수로 DSL 같은 코드 작성 가능
- 로컬 함수로 코드 중복 제거 및 구조화

## 상세 내용

### 컬렉션과 함수

코틀린은 자바 컬렉션을 그대로 사용하면서 더 많은 기능을 제공한다.

```kotlin
val set = hashSetOf(1, 7, 53)
val list = arrayListOf(1, 7, 53)
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

/* to는 키워드가 아니라 함수 */
/* 코틀린 컬렉션 = 자바 컬렉션 */
println(set.javaClass)    /* class java.util.HashSet */
println(list.javaClass)   /* class java.util.ArrayList */

/* 자바에 없는 기능 제공 */
val strings = listOf("first", "second", "fourteenth")
println(strings.last())   /* fourteenth */

val numbers = setOf(1, 14, 2)
println(numbers.max())    /* 14 */
```

### 이름 붙인 인자와 디폴트 파라미터

함수 호출 시 인자에 이름을 붙여 가독성을 높일 수 있다.

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ", ",  /* 디폴트 값 지정 */
    prefix: String = "",
    postfix: String = ""
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

/* 다양한 호출 방식 */
val list = listOf(1, 2, 3)
println(joinToString(list))                           /* 1, 2, 3 */
println(joinToString(list, "; "))                     /* 1; 2; 3 */
println(joinToString(list, postfix = ";", prefix = "#"))  /* # 1, 2, 3; */
```

자바에서 코틀린 함수 호출 시 모든 인자를 명시해야 한다. 또는 `@JvmOverloads` 애노테이션으로 자동 오버로딩 가능하다.

### 최상위 함수와 프로퍼티

```kotlin
/* join.kt */
package strings

fun joinToString(...): String { ... }
```

컴파일 시 다음과 같이 변환:

```java
package strings;

public class JoinKt {  /* 파일명으로 클래스 이름 생성 */
    public static String joinToString(...) {
        ...
    }
}
```

#### 최상위 프로퍼티

```kotlin
var opCount = 0

fun performOperation() {
    opCount++
}

/* 상수는 const로 선언 */
const val UNIX_LINE_SEPARATOR = "\n"
```

`const`를 사용하면 자바의 `public static final` 필드로 컴파일된다.

### 확장 함수

확장 함수는 기존 클래스에 메소드를 추가할 수 있는 강력한 기능이다.

```kotlin
package strings

/* String 클래스에 lastChar 메소드 추가 */
fun String.lastChar(): Char = this.get(this.length - 1)

/* this는 생략 가능 */
fun String.lastChar(): Char = get(length - 1)

/* 사용 */
println("Kotlin".lastChar())  /* n */
```

용어:
- **수신 객체 타입(receiver type)**: `String`
- **수신 객체(receiver object)**: `"Kotlin"`

특징:
- 확장 함수는 캡슐화를 깨지 않음 - `private`, `protected` 멤버 접근 불가
- 확장 함수는 **오버라이드 불가능**
- 임포트 필요 - `import strings.lastChar` 또는 `import strings.*`
- `as`로 이름 변경 가능 - `import strings.lastChar as last`

```kotlin
/* 확장 함수로 joinToString 개선 */
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

val list = listOf(1, 2, 3)
println(list.joinToString(separator = "; ", prefix = "(", postfix = ")"))
/* (1; 2; 3) */
```

#### 확장 프로퍼티

```kotlin
val String.lastChar: Char
    get() = get(length - 1)

/* 변경 가능한 확장 프로퍼티 */
var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }

println("Kotlin".lastChar)  /* n */

val sb = StringBuilder("Kotlin?")
sb.lastChar = '!'
println(sb)  /* Kotlin! */
```

### 컬렉션 처리

#### 가변 인자 함수

```kotlin
fun listOf<T>(vararg values: T): List<T> { ... }

/* 배열을 vararg에 전달 - 스프레드 연산자 사용 */
fun main(args: Array<String>) {
    val list = listOf("args: ", *args)
    println(list)
}
```

#### 중위 함수 호출과 구조 분해 선언

```kotlin
/* to는 중위 함수 */
val map = mapOf(1 to "one", 7 to "seven")

/* 중위 함수 정의 */
infix fun Any.to(other: Any) = Pair(this, other)

/* 구조 분해 선언으로 Map 순회 */
for ((key, value) in map) {
    println("$key -> $value")
}

/* 컬렉션에 대한 구조 분해 */
for ((index, element) in collection.withIndex()) {
    println("$index: $element")
}
```

### 로컬 함수

코틀린은 함수 내부에 함수를 중첩시킬 수 있어 코드 중복을 제거할 수 있다.

```kotlin
/* 코드 중복 예제 */
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
    if (user.name.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Name")
    }
    if (user.address.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Address")
    }
    /* 실제 저장 로직 */
}
```

로컬 함수로 개선:

```kotlin
fun saveUser(user: User) {
    /* 로컬 함수로 검증 로직 추출 */
    fun validate(value: String, fieldName: String) {
        if (value.isEmpty()) {
            throw IllegalArgumentException(
                "Can't save user ${user.id}: empty $fieldName"
            )
        }
    }

    validate(user.name, "Name")
    validate(user.address, "Address")
    /* 실제 저장 로직 */
}
```

확장 함수로 더 개선:

```kotlin
fun User.validateBeforeSave() {
    fun validate(value: String, fieldName: String) {
        if (value.isEmpty()) {
            throw IllegalArgumentException(
                "Can't save user $id: empty $fieldName"
            )
        }
    }

    validate(name, "Name")
    validate(address, "Address")
}

fun saveUser(user: User) {
    user.validateBeforeSave()
    /* 실제 저장 로직 */
}
```

## 관련 노트

- [[코틀린-기본-문법]] - 함수 기초와 식이 본문인 함수
- [[코틀린-람다와-컬렉션]] - 컬렉션과 확장 함수
- [[코틀린-고차함수]] - 고차함수와 함수 타입

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 3장
