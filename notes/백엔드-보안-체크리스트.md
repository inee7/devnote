---
tags: [보안, 인증, 인가, 입력값검증, 백엔드]
---

## 한 줄 요약

백엔드 API는 입력값 검증과 인증/인가를 철저히 구현하여 보안 취약점을 방지한다.

## 핵심 정리

- 모든 입력값은 검증 필수 (특히 조건부 파라미터)
- 인증(Authentication) 후 반드시 인가(Authorization) 확인
- 리소스 소유권 검증으로 수평적 권한 상승 방지
- 어드민 기능은 별도 인증/인가 체계 구축
- Query DSL로 동적 쿼리 구성 시 입력값 검증 철저히

## 상세 내용

### 입력값 검증

#### 기본 원칙

**모든 입력값은 신뢰할 수 없다**

```kotlin
@PostMapping("/users")
fun createUser(@RequestBody @Valid request: CreateUserRequest): User {
    // @Valid로 기본 검증은 되지만, 비즈니스 로직 검증도 필요
    validateBusinessRules(request)
    return userService.create(request)
}
```

입력값 검증 레벨:
1. **형식 검증**: `@Valid`, `@NotNull`, `@Size` 등 (Bean Validation)
2. **비즈니스 검증**: 도메인 규칙에 맞는지 확인
3. **컨텍스트 검증**: 현재 상태에서 유효한 요청인지 확인

#### 조건부 파라미터 검증

**문제 상황**

```kotlin
data class SearchRequest(
    val keyword: String?,
    val categoryId: Long?,
    val startDate: LocalDate?,
    val endDate: LocalDate?
)

// 위험: 둘 중 하나만 와야 하는데 검증 없음
@GetMapping("/products/search")
fun search(request: SearchRequest): List<Product> {
    // keyword나 categoryId 중 하나는 필수인데 둘 다 null일 수 있음
}
```

**해결: 커스텀 검증**

```kotlin
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = [AtLeastOneOfValidator::class])
annotation class AtLeastOneOf(
    val fields: Array<String>,
    val message: String = "At least one field must be provided"
)

@AtLeastOneOf(fields = ["keyword", "categoryId"])
data class SearchRequest(
    val keyword: String?,
    val categoryId: Long?,
    val startDate: LocalDate?,
    val endDate: LocalDate?
)

class AtLeastOneOfValidator : ConstraintValidator<AtLeastOneOf, Any> {
    private lateinit var fields: Array<String>

    override fun initialize(constraintAnnotation: AtLeastOneOf) {
        fields = constraintAnnotation.fields
    }

    override fun isValid(value: Any?, context: ConstraintValidatorContext): Boolean {
        if (value == null) return false

        return fields.any { fieldName ->
            val field = value::class.java.getDeclaredField(fieldName)
            field.isAccessible = true
            field.get(value) != null
        }
    }
}
```

#### Query DSL 사용 시 검증

**동적 쿼리 구성 시 주의**

```kotlin
fun searchProducts(request: SearchRequest): List<Product> {
    val query = queryFactory.selectFrom(product)

    // 조건 추가 전에 검증 필수
    request.keyword?.let { keyword ->
        require(keyword.isNotBlank()) { "Keyword must not be blank" }
        require(keyword.length <= 100) { "Keyword too long" }
        query.where(product.name.contains(keyword))
    }

    request.categoryId?.let { categoryId ->
        require(categoryId > 0) { "Invalid category ID" }
        query.where(product.categoryId.eq(categoryId))
    }

    return query.fetch()
}
```

주의사항:
- 빈 문자열, 음수, 과도하게 긴 값 등 방어
- SQL Injection 방지 (Query DSL은 기본 방어하지만 원시 쿼리 주의)
- 페이징 파라미터 검증 (limit이 너무 크지 않은지)

### 인증과 인가

#### 인증 vs 인가

**인증 (Authentication)**
- "당신은 누구인가?"
- 로그인, JWT 토큰 검증 등

**인가 (Authorization)**
- "당신은 이 리소스에 접근할 권한이 있는가?"
- 역할 기반, 리소스 소유권 확인 등

#### 수평적 권한 상승 방지

**문제 상황: 리소스 소유권 미확인**

```kotlin
// 위험: userId 검증 없음
@GetMapping("/orders/{orderId}")
fun getOrder(
    @PathVariable orderId: Long,
    @AuthenticationPrincipal user: User
): Order {
    return orderRepository.findById(orderId)
        .orElseThrow { NotFoundException() }
    // → 다른 사용자의 주문도 조회 가능!
}
```

**해결: 리소스 소유권 확인**

```kotlin
@GetMapping("/orders/{orderId}")
fun getOrder(
    @PathVariable orderId: Long,
    @AuthenticationPrincipal user: User
): Order {
    val order = orderRepository.findById(orderId)
        .orElseThrow { NotFoundException() }

    // 소유권 확인
    if (order.userId != user.id) {
        throw ForbiddenException("Not your order")
    }

    return order
}
```

**더 나은 방법: 쿼리 조건에 포함**

```kotlin
@GetMapping("/orders/{orderId}")
fun getOrder(
    @PathVariable orderId: Long,
    @AuthenticationPrincipal user: User
): Order {
    // userId 조건을 쿼리에 포함
    return orderRepository.findByIdAndUserId(orderId, user.id)
        .orElseThrow { NotFoundException() }
}
```

#### 역할 기반 인가

**Spring Security 활용**

```kotlin
@PreAuthorize("hasRole('ADMIN')")
@DeleteMapping("/users/{userId}")
fun deleteUser(@PathVariable userId: Long) {
    userService.delete(userId)
}

// 복잡한 조건
@PreAuthorize("hasRole('ADMIN') or @userSecurity.isOwner(#userId, authentication)")
@PutMapping("/users/{userId}")
fun updateUser(
    @PathVariable userId: Long,
    @RequestBody request: UpdateUserRequest
) {
    userService.update(userId, request)
}
```

커스텀 Security 평가자:

```kotlin
@Component("userSecurity")
class UserSecurityEvaluator {
    fun isOwner(userId: Long, authentication: Authentication): Boolean {
        val currentUser = authentication.principal as User
        return currentUser.id == userId
    }
}
```

### 어드민 시스템 보안

#### 어드민 기능 분리

**API로 데이터 자주 변경하는 경우**

문제:
- 운영 중 데이터 수정 필요 시 개발자가 직접 DB 접근
- 감사 로그 없음, 실수 위험

해결:
- 어드민 시스템 구축
- 별도 인증/인가 체계
- 모든 변경 기록

```kotlin
@RestController
@RequestMapping("/admin")
@PreAuthorize("hasRole('ADMIN')")
class AdminController(
    private val adminService: AdminService,
    private val auditLogger: AuditLogger
) {
    @PostMapping("/users/{userId}/points")
    fun adjustPoints(
        @PathVariable userId: Long,
        @RequestBody request: AdjustPointsRequest,
        @AuthenticationPrincipal admin: Admin
    ): User {
        // 감사 로그
        auditLogger.log(
            admin = admin,
            action = "ADJUST_POINTS",
            target = "USER:$userId",
            details = request
        )

        return adminService.adjustPoints(userId, request)
    }
}
```

#### 어드민 감사 로그

```kotlin
@Entity
class AuditLog(
    @Id @GeneratedValue
    val id: Long = 0,

    val adminId: Long,
    val adminName: String,
    val action: String,
    val target: String,

    @Column(columnDefinition = "TEXT")
    val details: String,

    val ipAddress: String,
    val createdAt: LocalDateTime = LocalDateTime.now()
)
```

모든 어드민 작업은 로그 필수:
- 누가 (adminId, adminName)
- 언제 (createdAt)
- 무엇을 (action, target)
- 어떻게 (details)
- 어디서 (ipAddress)

### 운영 환경 보안

#### 프로필 관리

**문제: 로컬에서 운영 프로필로 실행**

```kotlin
// application-prod.yml
spring:
  kafka:
    bootstrap-servers: prod-kafka:9092
  datasource:
    url: jdbc:mysql://prod-db:3306/myapp
```

로컬에서 `--spring.profiles.active=prod`로 실행하면:
- 운영 DB에 연결
- 운영 MQ 메시지 소비
- 실수로 운영 데이터 변경 가능

**해결 1: 프로필 검증**

```kotlin
@Configuration
class ProfileValidator : ApplicationListener<ApplicationReadyEvent> {
    @Value("\${spring.profiles.active:default}")
    private lateinit var activeProfile: String

    override fun onApplicationEvent(event: ApplicationReadyEvent) {
        val hostname = InetAddress.getLocalHost().hostName

        // 로컬 환경에서 운영 프로필 사용 방지
        if (hostname.contains("local") && activeProfile == "prod") {
            throw IllegalStateException(
                "Cannot use prod profile on local environment"
            )
        }
    }
}
```

**해결 2: 환경 변수 검증**

```kotlin
@Configuration
class EnvironmentValidator {
    init {
        val env = System.getenv("DEPLOYMENT_ENV")
        val profile = System.getProperty("spring.profiles.active")

        if (profile == "prod" && env != "PRODUCTION") {
            throw IllegalStateException(
                "prod profile requires DEPLOYMENT_ENV=PRODUCTION"
            )
        }
    }
}
```

## 실무 적용

### 보안 체크리스트

**API 개발 시**
- [ ] 모든 `@RequestBody`, `@RequestParam`에 검증 있는가?
- [ ] 조건부 파라미터 검증했는가?
- [ ] 인증 후 리소스 소유권 확인하는가?
- [ ] 민감한 작업에 추가 인가 검증이 있는가?

**어드민 개발 시**
- [ ] 어드민 전용 인증/인가 체계가 있는가?
- [ ] 모든 작업에 감사 로그를 남기는가?
- [ ] IP 화이트리스트 등 추가 보안 계층이 있는가?

**배포 전**
- [ ] 프로필별 환경 검증 로직이 있는가?
- [ ] 운영 프로필이 로컬에서 실행되지 않는가?
- [ ] 테스트 데이터가 운영 환경에 없는가?

### 금융권에서의 고려사항

- 입력값 검증 실패는 모두 로그 기록
- 인가 실패는 보안팀에 알림 (무차별 대입 공격 감지)
- 어드민 작업은 이중 인증 (2FA) 적용
- 민감한 데이터 조회 시 마스킹 처리
- 감사 로그는 변경 불가능한 저장소에 보관

---

**출처**
- 요즘 우아한 개발 (우아한형제들 기술블로그)
