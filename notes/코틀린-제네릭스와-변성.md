---
tags: [kotlin, generics, variance, reified]
---

# 코틀린 제네릭스와 변성

## 한 줄 요약

코틀린의 제네릭스는 타입 소거, 변성(공변/반공변), 그리고 실체화된 타입 파라미터를 통해 타입 안전성과 유연성을 동시에 제공한다.

## 핵심 정리

- 제네릭 타입 파라미터는 컴파일 시점에 타입 추론 가능
- 타입 파라미터 제약(`:`)으로 상한 지정 가능
- JVM에서는 타입 소거로 실행 시점에 타입 정보 제거
- `reified` 타입 파라미터로 실행 시점에도 타입 정보 사용 가능
- `out` (공변성): 타입 파라미터를 반환 위치에만 사용
- `in` (반공변성): 타입 파라미터를 인자 위치에만 사용
- 스타 프로젝션(`*`)으로 타입 인자 정보가 없음을 표현

## 상세 내용

### 제네릭 타입 파라미터

타입 파라미터는 컴파일러가 추론할 수 있다.

```kotlin
val readers: MutableList<String> = mutableListOf()
val readers = mutableListOf<String>()  // 타입 추론
```

코틀린은 제네릭을 처음부터 도입했기 때문에 타입 인자를 항상 정의해야 한다 (자바는 하위 호환을 위해 raw 타입 허용).

### 제네릭 함수와 프로퍼티

제네릭 함수를 호출할 때는 구체적 타입으로 인자를 넘겨야 한다 (추론 가능하면 생략).

```kotlin
val letters = ('a'..'z').toList()
println(letters.slice<Char>(0..2))  // 타입 명시
println(letters.slice(10..13))      // 타입 추론
```

제네릭 확장 프로퍼티:

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size - 2]

fun main(args: Array<String>) {
    println(listOf(1, 2, 3, 4).penultimate)  // 3
}
```

**주의:** 일반 프로퍼티는 타입 파라미터를 가질 수 없다.

### 제네릭 클래스 선언

하위 클래스에서 상위 제네릭 클래스를 사용할 때 구체적 타입으로 치환하거나 타입 인자로 넘길 수 있다.

```kotlin
interface List<T> {
    operator fun get(index: Int): T
}

// 구체적 타입으로 치환
class StringList: List<String> {
    override fun get(index: Int): String = ...
}

// 타입 인자로 전달
class ArrayList<R> : List<R> {
    override fun get(index: Int): R = ...
}

// 클래스 자신을 타입 인자로 참조
interface Comparable<T> {
    fun compareTo(other: T): Int
}

class String : Comparable<String> {
    override fun compareTo(other: String): Int = ...
}
```

### 타입 파라미터 제약

타입 파라미터에 상한(upper bound)을 지정하여 사용 가능한 타입을 제한할 수 있다.

```kotlin
fun <T : Number> oneHalf(value: T): Double {
    return value.toDouble() / 2.0
}

fun main(args: Array<String>) {
    println(oneHalf(3))  // 1.5
}

fun <T: Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}

fun main(args: Array<String>) {
    println(max("kotlin", "java"))  // kotlin
}
```

드물지만 제약을 둘 이상 지정해야 할 때는 `where` 사용:

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}
```

### 타입 파라미터를 널이 될 수 있는 타입으로 한정

- `:T` 또는 `:Any?` → 널이 될 수 있음
- `:Any` → 널이 될 수 없음
- `String?`은 `Any?`의 하위 타입

## 실행 시 제네릭스

JVM에서 제네릭스는 타입 소거(type erasure)를 사용한다.
- 실행 시점에 인스턴스에 타입 인자 정보가 들어있지 않다

### 타입 검사와 캐스트

컴파일 시점에는 `List<String>`과 `List<Int>`를 구별하지만, 실행 시점에는 둘 다 같은 `List` 타입이다.

```kotlin
// 에러: 실행 시점에 타입 인자 검사 불가
if (value is List<String>) {}  // ERROR: Cannot check for instance of erased type
```

타입 소거의 장점: 타입 정보를 저장하지 않아 메모리 사용량이 줄어든다.

스타 프로젝션(`*`)으로 타입 인자 정보 없이 검사:

```kotlin
if (value is List<*>) {  // OK
    // List인지만 확인
}
```

`as`나 `as?` 캐스팅에서 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅하면 컴파일러 경고가 발생한다:

```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int>  // 경고 발생
        ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

fun main(args: Array<String>) {
    printSum(listOf(1, 2, 3))           // 정상 작동
    printSum(setOf(1, 2, 3))            // IllegalArgumentException
    printSum(listOf("a", "b", "c"))     // ClassCastException
}
```

컴파일러는 타입 정보가 명시되면 is 검사를 허용한다:

```kotlin
fun printSum(c: Collection<Int>) {
    if (c is List<Int>) {  // OK: 파라미터로 Int가 명시됨
        println(c.sum())
    }
}

fun main(args: Array<String>) {
    printSum(listOf(1, 2, 3))
}
```

### 실체화한 타입 파라미터를 사용한 함수 선언

제네릭 타입 인자 정보는 실행 시점에 지워지므로, 제네릭 클래스의 인스턴스가 있어도 그 타입 인자를 알아낼 수 없다.

```kotlin
// 에러: 타입 소거로 실행 시점에 T를 알 수 없음
fun<T> isA(value: Any) = value is T  // Error
```

`inline` 함수와 `reified` 키워드를 함께 사용하면 실행 시점에 타입 정보 사용 가능:

```kotlin
inline fun <reified T> isA(value: Any) = value is T

fun main(args: Array<String>) {
    println(isA<String>("abc"))  // true
    println(isA<String>(123))    // false
}
```

### 실체화한 타입 파라미터로 클래스 참조

`::class.java`로 클래스의 Class 객체를 가져올 수 있다.

```kotlin
inline fun <reified T> loadService(): T {
    return ServiceLoader.load(T::class.java)
}
```

## 변성

변성(variance)은 기저 타입이 같고 타입 인자가 다른 여러 타입 간의 관계를 다룬다.

### 인자를 함수에 넘기기

`List<String>` 파라미터에 `List<Any>`를 넘기면 안전할까?

- `String`은 `Any`를 확장했으므로 안전해 보이지만
- `List`에 들어간 경우는 안전하지 않을 수 있다

```kotlin
fun printContents(list: List<Any>) {
    println(list.joinToString())
}

fun addAnswer(list: MutableList<Any>) {
    list.add(43)
}

fun main(args: Array<String>) {
    printContents(listOf("abc", "bac"))  // 안전하게 작동

    val strings = mutableListOf("abc", "bac")
    addAnswer(strings)  // 컴파일 에러!
    println(strings.maxBy { it.length })
}
```

- `List<T>`는 읽기 전용이므로 공변성
- `MutableList<T>`는 읽기/쓰기 가능하므로 무공변성

리스트의 원소를 추가하거나 변경한다면 타입 불일치가 생길 수 있어서 컴파일러가 막는다.

### 클래스 vs 타입 vs 하위타입

**클래스와 타입은 다르다:**
- `String` vs `String?`
- `List`는 클래스, `List<String>`, `List<String?>`는 타입
- 각 제네릭 클래스는 무수히 많은 타입을 만들 수 있다

**하위 타입:**
- A 대신 B를 넣어도 아무 문제 없다면 B는 A의 하위 타입
- 자기 자신도 하위 타입
- B가 A의 하위 타입이면 A는 B의 상위 타입
- 하위 클래스는 하위 타입이다
- 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이지만 같은 클래스

### 공변성: 하위 타입 관계를 유지

A가 B의 하위 타입일 때 `Producer<A>`가 `Producer<B>`의 하위 타입이면 `Producer`는 **공변적(covariant)**이다.

예: `Cat` → `Animal`이면 `Producer<Cat>` → `Producer<Animal>`

코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 `out`을 붙인다:

```kotlin
interface Producer<out T> {
    fun produce(): T
}
```

- **사용 제한**: 컴파일 단계에서 반환 위치에만 허용
- **공변성**: 하위 타입 관계가 유지됨

```kotlin
interface List<out T> : Collection<T> {
    fun subList(fromIndex: Int, toIndex: Int): List<T>  // T는 out 위치
}
```

`MutableList`는 in 위치와 out 위치 둘 다 타입 파라미터를 사용하므로 무공변성이다.

**주의사항:**
- 생성자 파라미터는 in/out 위치가 아니다
- 읽기 전용 프로퍼티는 out 위치, 변경 가능 프로퍼티는 out과 in 위치 모두
- 비공개 메소드는 변성 규칙이 적용되지 않는다 (외부에서 잘못 쓰는 것을 방지하기 위해)

### 반공변성: 뒤집힌 하위 타입 관계

타입 파라미터에 `in`을 붙여 in 위치에서만 사용하게 한다.

타입 B가 타입 A의 하위 타입인 경우 `Consumer<A>`가 `Consumer<B>`의 하위 타입인 관계.

```kotlin
interface Consumer<in T> {
    fun consume(item: T)
}
```

인자의 타입에 대해서는 반공변적이면서 반환 타입에는 공변적일 수 있다:

```kotlin
interface Function1<in P, out R> {
    operator fun invoke(p: P): R
}

fun enumerateCats(f: (Cat) -> Number) {}

fun Animal.getIndex(): Int = ...

enumerateCats(Animal::getIndex)  // OK
```

### 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

**선언 지점 변성:**
- 클래스 선언하면서 변성을 지정
- 그 클래스를 사용하는 모든 장소에 영향

**사용 지점 변성:**
- 자바: `? extends`, `? super`
- 코틀린에서도 지원
- 특정 타입 파라미터가 나타나는 지점에서 변성 결정

예시:

```kotlin
fun <T> copyData(source: MutableList<T>,
                 destination: MutableList<T>) {
    for (item in source) {
        destination.add(item)
    }
}
```

두 컬렉션의 타입이 일치할 필요는 없다. 문자열 컬렉션에서 객체 컬렉션으로 복사해도 문제없다.

```kotlin
// 방법 1: 타입 파라미터 2개 사용
fun <T: R, R> copyData(source: MutableList<T>,
                       destination: MutableList<R>) {
    for (item in source) {
        destination.add(item)
    }
}

fun main(args: Array<String>) {
    val ints = mutableListOf(1, 2, 3)
    val anyItems = mutableListOf<Any>()
    copyData(ints, anyItems)
    println(anyItems)
}
```

```kotlin
// 방법 2: 사용 지점 변성 사용
fun <T> copyData(source: MutableList<out T>,
                 destination: MutableList<T>) {
    for (item in source) {
        // source.add(item)  // 에러: out 위치라 add 불가
        destination.add(item)
    }
}

fun main(args: Array<String>) {
    val ints = mutableListOf(1, 2, 3)
    val anyItems = mutableListOf<Any>()
    copyData(ints, anyItems)
    println(anyItems)
}
```

- 타입 파라미터가 파라미터 타입, 로컬 변수 타입, 함수 반환 타입 등에 쓰일 때 in/out 변경자 사용 가능
- 이를 **타입 프로젝션(type projection)**이라고 함
- `MutableList`에 제약을 가함

### 스타 프로젝션: 타입인자 대신 *

제네릭 타입 인자 정보가 없음을 **스타 프로젝션**으로 표현한다.

`MutableList<*>`는 `MutableList<Any?>`와 다르다:
- `<Any?>`는 모든 타입의 원소를 담을 수 있다는 의미
- `<*>`는 어떤 정해진 구체적 타입의 원소만 담지만 그 타입이 무엇인지 모른다는 의미
- `*`는 `Any?`의 하위 타입
- `MutableList<*>`는 `MutableList<out Any?>`처럼 동작

따라서:
- 원소 타입을 모르더라도 안전하게 `Any?` 타입의 원소를 꺼낼 수 있음
- 타입을 모르는 리스트에 원소를 마음대로 넣을 수는 없음

타입 인자 정보가 중요하지 않을 때 스타 프로젝션 사용:

```kotlin
fun printFirst(list: List<*>) {
    if (list.isNotEmpty()) {  // 제네릭 파라미터 사용하지 않음
        println(list.first())  // Any? 반환, 하지만 충분
    }
}

fun main(args: Array<String>) {
    printFirst(listOf("Svetlana", "Dmitry"))
}
```

## 관련 노트

- [[코틀린-타입-시스템]] - 타입 안전성과 타입 계층
- [[코틀린-고차함수]] - reified 타입 파라미터와 인라인 함수

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 9장
