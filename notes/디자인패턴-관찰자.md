---
tags: [design-pattern, kotlin, behavioral]
---

# 관찰자 패턴

## 한 줄 요약

발행-구독 방식으로 객체의 상태 변화를 여러 구독자에게 자동으로 알리는 패턴

## 핵심 정리

- 함수형 프로그래밍을 다루는 가교 역할
- 함수를 키로 사용
- 유연성이 강점
- 발행자는 호출할 함수의 시그니처 외에는 구독자에 관해 아무것도 알 필요가 없음
- 중개인 패턴과 다르게 구독자가 런타임에 구독 및 구독 취소가 가능

## 상세 내용

### 구현 예제

```kotlin
fun main() {
    val catTheConductor = Cat()

    val bat = Bat()
    val dog = Dog()
    val turkey = Turkey()

    catTheConductor.joinChoir { bat.screech(HighMessage(2)) }
    catTheConductor.joinChoir(dog::howl)
    catTheConductor.joinChoir(dog::bark)
    catTheConductor.joinChoir(turkey::gobble)

    catTheConductor.conduct()
    catTheConductor.conduct()
}

class Bat {
    fun screech(message: Message) {
        when (message) {
            is HighMessage -> {
                for (i in 1..message.repeat) {
                    println("${message.pitch} 이---")
                }
            }
            else -> println("낼 수 없는 소리")
        }
    }
}

class Turkey {
    fun gobble() {
        println("Gob-gob")
    }
}

class Dog {
    fun bark() {
        println("Woof")
    }

    fun howl() {
        println("Auuuu")
    }
}

class Cat {
    private val participants = mutableMapOf<() -> Unit, () -> Unit>()

    fun joinChoir(whatToCall: () -> Unit) {
        participants[whatToCall] = whatToCall
    }

    fun leaveChoir(whatNotToCall: () -> Unit) {
        participants.remove(whatNotToCall)
    }

    fun conduct() {
        for (p in participants.values) {
            p()
        }
    }
}

typealias Times = Int

enum class SoundPitch { HIGH, LOW }

interface Message {
    val repeat: Times
    val pitch: SoundPitch
}

data class LowMessage(override val repeat: Times) : Message {
    override val pitch = SoundPitch.LOW
}

data class HighMessage(override val repeat: Times) : Message {
    override val pitch = SoundPitch.HIGH
}
```

### 특징

- 함수를 Map의 키로 사용하여 구독자 관리
- 람다나 메서드 참조로 구독 가능
- 런타임에 동적으로 구독/구독 취소
- 발행자와 구독자 간 느슨한 결합

---

**출처**
- 코틀린 디자인 패턴
