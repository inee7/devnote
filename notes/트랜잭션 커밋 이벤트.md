---
tags: [transactional, transaction, event, spring-boot, event-listener]
---
# 트랜잭션 커밋 이벤트

  

> **요약**  
> 스프링에서 트랜잭션이 **정상 커밋된 직후** 또는 **롤백 직후**에 특정 로직을 자동으로 실행하고 싶다면 다음 두 가지 방법이 대표적입니다:
> 1. `@TransactionalEventListener(phase = AFTER_COMMIT | AFTER_ROLLBACK)`  
> 2. `TransactionSynchronizationManager.registerSynchronization(...)`
> 상황에 맞게 선택하면 깔끔하고 안정적인 처리가 가능합니다.


---
## ✅ 왜 "커밋 직후"가 필요할까?

- **알림/이메일**: 트랜잭션이 성공한 후 사용자에게 카카오톡, 이메일 등을 보내야 할 때  
- **도메인 이벤트 발행**: 주문 완료 등 이벤트를 퍼블리시해야 하는 경우  
- **캐시 무효화**: DB가 성공적으로 반영된 후 캐시를 갱신해야 일관성이 보장됨

---

  

## ✅ 방법 1: `@TransactionalEventListener` — 가장 권장되는 방법

  

### 예시 코드



```java

// 비즈니스 서비스

@Service

@RequiredArgsConstructor

public class OrderService {

    private final ApplicationEventPublisher publisher;

    private final OrderRepository orderRepository;

  

    @Transactional

    public void placeOrder(Order order) {

        orderRepository.save(order);

        publisher.publishEvent(new OrderCompletedEvent(order.getId()));

    }

}

  

// 커밋 이후 실행할 리스너

@Component

public class OrderCompletedListener {

  

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)

    public void handleAfterCommit(OrderCompletedEvent event) {

        sendNotification(event.orderId());

    }

  

    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)

    public void handleAfterRollback(OrderCompletedEvent event) {

        log.warn("Order {} rolled back!", event.orderId());

    }

}
```

### **장점**

- ✅ 스프링 표준 기능, 유지보수 용이
- ✅ @Async 와 결합 시 논블로킹 처리 가능
- ✅ 단위 테스트 작성 쉬움


### **단점**

- ⚠️ 기본은 동기 처리 → 무거운 로직은 서비스 응답 지연 초래
- ⚠️ 같은 스레드에서 실행됨

  
> 💡 **TIP:**
> 외부 API 호출, 메일 발송 등 무거운 작업은 @Async나 Kafka 등으로 분리하세요.

---

## **✅ 방법 2:** 

## **TransactionSynchronizationManager.registerSynchronization()**

##  **— 세밀한 제어**

~~~java
@Transactional
public void businessLogic() {
    // ...

    TransactionSynchronizationManager.registerSynchronization(
        new TransactionSynchronizationAdapter() {
            @Override
            public void afterCommit() {
                // 커밋 직후 실행
            }

            @Override
            public void afterCompletion(int status) {
                if (status == STATUS_ROLLED_BACK) {
                    // 롤백 직후 처리
                }
            }
        }
    );
}
~~~
  ### **장점**

- ✅ 커밋/롤백 여부를 코드 안에서 직접 분기 가능
    
- ✅ 후처리를 메서드 내부에 명시할 수 있어 국소 제어 가능
    

  

### **단점**

- ⚠️ 코드 가독성 저하, 테스트 어려움
    
- ⚠️ 여러 곳에 남용 시 유지보수 지옥
    

---

## **❌ 자주 쓰면 안 되는 방법들**

|**방법**|**이유**|
|---|---|
|@PostPersist, @PostUpdate|JPA 영속성 이벤트일 뿐, 트랜잭션 커밋과는 별개|
|@AfterReturning (AOP)|트랜잭션 상태를 알 수 없음|
|메시지 큐 / 스케줄러|트랜잭션 커밋 직후가 아님. 대규모 분산 워크플로우에 적합|

## **✅ 상황별 선택 가이드**

|**질문**|**추천 방법**|
|---|---|
|커밋 이후 간단한 작업을 별도 리스너로 실행하고 싶은가?|@TransactionalEventListener|
|후처리 로직이 복잡하거나 비동기로 분리하고 싶은가?|@TransactionalEventListener + @Async|
|트랜잭션 안에서 커밋/롤백 여부를 직접 체크하고 싶은가?|TransactionSynchronization|

## **✅ 결론**

- 스프링에서 트랜잭션 후처리는 표준 이벤트 기반으로 관리하는 것이 가장 깔끔합니다.
    
- 대부분의 경우는 @TransactionalEventListener(phase = AFTER_COMMIT) 만으로 충분합니다.
    
- 커밋 결과를 민감하게 다뤄야 하거나, 특정 위치에서만 실행해야 할 경우에는 TransactionSynchronization 도 고려해보세요.


#Transactional #트랜잭션 #이벤트 #스프링부트
