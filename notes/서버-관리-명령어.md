---
tags: [linux, 서버관리, devops, 명령어, 운영]
---

## 한 줄 요약

Linux 서버 관리를 위한 필수 명령어로 파일 권한, 프로세스, 네트워크를 확인하고 제어한다.

## 핵심 정리

- `ls -l`로 파일 권한, 소유자, 크기 확인
- `chmod`로 파일 실행 권한 설정 (예: `chmod 754`)
- `ps aux` / `ps -eaf`로 프로세스 목록 확인
- `kill -15` (graceful) vs `kill -9` (force)
- `tail -f`로 실시간 로그 확인
- `nohup`으로 터미널 종료 후에도 프로세스 유지
- `lsof -p`로 프로세스의 파일 디스크립터 확인
- `netstat -lputn`으로 열린 포트 확인

## 상세 내용

### 파일 권한 관리

#### ls -l 출력 구조

```bash
$ ls -l
-rwxr-xr-- 1 user group 1024 Jan 01 12:00 run.sh
```

출력 형식:
```
파일권한 _ 소유자 _ 소유그룹 _ 파일크기 _ 마지막수정시간 _ 파일명
```

#### 파일 권한 해석

```
-rwxr-xr--
 │││ │││ │││
 │││ │││ └─┴─→ 다른 사용자 (r--: 읽기만)
 │││ └─┴────→ 그룹 (r-x: 읽기, 실행)
 └─┴────────→ 소유자 (rwx: 읽기, 쓰기, 실행)
```

권한 의미:
- `r` (read): 읽기
- `w` (write): 쓰기
- `x` (execute): 실행
- `-`: 권한 없음

#### chmod로 권한 변경

**숫자 방식**

```bash
$ chmod 754 run.sh
```

권한 계산:
- 7 (소유자): rwx = 4+2+1
- 5 (그룹): r-x = 4+0+1
- 4 (다른 사용자): r-- = 4+0+0

권한 값:
- r (read) = 4
- w (write) = 2
- x (execute) = 1

**문자 방식**

```bash
$ chmod +x run.sh        # 모두에게 실행 권한 추가
$ chmod u+x run.sh       # 소유자에게만 실행 권한
$ chmod go-w run.sh      # 그룹과 others의 쓰기 권한 제거
```

### 프로세스 관리

#### 프로세스 확인

**ps aux: BSD 스타일**

```bash
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  18236  3240 ?        Ss   Jan01   0:01 /sbin/init
user      1234  2.5  5.0 512000 51200 ?        Sl   12:00   1:30 java -jar app.jar
```

주요 컬럼:
- `USER`: 프로세스 소유자
- `PID`: 프로세스 ID
- `%CPU`: CPU 사용률
- `%MEM`: 메모리 사용률
- `COMMAND`: 실행 명령어

**ps -eaf: UNIX 스타일**

```bash
$ ps -eaf
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Jan01 ?        00:00:01 /sbin/init
user      1234     1  2 12:00 ?        00:01:30 java -jar app.jar
```

주요 컬럼:
- `PPID`: 부모 프로세스 ID
- `STIME`: 시작 시간

#### 프로세스 모니터링

**top: 실시간 프로세스 상태**

```bash
$ top
```

특징:
- 실시간 갱신
- CPU, 메모리 사용량 상위 프로세스 표시
- 키보드 조작으로 정렬 변경 가능

**htop: 향상된 top (설치 필요)**

```bash
$ htop
```

장점:
- 컬러풀한 UI
- 마우스 지원
- 프로세스 트리 구조 표시

#### 프로세스 종료

**kill -15 (SIGTERM): Graceful Shutdown**

```bash
$ kill -15 1234
```

특징:
- 프로세스에게 종료 신호 전송
- 프로세스가 정리 작업 후 종료
- 안전한 종료 방식

**kill -9 (SIGKILL): Force Kill**

```bash
$ kill -9 1234
```

특징:
- 강제 종료
- 프로세스가 정리 작업 불가
- 응답 없는 프로세스 종료 시 사용

권장:
1. 먼저 `kill -15` 시도
2. 종료되지 않으면 `kill -9` 사용

### 로그 확인

#### tail: 파일 끝부분 보기

```bash
$ tail access.log          # 마지막 10줄
$ tail -n 100 access.log   # 마지막 100줄
```

#### tail -f: 실시간 로그 확인

```bash
$ tail -f access.log
```

특징:
- 파일에 새로운 내용이 추가되면 실시간으로 출력
- 애플리케이션 로그 모니터링에 필수
- `Ctrl+C`로 종료

**응용: 여러 파일 동시 확인**

```bash
$ tail -f app.log error.log
```

### 백그라운드 실행

#### nohup: 터미널 종료 후에도 실행 유지

```bash
$ nohup java -jar app.jar &
```

특징:
- 터미널 세션이 끊겨도 프로세스 계속 실행
- 출력은 `nohup.out` 파일에 저장
- `&`로 백그라운드 실행

**출력 리다이렉션**

```bash
$ nohup java -jar app.jar > app.log 2>&1 &
```

의미:
- `> app.log`: 표준 출력을 app.log로
- `2>&1`: 표준 에러를 표준 출력과 같은 곳으로
- `&`: 백그라운드 실행

### 파일 디스크립터 관리

#### 파일 디스크립터란?

프로세스가 데이터 입출력을 위해 OS로부터 할당받는 핸들:
- 파일, 소켓, 파이프 등에 접근하는 통로
- 프로세스마다 개수 제한 있음 (기본 1024개)

#### lsof: 열린 파일 확인

```bash
$ lsof -p 1234
```

출력 예시:
```
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java    1234 user  cwd    DIR    8,1     4096  123 /app
java    1234 user  txt    REG    8,1   512000  456 /usr/bin/java
java    1234 user    0u   CHR  136,0      0t0    3 /dev/pts/0
java    1234 user    1u   CHR  136,0      0t0    3 /dev/pts/0
java    1234 user    2u   CHR  136,0      0t0    3 /dev/pts/0
java    1234 user   10u  IPv4  12345      0t0  TCP *:8080 (LISTEN)
```

주요 정보:
- `FD`: 파일 디스크립터 번호
- `TYPE`: 타입 (REG=파일, IPv4=소켓 등)
- `NAME`: 파일 경로 또는 소켓 정보

용도:
- 프로세스가 어떤 파일/소켓을 열고 있는지 확인
- 파일 디스크립터 부족 오류 디버깅

### 네트워크 관리

#### ifconfig: IP 정보 확인

```bash
$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
      inet 192.168.0.100  netmask 255.255.255.0  broadcast 192.168.0.255
      ether 00:0c:29:12:34:56  txqueuelen 1000  (Ethernet)
```

주요 정보:
- `inet`: IP 주소
- `netmask`: 서브넷 마스크
- `ether`: MAC 주소

#### nc: 포트 연결 테스트

```bash
$ nc -z -v daum.net 443
Connection to daum.net 443 port [tcp/https] succeeded!
```

옵션:
- `-z`: 스캔만 (데이터 전송 안 함)
- `-v`: verbose (상세 출력)

용도:
- 특정 호스트:포트가 열려 있는지 확인
- 방화벽 설정 확인

#### netstat: 열린 포트 확인

```bash
$ netstat -lputn
```

옵션:
- `-l`: LISTEN 상태 포트만
- `-p`: 프로세스 정보 포함
- `-u`: UDP
- `-t`: TCP
- `-n`: 숫자로 표시 (도메인 변환 안 함)

출력 예시:
```
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      1234/java
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      567/sshd
```

용도:
- 서버가 어떤 포트를 열고 있는지 확인
- 포트 충돌 확인

## 실무 적용

### 서버 배포 시 체크리스트

1. **애플리케이션 실행**
   ```bash
   $ chmod +x run.sh
   $ nohup ./run.sh > app.log 2>&1 &
   ```

2. **프로세스 확인**
   ```bash
   $ ps aux | grep java
   ```

3. **포트 확인**
   ```bash
   $ netstat -lputn | grep 8080
   ```

4. **로그 모니터링**
   ```bash
   $ tail -f app.log
   ```

### 장애 대응 시나리오

**1. 프로세스가 응답 없음**

```bash
# 프로세스 확인
$ ps aux | grep app

# Graceful 종료 시도
$ kill -15 1234

# 10초 대기 후 강제 종료
$ kill -9 1234
```

**2. 파일 디스크립터 부족**

```bash
# 현재 사용 중인 디스크립터 확인
$ lsof -p 1234 | wc -l

# 제한 확인
$ ulimit -n

# 제한 증가 (일시적)
$ ulimit -n 4096
```

**3. 포트가 이미 사용 중**

```bash
# 해당 포트를 사용 중인 프로세스 찾기
$ netstat -lputn | grep 8080
$ lsof -i :8080

# 프로세스 종료
$ kill -15 <PID>
```

### 금융권에서의 고려사항

- 프로세스 종료 시 반드시 `kill -15` 먼저 시도 (데이터 정합성)
- 배포 스크립트에 health check 포함
- 로그는 별도 디렉토리에 저장 (디스크 용량 관리)
- 파일 디스크립터 제한을 충분히 설정 (보통 65535)
- 네트워크 명령어로 외부 연동 상태 주기적 확인

---

**출처**
- 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식 (최범균)
