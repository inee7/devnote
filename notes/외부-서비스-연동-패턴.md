---
tags: [external-integration, timeout, retry, transaction, idempotency, backend]
---

## 한 줄 요약

외부 서비스 연동 시 타임아웃 설정, 멱등성 보장, 트랜잭션 경계 관리를 통해 안정성과 데이터 정합성을 확보한다.

## 핵심 정리

- 타임아웃 미설정 시 무한 대기로 전체 시스템 장애 발생 가능
- 재시도는 단순 조회, 커넥션 타임아웃, 멱등성이 보장된 변경 작업에만 적용
- 트랜잭션 내에서 외부 호출 시 타임아웃 발생하면 외부는 성공했으나 DB는 롤백될 수 있음
- HTTP 커넥션 풀도 DB 커넥션 풀만큼 중요하며, 연동 서비스 성능에 따라 설정
- 핵심 연동 서비스(결제 등)는 반드시 이중화 구성

## 상세 내용

### 타임아웃 설정

#### 타임아웃 미설정의 위험성

외부 서비스 연동 시 타임아웃을 설정하지 않으면:
- 외부 서비스가 응답하지 않을 때 무한 대기
- 스레드/커넥션 고갈로 전체 시스템 장애 확산

**필수 타임아웃 설정 항목**
1. 커넥션 타임아웃 (Connection Timeout)
2. 읽기 타임아웃 (Read Timeout)
3. (선택) 전체 호출 타임아웃 (Call Timeout)

#### 초기 권장 타임아웃 값

**커넥션 타임아웃**: 3~5초
- TCP 연결을 맺는 시간
- 네트워크 상태가 정상이면 빠르게 완료되므로 짧게 설정

**읽기 타임아웃**: 5~30초
- 요청 후 응답을 받는 시간
- 외부 서비스의 평균 응답 시간을 고려하여 설정
- 이 값에서 시작해 운영 환경에서 조정

**조정 원칙**
- 너무 짧으면: 정상 요청도 실패 처리
- 너무 길면: 장애 상황에서 시스템 전체 지연
- 모니터링을 통해 점진적으로 최적값 도출

#### OkHttp의 Call Timeout

OkHttp는 추가로 Call Timeout 제공:
- 요청 시작부터 응답 완료까지 전체 시간 제한
- 커넥션 타임아웃 + 읽기 타임아웃을 합친 시간 이상으로 설정

### 재시도 전략

#### 재시도 가능한 경우

**1. 단순 조회**
```kotlin
// OK: 멱등성 보장
fun getUserInfo(userId: Long): UserInfo {
    return retryTemplate.execute {
        externalApi.getUser(userId)
    }
}
```

**2. 커넥션 타임아웃**
- 연결 자체가 실패했으므로 외부 서비스가 요청을 받지 못함
- 재시도해도 중복 실행 위험 없음

**3. 멱등성이 보장된 변경 작업**
- API가 멱등키(idempotency key)를 지원하는 경우
- 같은 요청을 여러 번 보내도 결과가 동일

#### 재시도하면 안 되는 경우

**읽기 타임아웃으로 인한 변경 작업**

```kotlin
// 위험: 포인트가 두 번 차감될 수 있음
fun deductPoints(userId: Long, amount: Int) {
    try {
        pointService.deduct(userId, amount)  // 5초 후 Read Timeout
    } catch (e: ReadTimeoutException) {
        // 재시도하면 안 됨!
        // 외부 서비스에서는 이미 차감되었을 수 있음
    }
}
```

이유:
- 읽기 타임아웃 = 요청은 도착했으나 응답이 늦음
- 외부 서비스에서는 이미 처리 완료했을 가능성 높음
- 재시도 시 중복 처리 발생

#### 재시도 폭풍(Retry Storm) 주의

**문제 상황**
```
API 서버 10대가 각각 외부 서비스에 재시도
→ 외부 서비스에 순간적으로 10배 요청
→ 외부 서비스 과부하로 장애 확산
```

**대책**
1. 외부 서비스의 처리 용량 사전 확인
2. 지수 백오프(Exponential Backoff) 적용
3. Circuit Breaker 패턴 도입

### 트랜잭션과 외부 호출

#### 트랜잭션 내에서 외부 호출의 문제

**시나리오: 트랜잭션 내에서 외부 API 호출 후 타임아웃**

```kotlin
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)  // DB 저장

    paymentService.charge(order.amount)  // 외부 결제 API
    // → Read Timeout 발생
    // → 트랜잭션 롤백
}
```

결과:
- DB는 롤백되어 주문 취소
- 외부 결제 서비스에서는 결제 성공했을 수 있음
- **데이터 불일치 발생**

#### 해결 방법 1: 외부 API 호출 후 확인

```kotlin
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)

    try {
        val paymentResult = paymentService.charge(order.amount)
    } catch (e: ReadTimeoutException) {
        // 외부 서비스에 결제 성공 여부 확인 API 호출
        val isSuccess = paymentService.checkPayment(order.paymentId)

        if (isSuccess) {
            // 결제 성공 → 트랜잭션 지속
            return
        } else {
            // 결제 실패 → 롤백
            throw e
        }
    }
}
```

주의: 확인 API도 타임아웃될 수 있으므로 완벽한 해결책은 아님

#### 해결 방법 2: 취소 API 호출 후 롤백

```kotlin
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)

    try {
        paymentService.charge(order.amount)
    } catch (e: ReadTimeoutException) {
        // 외부 서비스에 취소 요청
        paymentService.cancel(order.paymentId)
        // → 취소 API도 타임아웃될 수 있음

        throw e  // 롤백
    }
}
```

한계: 취소 API도 타임아웃될 수 있음

#### 해결 방법 3: 정기 데이터 정합성 확인 및 보정

**근본적인 대책**
- 배치로 정기적으로 DB와 외부 서비스 데이터 비교
- 불일치 발견 시 자동/수동 보정
- 금융권에서 많이 사용하는 패턴

```kotlin
@Scheduled(cron = "0 0 2 * * *")  // 매일 새벽 2시
fun reconcilePayments() {
    val yesterday = LocalDate.now().minusDays(1)

    val ourPayments = orderRepository.findPaymentsByDate(yesterday)
    val externalPayments = paymentService.getPaymentsByDate(yesterday)

    val mismatches = findMismatches(ourPayments, externalPayments)

    mismatches.forEach { mismatch ->
        alertService.notify(mismatch)  // 담당자에게 알림
        // 또는 자동 보정 로직 수행
    }
}
```

#### 트랜잭션 외부로 외부 호출 이동

**커넥션 효율성 관점**

```kotlin
// 문제: 트랜잭션이 외부 API 응답까지 기다림 (비효율적)
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)
    paymentService.charge(order.amount)  // 5초 소요
    // → DB 커넥션을 5초 동안 점유
}
```

개선:

```kotlin
fun processOrder(order: Order) {
    // 1. 외부 호출 먼저
    val paymentResult = paymentService.charge(order.amount)

    // 2. DB 처리는 나중에
    saveOrder(order, paymentResult)
}

@Transactional
fun saveOrder(order: Order, paymentResult: PaymentResult) {
    orderRepository.save(order)
    // DB 트랜잭션 시간 최소화
}
```

장점:
- DB 커넥션 점유 시간 최소화
- 커넥션 풀 효율성 증가

단점:
- 트랜잭션 경계가 분리되어 일관성 보장 어려움
- 보상 트랜잭션이나 데이터 보정 로직 필요

### HTTP 커넥션 풀 관리

#### 중요성

HTTP 커넥션 풀도 DB 커넥션 풀만큼 중요:
- 외부 서비스 호출마다 TCP 연결을 새로 맺으면 오버헤드 큼
- 커넥션 재사용으로 성능 향상

#### 설정 원칙

**풀 크기 결정**
- 연동 서비스의 성능에 따라 결정
- 예: 외부 서비스가 초당 100개 요청 처리 가능하다면, 풀 크기는 그에 맞게 설정

**커넥션 대기 시간**
- 권장: 1~5초
- 풀이 고갈되었을 때 너무 오래 기다리지 않도록

**커넥션 유지 시간 (Keep-Alive)**
- 서버의 Keep-Alive 시간보다 짧게 설정
- 연결이 서버 측에서 끊기기 전에 클라이언트가 먼저 정리

```kotlin
val client = OkHttpClient.Builder()
    .connectionPool(ConnectionPool(
        maxIdleConnections = 50,
        keepAliveDuration = 5,
        timeUnit = TimeUnit.MINUTES
    ))
    .connectTimeout(3, TimeUnit.SECONDS)
    .readTimeout(10, TimeUnit.SECONDS)
    .build()
```

### 핵심 연동 서비스 이중화

**결제 같은 핵심 서비스는 반드시 이중화**

```kotlin
class PaymentServiceWithFailover(
    private val primaryService: PaymentService,
    private val secondaryService: PaymentService
) {
    fun charge(amount: Long): PaymentResult {
        return try {
            primaryService.charge(amount)
        } catch (e: Exception) {
            logger.warn("Primary payment service failed, using secondary", e)
            secondaryService.charge(amount)
        }
    }
}
```

구성 방법:
- 서로 다른 결제 PG사 사용
- 같은 PG사의 다른 엔드포인트 사용
- 지역별로 분산된 엔드포인트 활용

## 실무 적용

### 외부 연동 체크리스트

1. **타임아웃 설정 필수**
   - 커넥션 타임아웃: 3~5초
   - 읽기 타임아웃: 5~30초
   - 운영 모니터링 후 조정

2. **재시도 전략**
   - 조회: 재시도 O
   - 변경: 멱등성 보장 시에만 재시도
   - 읽기 타임아웃: 재시도 X

3. **트랜잭션 경계**
   - 외부 호출이 트랜잭션 내부에 있는가?
   - 데이터 정합성 보정 로직이 있는가?

4. **커넥션 풀 관리**
   - HTTP 커넥션 풀 크기 적절한가?
   - Keep-Alive 시간 설정했는가?

5. **핵심 서비스 이중화**
   - 결제, 인증 등 핵심 서비스는 이중화 구성

### 금융권에서의 고려사항

- 정합성이 최우선: 의심스러우면 트랜잭션 롤백 후 수동 확인
- 모든 외부 연동은 로그 남기기 (요청/응답 전체)
- 야간 배치로 데이터 정합성 검증 필수
- PG사 이중화는 계약 단계부터 고려
- 타임아웃은 보수적으로 설정 후 점진적으로 조정

---

**출처**
- 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식 (최범균)
