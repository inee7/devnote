---
tags: [performance-optimization, scalability, index, connection-pool, backend]
---

## 한 줄 요약

트래픽 증가 시 병목 지점을 정확히 파악하고, 수직/수평 확장, 인덱스 최적화, 커넥션 풀 조정을 통해 성능을 개선한다.

## 핵심 정리

- 트래픽 급증 시 수직 확장으로 임시 대응 가능하지만 장기적으로는 병목 해결이 우선
- 외부 API/DB가 병목인 상황에서 수평 확장은 오히려 역효과
- DB CPU 사용률이 높을 때 커넥션 수를 늘리면 안 되고, 오히려 줄여야 함
- 인덱스는 선택도가 높을수록 효율적이나, 쿼리 사용률이 높으면 선택도가 낮아도 효과적
- 복합 인덱스는 실제 조회 패턴과 비교해 불필요한 컬럼이 있으면 CUD 성능에 악영향

## 상세 내용

### 확장 전략

#### 수직 확장 vs 수평 확장

**수직 확장의 한계**
- 트래픽이 몰릴 때 급한 불을 끄는 용도로는 유효
- 근본적인 병목(외부 API/DB)을 해결하지 못하면 장기적으로 문제 지속

**수평 확장 시 주의사항**
- 외부 API/DB가 병목인 상황에서 서버를 늘리면 "불에 기름 붓는 격"
- 예: 외부 API 응답이 느린데 API 서버만 늘리면 외부 API에 요청이 더 몰려 전체 시스템 악화

**적절한 확장 전략**
- 병목 지점 정확히 파악 후 해당 부분 개선
- 조회용 DB를 별도로 두는 Read Replica 구성도 효과적
- 수직 확장도 성능 개선에 도움이 되므로 상황에 따라 병행

### 커넥션 풀 관리

#### 기본 원칙

```
커넥션 5개, 실행시간 0.1초일 때
→ 1초에 50개 요청 처리 가능
```

**트래픽 급증 시 설정**
- 최소 커넥션 수 = 최대 커넥션 수로 동일하게 설정
- 커넥션 생성 오버헤드를 제거하여 안정성 확보

#### DB CPU 사용률과 커넥션 수

**핵심 원칙: DB CPU 80% 이상이면 커넥션을 늘리면 안 되고 줄여야 한다**

이유:
- DB CPU가 이미 포화 상태인데 커넥션을 늘리면 컨텍스트 스위칭 증가
- 더 많은 쿼리가 동시 실행되어 CPU 경합 심화
- 결과적으로 전체 처리량 감소

해결책:
1. 쿼리 튜닝으로 CPU 사용률 낮추기
2. 캐시 도입으로 DB 부하 줄이기
3. CPU 사용률이 낮아진 후 API 서버 증설 고려

#### 커넥션 풀 세부 설정

**커넥션 대기 시간**
- 짧게 설정하여 빠른 실패(fail-fast) 유도
- 무한 대기로 인한 전체 시스템 지연 방지

**최대 유휴 시간**
- 커넥션이 사용되지 않고 유지되는 시간 제한
- `SELECT 1 FROM DUAL` 같은 health check로 유효성 확인

#### API 서버와 DB 커넥션 수 균형

**전체 시스템 관점에서 계산 필요**

```
API 서버 10대 × 커넥션 풀 20개 = 총 200개 커넥션
→ DB는 최소 200개 이상의 커넥션 처리 가능해야 함
```

주의사항:
- DB CPU가 70% 이상이면 커넥션을 늘려도 소용없음
- 이 경우 쿼리 튜닝과 캐시로 CPU 사용률을 낮춘 후 API 서버 증설

### 인덱스 최적화

#### 선택도(Selectivity)와 인덱스 효율

**선택도란?**
- 컬럼 값의 다양성을 나타내는 지표
- 선택도가 높을수록 (= 값이 다양할수록) 인덱스 효율 증가

**선택도가 낮아도 인덱스가 유효한 경우**
- 쿼리 사용 빈도가 매우 높은 경우
- 전체 스캔 비용이 인덱스 스캔보다 훨씬 큰 경우

#### 인덱스 활용 최적화

**쿼리에 인덱스 컬럼만 프로젝션**

```kotlin
// 인덱스: (name, age)
// 좋은 예: 인덱스만 읽음 (커버링 인덱스)
SELECT name, age FROM users WHERE name = 'Kim'

// 나쁜 예: 테이블까지 접근 필요
SELECT name, age, address FROM users WHERE name = 'Kim'
```

인덱스 컬럼만 조회하면 인덱스에서 바로 결과를 가져와 테이블 접근 생략

#### 복합 인덱스 관리

**불필요한 복합 인덱스 제거**

```
인덱스 A: (a, b)
인덱스 B: (a, b, c)

만약 WHERE a = ? AND b = ? 조회가 충분히 적은 결과를 반환한다면,
인덱스 B의 컬럼 c는 무의미하고 CUD 성능만 저하시킴
```

원칙:
- 실제 조회 결과 건수를 확인하여 불필요한 컬럼 제거
- 인덱스가 많을수록 INSERT/UPDATE/DELETE 성능 저하

#### 타입 일치

**인덱스 활용 시 타입 일치 필수**

```sql
-- 인덱스: user_id (INT 타입)

-- 나쁜 예: 문자열로 조회 → 타입 변환으로 인덱스 미사용
WHERE user_id = '12345'

-- 좋은 예: 인덱스 타입과 동일
WHERE user_id = 12345
```

타입이 다르면 내부적으로 변환 과정을 거쳐 인덱스를 제대로 활용하지 못함

### 문자 검색 최적화

**ElasticSearch를 못 쓰는 환경**

MySQL의 `FULLTEXT` 인덱스 활용:
- LIKE '%검색어%'보다 월등히 빠름
- 형태소 분석 등 기본적인 전문 검색 기능 제공

### MySQL 테이블 변경 주의사항

**ALTER TABLE의 동작 방식**
1. 새 테이블 생성
2. 원본 데이터를 새 테이블로 복사
3. 새 테이블로 교체

이 과정에서:
- CUD 작업이 계속 발생하므로 주의 필요
- 큰 테이블은 변경에 시간이 오래 걸림
- 온라인 DDL 등의 기법 고려

## 실무 적용

### 성능 문제 발생 시 체크리스트

1. **병목 지점 파악**
   - DB CPU 사용률 확인
   - 외부 API 응답 시간 확인
   - 애플리케이션 스레드 상태 확인

2. **DB 성능 이슈**
   - CPU 70% 이상: 쿼리 튜닝, 캐시 도입 우선
   - 커넥션 부족: 전체 시스템의 커넥션 수 균형 확인
   - 느린 쿼리: 인덱스 활용 여부, 실행 계획 확인

3. **확장 전략 결정**
   - 단기: 수직 확장으로 대응
   - 장기: 병목 해결 후 수평 확장

### 금융권에서의 고려사항

- 트래픽 예측과 사전 용량 계획 필수
- 커넥션 풀 설정은 보수적으로 시작하여 점진적 증가
- 인덱스 변경은 철저한 테스트 후 적용 (운영 영향도 큼)
- 피크 타임 대비 여유 커넥션 확보

---

**출처**
- 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식 (최범균)
