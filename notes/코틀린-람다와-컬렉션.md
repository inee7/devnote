---
tags: [kotlin, lambda, collection, functional-programming]
---

## 한 줄 요약

코틀린의 람다식과 컬렉션 함수형 API는 간결하고 표현력 있는 코드 작성을 가능하게 한다.

## 핵심 정리

- 람다식은 다른 함수에 넘길 수 있는 작은 코드 조각
- 컬렉션 함수형 API (`filter`, `map`, `all`, `any` 등)로 간결한 코드 작성
- 시퀀스(sequence)로 지연 계산하여 성능 최적화
- 수신 객체 지정 람다 (`with`, `apply`)로 객체 초기화 및 설정 간소화
- SAM 변환으로 자바 함수형 인터페이스와 자연스러운 통합

## 상세 내용

### 람다 식의 기본

```kotlin
/* 람다 식 문법 */
{ x: Int, y: Int -> x + y }

/* 람다를 변수에 저장 */
val sum = { x: Int, y: Int -> x + y }
println(sum(1, 2))  /* 3 */

/* maxBy를 사용한 컬렉션 검색 */
data class Person(val name: String, val age: Int)

val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })  /* Person(name=Bob, age=31) */

/* 멤버 참조 사용 */
people.maxBy(Person::age)
```

람다 특징:
- 항상 중괄호로 둘러싸임
- 화살표(`->`)가 인자 목록과 본문을 구분
- 인자가 하나인 경우 `it` 사용 가능
- 타입 추론 가능

### 람다와 컬렉션 API

#### filter와 map

```kotlin
val list = listOf(1, 2, 3, 4)

/* filter - 조건을 만족하는 원소만 선택 */
println(list.filter { it % 2 == 0 })  /* [2, 4] */

/* map - 각 원소를 변환 */
println(list.map { it * it })  /* [1, 4, 9, 16] */

/* 체이닝 */
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.filter { it.age > 30 }.map(Person::name))  /* [Bob] */

/* 맵에 대한 filter와 map */
val numbers = mapOf(0 to "zero", 1 to "one")
println(numbers.mapValues { it.value.toUpperCase() })  /* {0=ZERO, 1=ONE} */
```

#### all, any, count, find

```kotlin
val canBeInClub27 = { p: Person -> p.age <= 27 }

val people = listOf(Person("Alice", 27), Person("Bob", 31))

/* all - 모든 원소가 조건을 만족하는지 */
println(people.all(canBeInClub27))  /* false */

/* any - 하나라도 조건을 만족하는지 */
println(people.any(canBeInClub27))  /* true */

/* count - 조건을 만족하는 원소 개수 */
println(people.count(canBeInClub27))  /* 1 */

/* find - 조건을 만족하는 첫 번째 원소 (없으면 null) */
println(people.find(canBeInClub27))  /* Person(name=Alice, age=27) */
```

#### groupBy

```kotlin
val people = listOf(
    Person("Alice", 27),
    Person("Bob", 31),
    Person("Carol", 31)
)

/* 나이별로 그룹화 */
println(people.groupBy { it.age })
/* {27=[Person(name=Alice, age=27)],
     31=[Person(name=Bob, age=31), Person(name=Carol, age=31)]} */

/* 첫 글자로 그룹화 */
val list = listOf("a", "ab", "b")
println(list.groupBy(String::first))  /* {a=[a, ab], b=[b]} */
```

#### flatMap과 flatten

```kotlin
class Book(val title: String, val authors: List<String>)

val books = listOf(
    Book("Thursday Next", listOf("Jasper Fforde")),
    Book("Mort", listOf("Terry Pratchett")),
    Book("Good Omens", listOf("Terry Pratchett", "Neil Gaiman"))
)

/* flatMap - 각 원소를 변환하고 결과를 하나의 리스트로 평탄화 */
println(books.flatMap { it.authors }.toSet())
/* [Jasper Fforde, Terry Pratchett, Neil Gaiman] */

val strings = listOf("abc", "def")
println(strings.flatMap { it.toList() })  /* [a, b, c, d, e, f] */
```

### 지연 계산 컬렉션 연산: 시퀀스

```kotlin
/* 즉시 계산 - 중간 컬렉션 생성 */
people.map(Person::name).filter { it.startsWith("A") }

/* 지연 계산 - 중간 컬렉션 없음 */
people.asSequence()
    .map(Person::name)
    .filter { it.startsWith("A") }
    .toList()
```

시퀀스 특징:
- 원소가 많은 경우 성능 향상
- 중간 연산은 지연되며, 최종 연산에서만 수행
- 각 원소에 대해 모든 연산을 순차적으로 적용

```kotlin
/* 시퀀스 생성 */
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
println(numbersTo100.sum())  /* 5050 */
```

### 자바 함수형 인터페이스와 SAM 변환

```kotlin
/* 자바 메소드에 람다 전달 */
void postponeComputation(int delay, Runnable computation)

postponeComputation(1000) { println(42) }

/* SAM 생성자로 명시적 변환 */
fun createAllDoneRunnable(): Runnable {
    return Runnable { println("All Done") }
}

createAllDoneRunnable().run()  /* All Done! */

/* 리스너 재사용 */
val listener = OnClickListener { view ->
    val text = when (view.id) {
        R.id.button1 -> "First Button"
        R.id.button2 -> "Second Button"
        else -> "Unknown button"
    }
    toast(text)
}

button1.setOnClickListener(listener)
button2.setOnClickListener(listener)
```

### 수신 객체 지정 람다

#### with 함수

```kotlin
/* with 없이 알파벳 만들기 */
fun alphabet(): String {
    val result = StringBuilder()
    for (letter in 'A'..'Z') {
        result.append(letter)
    }
    result.append("\nNow I know the alphabet!")
    return result.toString()
}

/* with를 사용해 간결하게 */
fun alphabet() = with(StringBuilder()) {
    for (letter in 'A'..'Z') {
        append(letter)  /* this 생략 가능 */
    }
    append("\nNow I know the alphabet!")
    toString()
}
```

#### apply 함수

```kotlin
/* apply를 사용한 알파벳 만들기 */
fun alphabet() = StringBuilder().apply {
    for (letter in 'A'..'Z') {
        append(letter)
    }
    append("\nNow I know the alphabet!")
}.toString()

/* TextView 초기화에 apply 활용 */
fun createViewWithCustomAttributes(context: Context) =
    TextView(context).apply {
        text = "Sample Text"
        textSize = 20.0
        setPadding(10, 0, 0, 0)
    }
```

#### buildString 함수

```kotlin
/* buildString으로 더 간결하게 */
fun alphabet() = buildString {
    for (letter in 'A'..'Z') {
        append(letter)
    }
    append("\nNow I know the alphabet!")
}
```

### 람다의 특별한 기능

#### 람다가 캡처한 변수

```kotlin
/* 함수 인자를 람다 안에서 사용 */
fun printMessageWithPrefix(messages: Collection<String>, prefix: String) {
    messages.forEach {
        println("$prefix $it")  /* 외부 변수 접근 */
    }
}

val errors = listOf("403 Forbidden", "404 Not Found")
printMessageWithPrefix(errors, "Error:")

/* 람다 안에서 외부 변수 변경 (코틀린은 final이 아니어도 가능) */
fun printProblemCounts(responses: Collection<String>) {
    var clientErrors = 0
    var serverErrors = 0

    responses.forEach {
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startsWith("5")) {
            serverErrors++
        }
    }

    println("$clientErrors client errors, $serverErrors server errors")
}
```

#### let 함수

```kotlin
fun sendEmailTo(email: String) {
    println("Sending email to $email")
}

/* let을 사용한 null 체크 */
var email: String? = "yole@example.com"
email?.let { sendEmailTo(it) }  /* Sending email to yole@example.com */

email = null
email?.let { sendEmailTo(it) }  /* 실행되지 않음 */

/* 여러 값에 대한 null 체크는 if 사용 권장 */
```

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 5장
