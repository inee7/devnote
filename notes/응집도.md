---
tags: [oop, cohesion, design, static-method]
---

# 응집도

## 한 줄 요약

응집도는 데이터와 로직의 결합 강도이며, static 메서드 오용을 피하고 데이터와 로직을 같은 클래스에 배치해야 높아진다

## 핵심 정리

- 응집도: 모듈 내부 데이터와 로직 사이의 관계 강도
- 데이터와 로직 분리 시 응집도 저하
- static 메서드 판별법: static 붙여서 컴파일 되면 인스턴스 변수를 사용하지 않는 것
- 횡단 관심사(로그 출력, 포맷 변환)는 static 허용
- private 생성자 + 팩토리 메서드로 응집도 유지
- 매개변수가 많으면 응집도가 낮은 신호

## 상세 내용

### 응집도란?

응집도란 **모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지** 나타내는 지표다.

**높은 응집도:**
- 데이터와 그 데이터를 조작하는 로직이 같은 클래스에 있음
- 관련된 기능이 한 곳에 모여 있음

**낮은 응집도:**
- 데이터와 로직이 분리되어 있음
- 관련 없는 기능이 한 클래스에 섞여 있음

### 응집도를 낮추는 패턴

#### 1. 데이터와 로직 분리

```kotlin
// ❌ 응집도 낮음
class Location {
    var x: Int = 0
    var y: Int = 0
}

class ActorManager {
    fun shift(location: Location) {
        location.x += 10  // Location의 데이터를 외부에서 조작
    }
}
```

**문제점:**
- Location의 데이터를 ActorManager에서 조작
- 외부에서 변경되었다는 것을 알 수 없음
- 함수 내용을 하나하나 확인해야 해서 가독성 저하

**해결:**
```kotlin
// ✅ 응집도 높음
class Location {
    private var x: Int = 0
    private var y: Int = 0

    fun shift() {
        this.x += 10  // 데이터와 로직이 함께
    }
}
```

#### 2. Static 메서드 오용

**판별법:** 객체의 인스턴스 변수를 사용하는 함수여야 한다.

함수에 `static`을 붙여보고 **컴파일 문제가 되지 않는다면** 인스턴스 변수를 사용하지 않는 것이므로 응집도를 고려해봐야 한다.

```java
class Calculator {
    int value;

    // ❌ static으로 변경 가능 = 인스턴스 변수 미사용
    int add(int a, int b) {
        return a + b;
    }

    // ✅ static으로 변경 불가 = 인스턴스 변수 사용
    int addToValue(int a) {
        return value + a;
    }
}
```

**허용되는 경우:**
- 로그 출력
- 포맷 변환
- 횡단 관심사 (Cross-cutting Concerns)

```java
class Logger {
    static void log(String message) {  // ✅ 횡단 관심사라 허용
        System.out.println(message);
    }
}
```

### 응집도를 높이는 방법

#### 1. private 생성자 + 팩토리 메서드

```java
class Money {
    private final int amount;

    private Money(int amount) {  // private 생성자
        if (amount < 0) throw new IllegalArgumentException();
        this.amount = amount;
    }

    public static Money create(int amount) {  // 팩토리 메서드
        return new Money(amount);
    }

    public Money add(Money other) {  // 인스턴스 변수 사용
        return new Money(this.amount + other.amount);
    }
}
```

**장점:**
- 의도대로 인스턴스 변수를 가지며 응집된 로직도 가질 수 있음
- 생성 로직이 복잡해지면 팩토리 클래스로 분리 가능

#### 2. 매개변수 줄이기

매개변수가 많다는 것은 **처리할 것이 많은 함수**라는 신호다.

```java
// ❌ 매개변수가 많음 = 응집도 낮음
void createOrder(String productName, int quantity, int price,
                 String customerName, String address) {
    // ...
}

// ✅ 객체로 묶어서 응집도 향상
void createOrder(Product product, Customer customer) {
    // ...
}
```

## 실무 적용

### 응집도와 단일 책임 원칙

응집도가 높으면 자연스럽게 단일 책임 원칙(SRP)을 따르게 된다.

### Spring에서의 응집도

```java
// ❌ Service에 모든 로직
@Service
class OrderService {
    void createOrder(Long productId, int quantity, Long customerId) {
        // 재고 확인 로직
        // 할인 계산 로직
        // 주문 생성 로직
        // 결제 로직
    }
}

// ✅ 도메인 모델에 응집
class Order {
    private List<OrderItem> items;
    private Money totalAmount;

    Money calculateTotal() {
        return items.stream()
            .map(OrderItem::getAmount)
            .reduce(Money.ZERO, Money::add);
    }
}
```

### 주의사항

- 무조건 static을 피하라는 것이 아님
- Utility 성격의 메서드는 static이 적절할 수 있음
- 응집도와 성능 사이의 균형 고려

## 관련 노트

- [[불변]]
- [[단일 책임 원칙]]

---

**출처**
- 내 코드가 그렇게 이상한가요 (마츠오카 켄타로), 5장

#oop #cohesion #design