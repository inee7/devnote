---
tags: [testing, slice-test, spring-boot, webmvctest, datajpatest, integration-test]
---
# 슬라이스 테스트 (Slice Test)

## 한 줄 요약

슬라이스 테스트는 Spring Boot 애플리케이션의 특정 계층만 선택적으로 로드하여 빠르게 검증하는 부분 통합 테스트 방식이다.

## 핵심 정리

- **정의**: Spring의 자동 설정을 기능별로 잘라서 필요한 빈만 띄우는 테스트
- **목적**: 전체 컨텍스트 로딩 없이 특정 계층의 설정/매핑/동작 검증
- **장점**: 통합 테스트보다 빠르고, 단위 테스트보다 현실적
- **주요 애노테이션**: `@WebMvcTest`, `@DataJpaTest`, `@JsonTest`, `@RestClientTest` 등
- **테스트 비중**: 전체 테스트의 10-20% 권장 (유닛 60-70%, 통합 20-30%, E2E 0-5%)
- **격리 전략**: 테스트 대상 계층만 실제 빈, 나머지는 `@MockBean`으로 대체

## 상세 내용

### 슬라이스 테스트란?

**배경**

Spring Boot 애플리케이션에서 `@SpringBootTest`를 사용하면:
- 전체 ApplicationContext 로드
- 모든 빈 생성 및 의존성 주입
- 시간이 오래 걸림 (초기화에 수 초 ~ 수십 초)

**슬라이스 테스트의 접근**

특정 계층(Slice)만 선택적으로 로드:
- Web 계층만 (`@WebMvcTest`)
- Data 계층만 (`@DataJpaTest`)
- JSON 직렬화만 (`@JsonTest`)
- 외부 클라이언트만 (`@RestClientTest`)

**이점**
- 빠른 피드백 (일반적으로 1~3초 내 실행)
- 명확한 테스트 범위
- 계층 간 책임 분리 강제

### 주요 슬라이스 테스트 애노테이션

```
Web 계층
 ├─ @WebMvcTest          (Spring MVC 컨트롤러)
 └─ @WebFluxTest         (Spring WebFlux)

Data 계층
 ├─ @DataJpaTest         (JPA 엔티티, Repository)
 ├─ @JdbcTest            (JDBC)
 ├─ @DataMongoTest       (MongoDB)
 ├─ @DataRedisTest       (Redis)
 └─ @DataNeo4jTest       (Neo4j)

Serialization
 └─ @JsonTest            (Jackson 직렬화/역직렬화)

외부 연동
 └─ @RestClientTest      (REST 클라이언트)

메시징
 ├─ @KafkaTest           (Kafka, 제한적)
 └─ @JmsTest             (JMS)
```

### @WebMvcTest

**목적**: Controller 레이어의 HTTP 요청/응답 처리 검증

**로드되는 컴포넌트**
- `@Controller`, `@RestController`
- `@ControllerAdvice`, `@JsonComponent`
- Jackson (직렬화/역직렬화)
- Bean Validation (`@Valid`)
- ArgumentResolver, MessageConverter
- Filter (일부, 설정 필요)

**로드되지 않는 컴포넌트**
- `@Service`, `@Repository`, `@Component`
- `@Configuration` (일부 제외)

**기본 사용법**

```kotlin
@WebMvcTest(OrderController::class)
class OrderControllerTest {

    @Autowired
    private lateinit var mockMvc: MockMvc

    @MockBean
    private lateinit var orderService: OrderService

    @Test
    fun `주문 조회 API 응답 형식 검증`() {
        // given
        given(orderService.getOrder(1L))
            .willReturn(OrderDto(1L, "상품A", 10000))

        // when & then
        mockMvc.perform(get("/orders/1"))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.productName").value("상품A"))
            .andExpect(jsonPath("$.amount").value(10000))
    }
}
```

**테스트 케이스 유형**

**CASE 1: 계약 테스트 (Contract Test)**

목표: API가 계약된 요청에 올바른 응답을 반환하는가?

```kotlin
@Test
fun `주문 생성 API는 201 Created와 생성된 주문 ID를 반환한다`() {
    val request = OrderCreateRequest("상품A", 2)
    given(orderService.createOrder(any()))
        .willReturn(OrderDto(123L, "상품A", 20000))

    mockMvc.perform(
        post("/orders")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request))
    )
        .andExpect(status().isCreated)
        .andExpect(header().exists("Location"))
        .andExpect(jsonPath("$.id").value(123))
}
```

**CASE 2: Validation 테스트**

목표: 잘못된 요청에 적절한 에러 응답을 하는가?

```kotlin
@Test
fun `주문 수량이 음수면 400 Bad Request를 반환한다`() {
    val request = OrderCreateRequest("상품A", -1)  // 잘못된 입력

    mockMvc.perform(
        post("/orders")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request))
    )
        .andExpect(status().isBadRequest)
        .andExpect(jsonPath("$.errors[0].field").value("quantity"))
        .andExpect(jsonPath("$.errors[0].message").exists())
}
```

**CASE 3: @ControllerAdvice 동작 테스트**

목표: 예외에 따른 에러 계약이 잘 되어있는지

```kotlin
@Test
fun `존재하지 않는 주문 조회 시 404 Not Found를 반환한다`() {
    given(orderService.getOrder(999L))
        .willThrow(OrderNotFoundException("주문을 찾을 수 없습니다"))

    mockMvc.perform(get("/orders/999"))
        .andExpect(status().isNotFound)
        .andExpect(jsonPath("$.errorCode").value("ORDER_NOT_FOUND"))
        .andExpect(jsonPath("$.message").exists())
}
```

**인터셉터 테스트**

인터셉터는 기본적으로 로드되지 않으므로 명시적으로 추가:

```kotlin
@WebMvcTest(OrderController::class)
@Import(WebMvcConfig::class, AuthInterceptor::class)
class OrderControllerWithInterceptorTest {

    @Test
    fun `인증 헤더가 없으면 401 Unauthorized를 반환한다`() {
        mockMvc.perform(get("/orders/1"))
            .andExpect(status().isUnauthorized)
    }

    @Test
    fun `유효한 인증 토큰이 있으면 200 OK를 반환한다`() {
        mockMvc.perform(
            get("/orders/1")
                .header("Authorization", "Bearer valid-token")
        )
            .andExpect(status().isOk)
    }
}
```

### @DataJpaTest

**목적**: JPA 엔티티, Repository, 쿼리 메서드 검증

**로드되는 컴포넌트**
- `@Entity` 클래스
- `@Repository` (JPA Repository)
- `EntityManager`, `TestEntityManager`
- 내장 데이터베이스 (H2, HSQL 등)

**기본 특성**
- 각 테스트 메서드마다 트랜잭션 시작 후 롤백 (기본값)
- 실제 DB 쿼리 실행
- `@Transactional` 자동 적용

**기본 사용법**

```kotlin
@DataJpaTest
class OrderRepositoryTest {

    @Autowired
    private lateinit var orderRepository: OrderRepository

    @Autowired
    private lateinit var testEntityManager: TestEntityManager

    @Test
    fun `주문을 저장하고 조회할 수 있다`() {
        // given
        val order = Order(
            productName = "상품A",
            quantity = 2,
            amount = Money(20000)
        )

        // when
        val saved = orderRepository.save(order)
        testEntityManager.flush()
        testEntityManager.clear()  // 1차 캐시 제거

        // then
        val found = orderRepository.findById(saved.id!!).orElseThrow()
        assertThat(found.productName).isEqualTo("상품A")
        assertThat(found.quantity).isEqualTo(2)
    }
}
```

**쿼리 메서드 테스트**

```kotlin
@Test
fun `특정 상태의 주문만 조회된다`() {
    // given
    orderRepository.save(Order(status = OrderStatus.PENDING))
    orderRepository.save(Order(status = OrderStatus.COMPLETED))
    orderRepository.save(Order(status = OrderStatus.PENDING))
    testEntityManager.flush()

    // when
    val pendingOrders = orderRepository.findByStatus(OrderStatus.PENDING)

    // then
    assertThat(pendingOrders).hasSize(2)
    assertThat(pendingOrders).allMatch { it.status == OrderStatus.PENDING }
}
```

**@Query 커스텀 쿼리 테스트**

```kotlin
@Test
fun `특정 기간의 주문 금액 합계를 조회한다`() {
    // given
    val start = LocalDateTime.of(2025, 1, 1, 0, 0)
    val end = LocalDateTime.of(2025, 1, 31, 23, 59)

    orderRepository.save(Order(amount = Money(10000), createdAt = start.plusDays(1)))
    orderRepository.save(Order(amount = Money(20000), createdAt = start.plusDays(2)))
    orderRepository.save(Order(amount = Money(5000), createdAt = end.plusDays(1)))  // 범위 밖
    testEntityManager.flush()

    // when
    val total = orderRepository.getTotalAmountBetween(start, end)

    // then
    assertThat(total).isEqualTo(Money(30000))
}
```

**실제 DB 사용하기**

```kotlin
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class OrderRepositoryWithRealDBTest {

    @Container
    val postgres = PostgreSQLContainer<Nothing>("postgres:15").apply {
        withDatabaseName("test")
        withUsername("test")
        withPassword("test")
    }

    @DynamicPropertySource
    fun properties(registry: DynamicPropertyRegistry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl)
        registry.add("spring.datasource.username", postgres::getUsername)
        registry.add("spring.datasource.password", postgres::getPassword)
    }

    @Test
    fun `PostgreSQL 특정 기능 테스트`() {
        // 실제 PostgreSQL 기능 테스트
    }
}
```

### @JsonTest

**목적**: Jackson 직렬화/역직렬화 검증

**로드되는 컴포넌트**
- Jackson `ObjectMapper`
- `@JsonComponent`
- `JacksonTester<T>`

**기본 사용법**

```kotlin
@JsonTest
class OrderDtoJsonTest {

    @Autowired
    private lateinit var json: JacksonTester<OrderDto>

    @Test
    fun `OrderDto를 JSON으로 직렬화한다`() {
        // given
        val order = OrderDto(
            id = 123L,
            productName = "상품A",
            amount = 10000,
            createdAt = LocalDateTime.of(2025, 1, 5, 10, 30)
        )

        // when & then
        assertThat(json.write(order)).isEqualToJson("""
            {
                "id": 123,
                "productName": "상품A",
                "amount": 10000,
                "createdAt": "2025-01-05T10:30:00"
            }
        """)
    }

    @Test
    fun `JSON을 OrderDto로 역직렬화한다`() {
        // given
        val content = """
            {
                "id": 123,
                "productName": "상품A",
                "amount": 10000
            }
        """

        // when
        val order = json.parseObject(content)

        // then
        assertThat(order.id).isEqualTo(123L)
        assertThat(order.productName).isEqualTo("상품A")
        assertThat(order.amount).isEqualTo(10000)
    }

    @Test
    fun `필드명 매핑이 올바르게 동작한다`() {
        val order = OrderDto(id = 1L, productName = "테스트")

        assertThat(json.write(order))
            .extractingJsonPathStringValue("$.productName")
            .isEqualTo("테스트")
    }
}
```

**커스텀 Serializer/Deserializer 테스트**

```kotlin
@JsonTest
class MoneyJsonTest {

    @Autowired
    private lateinit var json: JacksonTester<Money>

    @Test
    fun `Money는 value 필드로 직렬화된다`() {
        val money = Money(10000)

        assertThat(json.write(money))
            .extractingJsonPathNumberValue("$.value")
            .isEqualTo(10000)
    }

    @Test
    fun `JSON에서 Money로 역직렬화된다`() {
        val content = """{"value": 10000, "currency": "KRW"}"""

        val money = json.parseObject(content)

        assertThat(money.value).isEqualTo(10000)
    }
}
```

### @RestClientTest

**목적**: REST 클라이언트 (RestTemplate, WebClient 등) 동작 검증

**로드되는 컴포넌트**
- 테스트 대상 클라이언트 빈
- `MockRestServiceServer` (RestTemplate용)
- Jackson, MessageConverter

**RestTemplate 테스트**

```kotlin
@RestClientTest(PaymentGatewayClient::class)
class PaymentGatewayClientTest {

    @Autowired
    private lateinit var client: PaymentGatewayClient

    @Autowired
    private lateinit var mockServer: MockRestServiceServer

    @Test
    fun `결제 요청이 성공하면 승인 번호를 반환한다`() {
        // given
        mockServer.expect(requestTo("/payments"))
            .andExpect(method(HttpMethod.POST))
            .andExpect(jsonPath("$.amount").value(10000))
            .andRespond(
                withSuccess("""
                    {
                        "approvalNumber": "ABC123",
                        "status": "APPROVED"
                    }
                """, MediaType.APPLICATION_JSON)
            )

        // when
        val response = client.requestPayment(PaymentRequest(10000))

        // then
        assertThat(response.approvalNumber).isEqualTo("ABC123")
        assertThat(response.status).isEqualTo("APPROVED")
        mockServer.verify()
    }

    @Test
    fun `결제 요청이 실패하면 예외를 발생시킨다`() {
        // given
        mockServer.expect(requestTo("/payments"))
            .andRespond(withBadRequest())

        // when & then
        assertThatThrownBy { client.requestPayment(PaymentRequest(10000)) }
            .isInstanceOf(PaymentException::class.java)
    }
}
```

### 기타 슬라이스 테스트

**@DataMongoTest**

```kotlin
@DataMongoTest
class UserDocumentRepositoryTest {

    @Autowired
    private lateinit var repository: UserDocumentRepository

    @Test
    fun `사용자 문서를 저장하고 조회한다`() {
        val user = UserDocument(name = "Alice", email = "alice@example.com")
        repository.save(user)

        val found = repository.findByEmail("alice@example.com")
        assertThat(found?.name).isEqualTo("Alice")
    }
}
```

**@DataRedisTest**

```kotlin
@DataRedisTest
class CacheRepositoryTest {

    @Autowired
    private lateinit var redisTemplate: RedisTemplate<String, String>

    @Test
    fun `Redis에 값을 저장하고 조회한다`() {
        redisTemplate.opsForValue().set("key1", "value1")

        val value = redisTemplate.opsForValue().get("key1")
        assertThat(value).isEqualTo("value1")
    }
}
```

## 실무 적용

### 슬라이스 테스트 선택 가이드

| 테스트 대상 | 슬라이스 애노테이션 | 목적 |
|------------|------------------|------|
| REST API 계약 | `@WebMvcTest` | HTTP 요청/응답, Validation, 에러 핸들링 |
| JPA 쿼리 메서드 | `@DataJpaTest` | 쿼리 동작, 엔티티 매핑, 영속성 |
| JSON 직렬화 | `@JsonTest` | DTO 필드명, 날짜 포맷, 커스텀 serializer |
| 외부 API 클라이언트 | `@RestClientTest` | HTTP 요청 구성, 응답 파싱, 에러 처리 |

### 통합 테스트가 필요한 케이스

슬라이스 테스트로는 검증할 수 없는 경우 통합 테스트(`@SpringBootTest`) 사용:

1. **필터 체인 동작**: 필터는 슬라이스 테스트에 기본적으로 로드되지 않음
2. **트랜잭션 경계**: 여러 계층에 걸친 트랜잭션 동작
3. **이벤트 발행/구독**: Spring Event, TransactionalEventListener
4. **보안 설정**: Spring Security 전체 흐름
5. **전체 유스케이스**: Service → Repository → DB까지 end-to-end 검증

### 테스트 구성 전략

```kotlin
// 1. 도메인 로직: 순수 단위 테스트
class OrderTest {
    @Test
    fun `주문 금액을 계산한다`() {
        val order = Order(quantity = 2, unitPrice = Money(5000))
        assertThat(order.totalAmount()).isEqualTo(Money(10000))
    }
}

// 2. Repository: @DataJpaTest
@DataJpaTest
class OrderRepositoryTest {
    @Test
    fun `주문을 저장하고 조회한다`() { }
}

// 3. Controller: @WebMvcTest
@WebMvcTest(OrderController::class)
class OrderControllerTest {
    @Test
    fun `주문 생성 API 검증`() { }
}

// 4. 전체 흐름: @SpringBootTest
@SpringBootTest
class OrderIntegrationTest {
    @Test
    fun `주문 생성부터 저장까지 전체 흐름 검증`() { }
}
```

## 주의사항 및 트러블슈팅

### 1. 슬라이스 테스트에서 다른 빈이 필요한 경우

**문제**: `@WebMvcTest`에서 커스텀 Converter가 필요한 경우

**해결**:
```kotlin
@WebMvcTest(OrderController::class)
@Import(StringToMoneyConverter::class)  // 필요한 빈 명시적으로 추가
class OrderControllerTest { }
```

### 2. @DataJpaTest에서 서비스 로직 필요

**문제**: Repository 테스트에서 Service가 필요한 경우

**해결**: 설계 재검토 필요. Repository는 순수 데이터 접근만 담당해야 함. 복잡한 로직은 통합 테스트로 이동.

### 3. 실제 DB를 사용하고 싶은 경우

**해결**:
```kotlin
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class OrderRepositoryTest { }
```

### 4. 슬라이스 테스트가 느린 경우

**원인**: 불필요한 `@MockBean` 과다 사용, Context 캐싱 실패

**해결**:
- `@MockBean`을 최소화 (Context 캐시 무효화 원인)
- 테스트 클래스 간 슬라이스 설정 통일
- 필요하면 공통 설정을 별도 클래스로 분리

```kotlin
// 공통 설정
@WebMvcTest(OrderController::class)
@Import(CommonTestConfig::class)
abstract class BaseControllerTest
```

### 5. 트랜잭션 롤백이 안 되는 경우

`@DataJpaTest`는 기본적으로 `@Transactional`이지만, 명시적으로 커밋하면 롤백 안 됨:

```kotlin
@Test
fun test() {
    orderRepository.save(order)
    testEntityManager.flush()
    // 기본적으로 테스트 종료 시 롤백됨
}
```

## 금융권에서의 고려사항

- **계약 테스트 필수**: API 응답 스키마가 변경되면 하위 호환성 검증 필요
- **Validation 엄격 검증**: 금액 필드의 null, 음수, 소수점 등 엣지 케이스 철저히 테스트
- **에러 응답 표준화**: `@ControllerAdvice`로 모든 예외를 표준 에러 형식으로 변환
- **감사 로그 검증**: `@DataJpaTest`에서 엔티티의 생성/수정 시각 자동 기록 확인
- **JSON 직렬화 보안**: `@JsonTest`로 민감 정보(계좌번호, 비밀번호 등) 마스킹 확인
- **외부 연동 검증**: `@RestClientTest`로 타임아웃, 재시도, Circuit Breaker 동작 확인

## 관련 노트

- [[테스트의 종류]]
- [[단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실]]
- [[테스트-작성-원칙]]
- [[테스트더블]]
- [[Spring Boot 테스트 전략과 테스트 더블]]
- [[Junit]]
- [[스프링부트와 스프링프레임워크 관계]]

---

**출처**
- Spring Boot Testing Documentation
- Effective Software Testing (Maurício Aniche)
