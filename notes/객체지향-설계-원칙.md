---
tags: [oop, immutable, cohesion, first-class-collection, design, side-effect]
---

## 한 줄 요약

좋은 객체지향 설계는 불변성으로 부수효과를 방지하고, 데이터와 로직을 응집시키며, 컬렉션을 일급 객체로 캡슐화하여 안전하고 유지보수하기 쉬운 코드를 만든다.

## 핵심 정리

**불변성**
- 부수효과 원인: 가변 인스턴스, 매개변수 변경, 전역변수 변경, 외부 데이터 조작
- 이상적인 함수: 상태를 매개변수로 받고 변경하지 않으며 값만 반환
- 값 변경 시 새 인스턴스 생성
- 장점: 스레드 안전, 예측 가능, 캐싱 가능, 버그 감소

**응집도**
- 데이터와 로직을 같은 클래스에 배치
- static 메서드 판별법: static 붙여서 컴파일 되면 인스턴스 변수를 사용하지 않는 것
- 횡단 관심사(로그, 포맷)는 static 허용
- 매개변수가 많으면 응집도가 낮은 신호

**일급 컬렉션**
- 컬렉션을 Wrapping한 클래스
- 유효성 검증을 생성자에서 수행
- 불변성 보장: 새 인스턴스 반환, unmodifiableList 사용
- 비즈니스 로직 캡슐화, 이름을 가진 컬렉션

## 상세 내용

### 불변성 (Immutability)

#### 부수효과란?

함수가 외부 상태를 변경하거나 예상치 못한 영향을 주는 것을 부수효과(Side Effect)라고 한다.

**부수효과 발생 원인:**
1. **가변 인스턴스 사용**: 객체의 상태를 직접 변경
2. **매개변수 변경**: 전달받은 매개변수를 수정
3. **전역변수 변경**: 함수 밖의 변수를 변경
4. **외부 데이터 조작**: 파일, I/O, 네트워크 등

#### 부수효과를 막는 방법

**이상적인 함수:**
- 상태를 매개변수로 받는다
- 상태를 변경하지 않는다
- 값을 리턴하기만 한다

```java
// ❌ 부수효과 있음
class Counter {
    int count = 0;

    void increment() {
        count++;  // 상태를 직접 변경
    }
}

// ✅ 부수효과 없음
class Counter {
    final int count;

    Counter(int count) {
        this.count = count;
    }

    Counter increment() {
        return new Counter(count + 1);  // 새 인스턴스 반환
    }
}
```

#### 인스턴스 변수는 사용하면 안 되나?

**아니다.** 인스턴스 변수는 불변으로 만들어 영향이 전달되지 않게 할 수 있다.

객체지향 언어는 **클래스 내부에서 동일 인스턴스 변수를 사용하는 것을 허용**한다.

```java
class Money {
    private final int amount;  // 불변
    private final Currency currency;  // 불변

    Money add(Money other) {
        // 인스턴스 변수를 사용하지만 불변이므로 안전
        return new Money(this.amount + other.amount, this.currency);
    }
}
```

#### 불변 객체에서 값 변경하기

불변이라면 값을 변경할 때 **인스턴스를 새로 생성**해야 한다.

```java
Money money = new Money(1000, Currency.KRW);
Money increased = money.add(new Money(500, Currency.KRW));

// money는 그대로 1000원
// increased는 새로운 인스턴스로 1500원
```

#### 불변의 장점

1. **스레드 안전**: 여러 스레드에서 동시 접근해도 안전
2. **예측 가능**: 생성 후 상태가 변하지 않아 디버깅 쉬움
3. **캐싱 가능**: 값이 변하지 않으므로 안전하게 재사용 가능
4. **버그 감소**: 의도치 않은 상태 변경 방지

### 응집도 (Cohesion)

#### 응집도란?

응집도란 **모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지** 나타내는 지표다.

**높은 응집도:**
- 데이터와 그 데이터를 조작하는 로직이 같은 클래스에 있음
- 관련된 기능이 한 곳에 모여 있음

**낮은 응집도:**
- 데이터와 로직이 분리되어 있음
- 관련 없는 기능이 한 클래스에 섞여 있음

#### 응집도를 낮추는 패턴

**1. 데이터와 로직 분리**

```kotlin
// ❌ 응집도 낮음
class Location {
    var x: Int = 0
    var y: Int = 0
}

class ActorManager {
    fun shift(location: Location) {
        location.x += 10  // Location의 데이터를 외부에서 조작
    }
}
```

**문제점:**
- Location의 데이터를 ActorManager에서 조작
- 외부에서 변경되었다는 것을 알 수 없음
- 함수 내용을 하나하나 확인해야 해서 가독성 저하

**해결:**
```kotlin
// ✅ 응집도 높음
class Location {
    private var x: Int = 0
    private var y: Int = 0

    fun shift() {
        this.x += 10  // 데이터와 로직이 함께
    }
}
```

**2. Static 메서드 오용**

**판별법:** 객체의 인스턴스 변수를 사용하는 함수여야 한다.

함수에 `static`을 붙여보고 **컴파일 문제가 되지 않는다면** 인스턴스 변수를 사용하지 않는 것이므로 응집도를 고려해봐야 한다.

```java
class Calculator {
    int value;

    // ❌ static으로 변경 가능 = 인스턴스 변수 미사용
    int add(int a, int b) {
        return a + b;
    }

    // ✅ static으로 변경 불가 = 인스턴스 변수 사용
    int addToValue(int a) {
        return value + a;
    }
}
```

**허용되는 경우:**
- 로그 출력
- 포맷 변환
- 횡단 관심사 (Cross-cutting Concerns)

```java
class Logger {
    static void log(String message) {  // ✅ 횡단 관심사라 허용
        System.out.println(message);
    }
}
```

#### 응집도를 높이는 방법

**1. private 생성자 + 팩토리 메서드**

```java
class Money {
    private final int amount;

    private Money(int amount) {  // private 생성자
        if (amount < 0) throw new IllegalArgumentException();
        this.amount = amount;
    }

    public static Money create(int amount) {  // 팩토리 메서드
        return new Money(amount);
    }

    public Money add(Money other) {  // 인스턴스 변수 사용
        return new Money(this.amount + other.amount);
    }
}
```

**장점:**
- 의도대로 인스턴스 변수를 가지며 응집된 로직도 가질 수 있음
- 생성 로직이 복잡해지면 팩토리 클래스로 분리 가능

**2. 매개변수 줄이기**

매개변수가 많다는 것은 **처리할 것이 많은 함수**라는 신호다.

```java
// ❌ 매개변수가 많음 = 응집도 낮음
void createOrder(String productName, int quantity, int price,
                 String customerName, String address) {
    // ...
}

// ✅ 객체로 묶어서 응집도 향상
void createOrder(Product product, Customer customer) {
    // ...
}
```

### 일급 컬렉션 (First-Class Collection)

#### 일급 컬렉션이란?

컬렉션과 관련된 로직을 캡슐화한 클래스다.

**규칙:**
- 컬렉션을 인스턴스 변수로 가짐
- 컬렉션 외에 다른 인스턴스 변수는 없음

#### 기본 구현

```java
class Party {
    private final List<Member> members;

    Party(List<Member> members) {
        this.members = new ArrayList<>(members);
    }

    Party add(Member newMember) {
        List<Member> adding = new ArrayList<>(members);
        adding.add(newMember);
        return new Party(adding);  // 부수효과를 막기 위해 새로운 객체 리턴
    }

    List<Member> members() {
        return Collections.unmodifiableList(members);  // 외부에서 변경 못하게
    }
}
```

#### 일급 컬렉션의 장점

**1. 비즈니스 로직의 캡슐화**

```java
// ❌ 로직이 흩어짐
if (members.size() > 10) {
    throw new IllegalStateException("파티는 최대 10명까지 가능합니다");
}

// ✅ 일급 컬렉션에 캡슐화
class Party {
    private static final int MAX_SIZE = 10;
    private final List<Member> members;

    Party(List<Member> members) {
        if (members.size() > MAX_SIZE) {
            throw new IllegalStateException("파티는 최대 10명까지 가능합니다");
        }
        this.members = new ArrayList<>(members);
    }
}
```

**2. 불변성 보장**

```java
class Party {
    private final List<Member> members;

    Party add(Member newMember) {
        List<Member> newMembers = new ArrayList<>(this.members);
        newMembers.add(newMember);
        return new Party(newMembers);  // 새 인스턴스 반환
    }

    List<Member> getMembers() {
        return Collections.unmodifiableList(members);  // 수정 불가능한 뷰 반환
    }
}
```

**3. 이름을 가진 컬렉션**

```java
// ❌ 의미 불명확
List<Member> members = ...;

// ✅ 의미 명확
Party party = new Party(members);
```

**4. 중복 방지 로직**

```java
class Party {
    private final List<Member> members;

    boolean hasDuplicateNames() {
        return members.stream()
            .map(Member::getName)
            .distinct()
            .count() != members.size();
    }
}
```

## 실무 적용

### Kotlin에서의 구현

**불변 객체**

```kotlin
data class Money(
    val amount: Int,  // val = 불변
    val currency: Currency
) {
    fun add(other: Money) = Money(amount + other.amount, currency)
}

// 컬렉션도 불변으로
val immutableList = listOf(1, 2, 3)
val mutableList = mutableListOf(1, 2, 3)  // 명시적으로 가변 선언
```

**일급 컬렉션**

```kotlin
class Party(
    members: List<Member>
) {
    private val _members: List<Member> = members.toList()  // 방어적 복사

    init {
        require(_members.size <= MAX_SIZE) { "파티는 최대 10명까지 가능합니다" }
    }

    fun add(newMember: Member): Party {
        return Party(_members + newMember)  // 새 인스턴스 반환
    }

    val members: List<Member>
        get() = _members.toList()  // 불변 리스트 반환

    companion object {
        private const val MAX_SIZE = 10
    }
}
```

### Spring에서의 응집도

```java
// ❌ Service에 모든 로직
@Service
class OrderService {
    void createOrder(Long productId, int quantity, Long customerId) {
        // 재고 확인 로직
        // 할인 계산 로직
        // 주문 생성 로직
        // 결제 로직
    }
}

// ✅ 도메인 모델에 응집
class Order {
    private List<OrderItem> items;
    private Money totalAmount;

    Money calculateTotal() {
        return items.stream()
            .map(OrderItem::getAmount)
            .reduce(Money.ZERO, Money::add);
    }
}
```

### JPA Entity에서 활용

**일급 컬렉션과 JPA**

```java
@Entity
class Order {
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();

    // 직접 List를 노출하지 않고 일급 컬렉션 반환
    public OrderItems getOrderItems() {
        return new OrderItems(this.orderItems);
    }
}

class OrderItems {
    private final List<OrderItem> items;

    OrderItems(List<OrderItem> items) {
        this.items = new ArrayList<>(items);
    }

    public Money calculateTotalAmount() {
        return items.stream()
            .map(OrderItem::getAmount)
            .reduce(Money.ZERO, Money::add);
    }
}
```

### 응집도와 단일 책임 원칙

응집도가 높으면 자연스럽게 [[단일-책임-원칙]](SRP)을 따르게 된다.

## 금융권에서의 고려사항

**불변성**
- 거래 금액, 계좌 잔액 등은 반드시 불변 객체로 관리
- 상태 변경은 새 인스턴스 생성으로 처리하여 추적 가능
- 감사 로그에서 변경 이력 추적 용이

**응집도**
- 금융 규칙(이자 계산, 수수료, 한도 체크 등)은 도메인 모델에 응집
- Service 레이어는 트랜잭션과 도메인 조합만 담당
- 복잡한 비즈니스 로직을 Entity에 배치하여 테스트 용이성 확보

**일급 컬렉션**
- 거래 내역, 포인트 이력 등을 일급 컬렉션으로 관리
- 유효성 검증을 생성자에서 수행하여 잘못된 상태 방지
- 총액 계산, 필터링 등의 로직 캡슐화

**주의사항**
- 모든 것을 불변으로 만들 필요는 없음 (성능 중요 부분은 가변 고려)
- JPA Entity는 프레임워크 제약으로 가변 필드 필요할 수 있음
- 단순 DTO는 일급 컬렉션 없이 List 사용해도 무방

---

**출처**
- 내 코드가 그렇게 이상한가요 (마츠오카 켄타로), 4장, 5장, 7장

