트래픽몰리면 수직확장으로 급한불끌수있지만 장기적으로 문제
외부api/db 병목인데 수평확장하면 불에 기름붓는격
커넥션5 실행시간0.1초 
1초에 50개요청 
트래픽 급증하면 최소최대커넥션수동일
db cpu 80프로인데 커넥션 늘리면 안되고 줄여야한다 
커넥션대기시간 짧게 해라
최대유휴시간 
select 1 from dual 

문자검색시 엘라스틱서치 같은거 못쓰면 fulltext 써라 
인덱스 잘걸어야한다 
선택도selectivity가 높아야 (다양한값) 인덱스 효율이 좋은데 선택도가 낮아도 쿼리 사용율이 높으면 인덱스 걸자 
쿼리에 인덱스 값만 프로젝션하면 인덱스값만 가져오게되서 빠르다
복합인덱스 a,b 와 a,b,c 가 있는데 건수자체가 a,b 조회한게 갯수가 적다면 a,b,c의 인덱스가 무의미하고 cud 성능이 안좋다
쿼리조건을 잘 만들면 성능에 도움된다
수직확장도 성능에 도움된다
수평확장 중 조회용 별도로 둬도 도움된다
인덱스를 활용할때 타입이 다르면 비효율적이다 타입을 인덱스 타입에 맞게 줘야한다
mysql은 테이블변경시 새테이블 생성하고 원본의 
데이터복사한후 새테이블로 대체 한다 그과정에서 cud힌다
api 서버들의 커넥션 수와 디비의 최대 커넥션 가능수가 맞아야한다 db cpu가 70프로 넘는다면 커넥션 늘리면 안된다 이럴땐 쿼리튜닝과 캐시로 cpu낮춘후 api서버 늘릴수 있다 


외부서비스 연동해서 쓸때 타임아웃 없으면 무한 대기 걸릴수 있다

초반 추천 타임아웃
커탐아 - 3~5초
리탐아 - 5~30초
이것에서 조정 추천

okhttp는 콜탐아가 있음 요청시작부터 응답까지

포인트서비스를 호출하는 주문서비스가 있는데 포인트치감에 대해 리탐아 발생한다고 재시도 하면 두번 차감 될수 있다
그래서 재시도는 단순조회나 커탐아나 멱등성 가진 변뎡에만 가능 

재시도폭풍으로 연동서비스가 장애날수 있으니 연동서비스가 얼마나 버틸지 성능체크가 필요

트랜잭션 안에서 디비변경하고 외부서비스 호출했는데 에러나서 트랜잭션 롤백이 된다
하지만 리탐아가 발생해 롤백된다면 외부서비스가 성공했을수 있어서 주의해야한다
이럴땐 배치로 데이터 일치하는지 확인후 보정하거나 이후에 외부호출이 성공했는지 확인하는 api를 호출하고 성공하면 트랜잭션 지속하고 실패면 롤백
혹릉 취소api를 호출하고 롤백
그리고 이 api도 역시나 리탐아 가능
그래서 정기적으로 데이터 일치 확인하는 프로세스 필요 
또는 외부서비스는 성공했는데 디비가 실패할수 있는데 이때는 외부서비스 취소 api 호출해여하거나 정기적으로 데이터 일치와 보정 해야돼

트랜잭션안에 외부연동이 디비처리보다 훨씬오래 걸리면 커넥션 비효율 점유하게된다 
평소 5초 걸리는 트랜잭션에 커넥션풀이 5라고 했을때 rps가 1이라면 딱맞게 동작하나 만약 외부연동시간이 늘어 트랜잭션이 길어지면 커넥션 풀이 부족하다
디비트랜잭션 전후에 외부연동을 해버리면 디비커넥션 풀 문제가 해결된다 다만 트랜잭션이 묶여야한다면 보상트랜잭션이나 데이터후보정 해야할것이다

http커넥션풀도 디비커넥션풀만큼 중요하다
풀은 연동서비스 성능에따라 결정된다 커넥션대기시간도 1-5초가 적당하다 
커넥션 유지시간도 고려해야한다 keep alive도 고랴해서 그 시간보다 짧아야된다 

핵심 연동서비스 (결제같은) 를 이중화 해라

a서비스가 b서비스에 직접 요청할때 트래픽이 크면  성능저하가 있을수 있다
메시징시스템을 통해 비동기 처리한다면 b서비스가 적절히 처리하고 성능영향을 주지 않는다 
그리고 메시지시스템이 보관도 가능하다
그리고 확장도 좋다 c서비스가 생긴하면 메시지시스템에서 메시지 가져가면 끝이다 
pub/sub 구조

카프카가 레빗보다 좋은점은 수평확장이 유리하고 메시지유실이 없고 파티션단위로 순서보장하고 언제든지 소비자가 재처리할수 있다
소비자가 가져가는걸 풀방식
레빗은 유실될수있고 브로커가 직접 소비자에 주는 푸쉬방식
메시지유실되고 상관없는건 레디스pub/sub 추천한다 간단하고 적은 장비로 높은 성능 
트래픽 대량이면 카프카 
amqp나 stomp써야하면 래빗

디비트랜잭션 완료 후 메시지 전송하는거를 보면 메시지 연동이 어떻게든 실패될수 있다 
메시지 유실을 막기 위해 안전하게 디비에 저장하고 그뒤에 읽어 메시지전송하는것이다 이게 트랜잭션 아웃박스 패턴이다
건 트랜잭션 중에 아웃박스 테이블에 메시지를 저징후 메시지중계시스템이 반복적으로 메시지조회해서 메시지시스템에전송하고 완료되면 테이블에 완료 표기하는거다
아니면 2개이상의 메시지중계서비스가 아웃박스 테이블 함께 쓰면 성공한 아이디를 저장하고 관리하는것도 방법


잠금이 뮤텍스이다 
세마포어는 동시 실행 허용 스레드 수 정힌다 
읽기쓰기잠금으로 쓸때 읽거나 읽을때 쓸수 없지만 읽을때 여러개 동시에 읽을수 있다

잠금을 사용하여 값을 동시제어하면 성능이 떨어진다 원자적 atomic을 사용하면 해결된다
여러쓰레드가 동시에 변경해도 안전하다

db와 동시성
db 비관적잠금하면 락 걸린다 
레디스 분산락 쓰면 빠르다 좋다 추천
낙관적 락 하면 대기없어서 빠르다 
트랜잭션 중간에 외부 요청하면 비관적락을 써라 낙관적락을 쓰면 중간에 다른 트랜잭션으로 데이터 변경시 외부 요청은 성공했는데 디비는 롤백 될수 있다
낙관적 락 쓰려면 트랜잭션 아웃박스패턴을 적용해서 외부 연동 처리 한다 

동시에 카운터가 늘어나는 곳에 비관적잠금하면 원자 보장 되나 느려진다 
증분쿼리 set count = count + 1 쓰면 원자적 보정 
DB에 따라 원자적 연산 아닐수도 있다 DB 확인필요

p199
논블로킹io로 성능높이기

경량쓰레드도 한계가 온다 그때는 논블로킹io
입출력을 대기하지 않고 다음 수행한다
소수의 스레드로 
동시성위해 채널을 cpu갯수만큼 만들어 쓰레드 할당해서 처리
리액터=이벤트루프
p212

## 8. 보안

## 9.  서버관리
ls-l 로 확인하는 정보 구조 
파일권한_소유자_소유그룹_파일크기_마지막수정시간_파일명
rwx_rwx_rwx 
소유자_그룹_다른사용자
$ chmod 754 run.sh <- 전체권한_일기실행_읽기

프로세스ID 확인 : ps aux, ps -eaf 
프로세스 cpu, 메모리 사용량 : top, htop 

kill -15 pid (grace kill)
kill -9 pid (force kill)

tail -f access.log : 로그 보기 
nohup 명령어 & : 터미널 종료해도 백그라운드로 실행 

프로세스마다 파일디스크립터 개수 제한이 있을수 있다 
파일디스크립터는 데이터입출력이 필요할때 OS로 부터 할당받는것 
losf -p 프로세스ID : 디스크립터 갯수 

ifconfig : ip 정보 확인 
$ nc -z -v daum.net 433 : daum.net:433에 포트가 잘 연결되나 확인 
$ netstat -lputn : 열려있는 서버 포트 확인

## 10. 네트워크 기초

## 11. 서버구조와 설계패턴


#dev/book/주니어_백엔드_개발자가_반드시_알아야_할_실무_지식
