---
tags: [oop, design, first-class-collection]
---

# 일급 컬렉션

## 한 줄 요약

컬렉션을 감싸는 클래스를 만들어 컬렉션 관련 로직을 캡슐화하고, 불변성과 유효성 검증을 강제한다

## 핵심 정리

- 일급 컬렉션: 컬렉션을 Wrapping한 클래스
- 컬렉션에 대한 로직을 한 곳에서 관리
- 유효성 검증을 생성자에서 수행
- 불변성 보장: 새 인스턴스 반환, unmodifiableList 사용
- 외부에서 컬렉션 직접 변경 방지

## 상세 내용

### 일급 컬렉션이란?

컬렉션과 관련된 로직을 캡슐화한 클래스다.

**규칙:**
- 컬렉션을 인스턴스 변수로 가짐
- 컬렉션 외에 다른 인스턴스 변수는 없음

### 기본 구현

```java
class Party {
    private final List<Member> members;

    Party(List<Member> members) {
        this.members = new ArrayList<>(members);
    }

    void add(Member newMember) {
        List<Member> adding = new ArrayList<>(members);
        adding.add(newMember);
        return new Party(adding);  // 부수효과를 막기 위해 새로운 객체 리턴
    }

    List<Member> members() {
        return Collections.unmodifiableList(members);  // 외부에서 변경 못하게
    }
}
```

### 일급 컬렉션의 장점

#### 1. 비즈니스 로직의 캡슐화

```java
// ❌ 로직이 흩어짐
if (members.size() > 10) {
    throw new IllegalStateException("파티는 최대 10명까지 가능합니다");
}

// ✅ 일급 컬렉션에 캡슐화
class Party {
    private static final int MAX_SIZE = 10;
    private final List<Member> members;

    Party(List<Member> members) {
        if (members.size() > MAX_SIZE) {
            throw new IllegalStateException("파티는 최대 10명까지 가능합니다");
        }
        this.members = new ArrayList<>(members);
    }
}
```

#### 2. 불변성 보장

```java
class Party {
    private final List<Member> members;

    Party add(Member newMember) {
        List<Member> newMembers = new ArrayList<>(this.members);
        newMembers.add(newMember);
        return new Party(newMembers);  // 새 인스턴스 반환
    }

    List<Member> getMembers() {
        return Collections.unmodifiableList(members);  // 수정 불가능한 뷰 반환
    }
}
```

#### 3. 이름을 가진 컬렉션

```java
// ❌ 의미 불명확
List<Member> members = ...;

// ✅ 의미 명확
Party party = new Party(members);
```

#### 4. 중복 방지 로직

```java
class Party {
    private final List<Member> members;

    boolean hasDuplicateNames() {
        return members.stream()
            .map(Member::getName)
            .distinct()
            .count() != members.size();
    }
}
```

## 실무 적용

### Kotlin에서의 구현

```kotlin
class Party(
    members: List<Member>
) {
    private val _members: List<Member> = members.toList()  // 방어적 복사

    init {
        require(_members.size <= MAX_SIZE) { "파티는 최대 10명까지 가능합니다" }
    }

    fun add(newMember: Member): Party {
        return Party(_members + newMember)  // 새 인스턴스 반환
    }

    val members: List<Member>
        get() = _members.toList()  // 불변 리스트 반환

    companion object {
        private const val MAX_SIZE = 10
    }
}
```

### JPA Entity에서 활용

```java
@Entity
class Order {
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();

    // 직접 List를 노출하지 않고 일급 컬렉션 반환
    public OrderItems getOrderItems() {
        return new OrderItems(this.orderItems);
    }
}

class OrderItems {
    private final List<OrderItem> items;

    OrderItems(List<OrderItem> items) {
        this.items = new ArrayList<>(items);
    }

    public Money calculateTotalAmount() {
        return items.stream()
            .map(OrderItem::getAmount)
            .reduce(Money.ZERO, Money::add);
    }
}
```

### 주의사항

- 모든 컬렉션을 일급 컬렉션으로 만들 필요는 없음
- 비즈니스 로직이 있는 경우에만 적용
- 단순 DTO는 그냥 List 사용해도 무방

## 관련 노트

- [[4. 불변]]
- [[3.2 성숙한 클래스로 성장시키기]]
- [[5장. 응집도]]

#first-class-collection #oop #immutable