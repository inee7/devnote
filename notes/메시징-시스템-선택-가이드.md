---
tags: [메시징, 카프카, 래빗mq, 레디스, 비동기, 트랜잭션아웃박스패턴]
---

## 한 줄 요약

메시징 시스템은 트래픽 규모, 메시지 유실 허용 여부, 프로토콜 요구사항에 따라 카프카, 래빗MQ, 레디스 Pub/Sub 중에서 선택한다.

## 핵심 정리

- 동기 호출 대신 메시징 시스템을 사용하면 성능 저하 없이 확장 가능
- 카프카: 대용량 트래픽, 메시지 유실 방지, 수평 확장, 재처리 필요 시
- 래빗MQ: AMQP/STOMP 프로토콜 필요, 중소 규모 트래픽
- 레디스 Pub/Sub: 메시지 유실 허용 가능, 간단한 구성, 높은 성능
- 트랜잭션 아웃박스 패턴으로 메시지 유실 방지

## 상세 내용

### 비동기 메시징의 필요성

#### 동기 호출의 한계

**시나리오: A 서비스가 B 서비스에 직접 요청**

```kotlin
// A 서비스
fun processOrder(order: Order) {
    // B 서비스에 동기 호출
    bService.notifyOrder(order)  // 네트워크 대기
}
```

문제점:
- 트래픽이 크면 B 서비스가 부하로 인해 응답 지연
- A 서비스도 함께 느려짐 (성능 저하 전파)
- B 서비스가 다운되면 A 서비스도 실패

#### 메시징 시스템 도입

```kotlin
// A 서비스
fun processOrder(order: Order) {
    // 메시지 큐에 발행하고 즉시 리턴
    messageQueue.publish("order.created", order)
}

// B 서비스
@MessageListener("order.created")
fun handleOrder(order: Order) {
    // 자신의 속도에 맞춰 처리
}
```

장점:
- A 서비스는 메시지 발행 후 즉시 다음 작업 진행
- B 서비스가 느려도 A 서비스에 영향 없음
- 메시징 시스템이 메시지를 보관하므로 B가 일시적으로 다운되어도 복구 후 처리 가능

### 확장성 향상

**Pub/Sub 구조의 유연성**

```
A 서비스 → 메시지 발행
            ↓
      메시징 시스템
       ↙    ↓    ↘
   B 서비스  C 서비스  D 서비스
```

새로운 서비스(C, D) 추가 시:
- A 서비스 코드 변경 불필요
- C, D가 메시징 시스템에서 메시지 구독만 추가
- 느슨한 결합으로 확장성 극대화

### 메시징 시스템 비교

#### 카프카 (Apache Kafka)

**특징**
- Pull 방식: 소비자가 메시지를 직접 가져감
- 메시지 유실 없음 (디스크에 영구 저장)
- 파티션 단위로 순서 보장
- 소비자가 언제든지 메시지 재처리 가능
- 수평 확장 유리 (파티션 추가)

**장점**
- 대용량 트래픽 처리에 최적화
- 메시지를 오래 보관 가능 (설정에 따라 수일~수개월)
- 소비자가 특정 시점부터 재처리 가능 (오프셋 조정)
- 높은 처리량

**단점**
- 운영 복잡도 높음 (주키퍼 필요, 최신 버전은 KRaft)
- 초기 설정과 학습 비용

**적합한 경우**
- 대량의 트래픽 (초당 수천~수만 메시지)
- 메시지 유실이 절대 안 되는 경우 (금융, 주문)
- 메시지 재처리가 필요한 경우
- 이벤트 소싱, CDC(Change Data Capture) 등

```kotlin
// 카프카 프로듀서
kafkaTemplate.send("order-events", order)

// 카프카 컨슈머
@KafkaListener(topics = ["order-events"], groupId = "order-processor")
fun consume(order: Order) {
    // 처리 실패 시 오프셋 커밋 안 하면 재처리됨
}
```

#### 래빗MQ (RabbitMQ)

**특징**
- Push 방식: 브로커가 소비자에게 메시지 전달
- AMQP, STOMP 등 다양한 프로토콜 지원
- 복잡한 라우팅 규칙 지원 (Exchange, Binding)
- 메시지 유실 가능 (설정에 따라 방지 가능)

**장점**
- 유연한 라우팅 (Direct, Topic, Fanout, Headers Exchange)
- AMQP 프로토콜이 필요한 경우 필수
- 중소 규모 트래픽에 적합

**단점**
- 대량 트래픽 처리는 카프카보다 불리
- 메시지 재처리가 카프카만큼 유연하지 않음

**적합한 경우**
- AMQP, STOMP 등 특정 프로토콜 필요
- 복잡한 라우팅 규칙 필요
- 중소 규모 트래픽

```kotlin
// 래빗MQ 발행
rabbitTemplate.convertAndSend("order-exchange", "order.created", order)

// 래빗MQ 소비
@RabbitListener(queues = ["order-queue"])
fun handleOrder(order: Order) {
    // 처리
}
```

#### 레디스 Pub/Sub

**특징**
- In-Memory 기반
- 메시지 유실 가능 (브로커가 메시지 보관 안 함)
- 소비자가 없으면 메시지 사라짐
- 매우 빠른 성능

**장점**
- 간단한 구성 (레디스만 있으면 됨)
- 적은 장비로 높은 성능
- 운영 부담 최소

**단점**
- 메시지 유실 가능
- 메시지 영구 저장 안 됨
- 재처리 불가

**적합한 경우**
- 메시지 유실이 허용되는 경우 (실시간 알림, 채팅)
- 빠른 전파가 중요한 경우
- 간단한 Pub/Sub 구조

```kotlin
// 레디스 발행
redisTemplate.convertAndSend("order-channel", order)

// 레디스 구독
@RedisMessageListener
fun handleMessage(message: String, channel: String) {
    // 처리
}
```

### 선택 가이드

| 요구사항 | 추천 시스템 |
|---------|-----------|
| 대량 트래픽 (수천~수만 TPS) | 카프카 |
| 메시지 유실 절대 안 됨 | 카프카 |
| 메시지 재처리 필요 | 카프카 |
| AMQP/STOMP 프로토콜 필요 | 래빗MQ |
| 메시지 유실 허용 + 간단한 구성 | 레디스 Pub/Sub |
| 적은 장비로 높은 성능 | 레디스 Pub/Sub |

### 트랜잭션 아웃박스 패턴

#### 문제: 메시지 유실 방지

**시나리오**

```kotlin
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)  // DB 저장 성공

    messageQueue.publish("order.created", order)  // 메시지 발행 실패
    // → DB에는 저장되었으나 메시지는 전송 안 됨
}
```

DB 커밋은 성공했으나 메시지 발행이 실패하면:
- 다른 서비스는 주문 생성을 모름
- 데이터 정합성 깨짐

#### 해결: 트랜잭션 아웃박스 패턴

**원리**
1. DB 트랜잭션 내에서 메시지를 아웃박스 테이블에 저장
2. 별도의 메시지 중계 시스템이 아웃박스 테이블을 폴링
3. 메시지를 메시징 시스템에 전송
4. 전송 성공하면 아웃박스 테이블에 완료 표시

**구현 예시**

```kotlin
// 1. 아웃박스 테이블
@Entity
class OutboxMessage(
    @Id @GeneratedValue
    val id: Long = 0,
    val topic: String,
    val payload: String,
    val published: Boolean = false,
    val createdAt: LocalDateTime = LocalDateTime.now()
)

// 2. 트랜잭션 내에서 아웃박스에 저장
@Transactional
fun processOrder(order: Order) {
    orderRepository.save(order)

    // 메시지를 아웃박스 테이블에 저장 (같은 트랜잭션)
    outboxRepository.save(
        OutboxMessage(
            topic = "order.created",
            payload = objectMapper.writeValueAsString(order)
        )
    )
    // DB 커밋 → 주문과 메시지가 원자적으로 저장됨
}

// 3. 메시지 중계 시스템 (별도 스레드/프로세스)
@Scheduled(fixedDelay = 1000)
fun relayMessages() {
    val messages = outboxRepository.findByPublishedFalse()

    messages.forEach { message ->
        try {
            // 메시징 시스템에 발행
            kafkaTemplate.send(message.topic, message.payload)

            // 성공하면 완료 표시
            message.published = true
            outboxRepository.save(message)
        } catch (e: Exception) {
            // 실패하면 다음 폴링 때 재시도
            logger.error("Failed to publish message ${message.id}", e)
        }
    }
}
```

#### 다중 중계 서비스 구성

**문제: 중계 서비스가 1대면 단일 장애점**

해결: 여러 중계 서비스가 동시에 폴링

```kotlin
@Scheduled(fixedDelay = 1000)
fun relayMessages() {
    // 처리한 메시지 ID를 Redis에 저장하여 중복 방지
    val messages = outboxRepository.findByPublishedFalse()

    messages.forEach { message ->
        val lockKey = "outbox-lock:${message.id}"
        val acquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "locked", 10, TimeUnit.SECONDS)

        if (acquired == true) {
            try {
                kafkaTemplate.send(message.topic, message.payload)
                message.published = true
                outboxRepository.save(message)
            } finally {
                redisTemplate.delete(lockKey)
            }
        }
    }
}
```

분산 락으로 여러 중계 서비스가 같은 메시지를 중복 처리하지 않도록 방지

## 실무 적용

### 메시징 시스템 도입 체크리스트

1. **트래픽 규모 확인**
   - 초당 메시지 수가 얼마나 되는가?
   - 향후 증가 예상은?

2. **메시지 유실 허용 여부**
   - 유실되면 안 되는가? → 카프카
   - 유실 허용 가능한가? → 레디스

3. **재처리 필요 여부**
   - 과거 메시지 재처리 필요? → 카프카
   - 실시간만 필요? → 래빗MQ, 레디스

4. **프로토콜 요구사항**
   - AMQP/STOMP 필요? → 래빗MQ

5. **운영 역량**
   - 카프카 운영 가능한가?
   - 간단한 시스템 선호? → 레디스

### 금융권에서의 고려사항

- 주문, 결제 등 핵심 이벤트는 카프카 사용 (유실 방지)
- 트랜잭션 아웃박스 패턴 필수 적용
- 메시지 발행과 소비 모두 로깅
- 메시지 재처리 시나리오 사전 검증
- 소비자의 멱등성 보장 (중복 메시지 대비)

---

**출처**
- 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식 (최범균)
