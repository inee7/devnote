---
tags: [kotlin, lambda, function-literal, anonymous-function, function-reference, functional-programming]
---
# 리터럴 함수 (Function Literal)

## 한 줄 요약

리터럴 함수는 함수를 값처럼 직접 작성하여 변수에 할당하거나 인자로 전달할 수 있게 하는 표현 방식으로, Kotlin에서는 람다식, 익명 함수, 함수 참조 세 가지 형태가 있다.

## 핵심 정리

- **리터럴 함수**: 함수를 값으로 표현하는 방법 (숫자 리터럴 `42`, 문자열 리터럴 `"hello"`처럼)
- **세 가지 형태**: 람다식 `{ x -> x * 2 }`, 익명 함수 `fun(x: Int) = x * 2`, 함수 참조 `::doubleValue`
- **람다식**: 가장 간결한 형태, 마지막 표현식이 자동으로 반환값
- **익명 함수**: 명시적 반환 타입과 일반 함수 문법 사용
- **함수 참조**: 기존 함수를 리터럴처럼 참조 (`::functionName`)
- **함수 타입**: `(Int, Int) -> Int` 형태로 함수의 시그니처 표현

## 상세 내용

### 리터럴 함수의 개념

**리터럴(Literal)이란?**
- 코드에 직접 작성한 값
- 예: `42` (정수 리터럴), `"hello"` (문자열 리터럴), `true` (불리언 리터럴)

**리터럴 함수**
- 함수를 값처럼 직접 작성하는 표현
- 함수를 변수에 할당하거나 다른 함수의 인자로 전달 가능
- 일급 객체(First-Class Citizen)로서의 함수

### 함수 타입 (Function Type)

함수를 값으로 다루려면 먼저 함수의 타입을 이해해야 한다.

**기본 형태**
```kotlin
// (파라미터 타입들) -> 반환 타입
(Int, Int) -> Int           // 두 Int를 받아 Int 반환
(String) -> Unit            // String을 받아 반환값 없음
() -> Boolean               // 파라미터 없이 Boolean 반환
(Int) -> (Int) -> Int       // 함수를 반환하는 함수
```

**변수에 함수 타입 선언**
```kotlin
val sum: (Int, Int) -> Int = { a, b -> a + b }
val greet: (String) -> Unit = { name -> println("Hello, $name") }
val isPositive: (Int) -> Boolean = { it > 0 }
```

### 1. 람다식 (Lambda Expression)

가장 간결하고 많이 사용되는 리터럴 함수 형태다.

**기본 문법**
```kotlin
// 완전한 형태
val sum = { x: Int, y: Int -> x + y }

// 타입 추론 활용
val multiply: (Int, Int) -> Int = { x, y -> x * y }

// 파라미터가 하나면 it 사용 가능
val double: (Int) -> Int = { it * 2 }

// 파라미터가 없는 경우
val greeting = { println("Hello!") }
```

**특징**
- 중괄호 `{}` 사용
- 파라미터와 본문을 화살표 `->` 로 구분
- 마지막 표현식이 자동으로 반환값 (명시적 return 없음)
- 파라미터가 하나면 `it` 사용 가능

**컬렉션과 함께 사용**
```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// filter: 조건에 맞는 요소만 선택
val evens = numbers.filter { it % 2 == 0 }  // [2, 4]

// map: 각 요소를 변환
val doubled = numbers.map { it * 2 }  // [2, 4, 6, 8, 10]

// reduce: 요소들을 하나로 축약
val sum = numbers.reduce { acc, n -> acc + n }  // 15
```

### 2. 익명 함수 (Anonymous Function)

일반 함수 문법을 사용하되 이름이 없는 형태다.

**기본 문법**
```kotlin
// 표현식 본문
val sum = fun(x: Int, y: Int): Int = x + y

// 블록 본문
val multiply = fun(x: Int, y: Int): Int {
    println("Multiplying $x and $y")
    return x * y
}

// 반환 타입 추론 가능
val double = fun(x: Int) = x * 2
```

**람다와의 차이점**

| 특징 | 람다식 | 익명 함수 |
|------|--------|----------|
| 문법 | `{ x -> x * 2 }` | `fun(x: Int) = x * 2` |
| 반환 | 마지막 표현식 | 명시적 `return` |
| 타입 추론 | 맥락에서 추론 | 파라미터 타입 필수 |
| return | non-local return | local return |

**return 동작 차이**
```kotlin
// 람다: non-local return (외부 함수에서 반환)
fun processLambda() {
    listOf(1, 2, 3).forEach {
        if (it == 2) return  // processLambda() 자체를 종료
        println(it)
    }
    println("Done")  // 실행되지 않음
}

// 익명 함수: local return (익명 함수만 종료)
fun processAnonymous() {
    listOf(1, 2, 3).forEach(fun(value) {
        if (value == 2) return  // forEach만 종료
        println(value)
    })
    println("Done")  // 실행됨
}
```

### 3. 함수 참조 (Function Reference)

기존에 정의된 함수를 리터럴처럼 참조한다.

**종류**

```kotlin
// 1. 최상위 함수 참조
fun isEven(n: Int) = n % 2 == 0

val predicate: (Int) -> Boolean = ::isEven
listOf(1, 2, 3, 4).filter(::isEven)  // [2, 4]

// 2. 멤버 함수 참조
class Calculator {
    fun add(a: Int, b: Int) = a + b
}

val calc = Calculator()
val operation: (Int, Int) -> Int = calc::add

// 3. 확장 함수 참조
fun String.isLong() = length > 5

val check: (String) -> Boolean = String::isLong

// 4. 생성자 참조
data class Person(val name: String, val age: Int)

val personCreator: (String, Int) -> Person = ::Person
val people = listOf("Alice" to 25, "Bob" to 30)
    .map { (name, age) -> personCreator(name, age) }
```

**장점**
- 이미 정의된 함수를 재사용
- 코드 중복 방지
- 가독성 향상

### 세 가지 형태 비교

```kotlin
// 같은 기능을 세 가지 방법으로 표현

// 1. 람다식 (가장 간결)
val double1: (Int) -> Int = { it * 2 }

// 2. 익명 함수 (명시적 타입, 일반 함수 문법)
val double2 = fun(x: Int): Int = x * 2

// 3. 함수 참조 (기존 함수 재사용)
fun doubleValue(x: Int) = x * 2
val double3: (Int) -> Int = ::doubleValue

// 모두 같은 방식으로 사용
println(double1(5))  // 10
println(double2(5))  // 10
println(double3(5))  // 10
```

## 실무 적용

### 1. 고차 함수와 함께 사용

```kotlin
// 고차 함수 정의
fun <T, R> List<T>.customMap(transform: (T) -> R): List<R> {
    val result = mutableListOf<R>()
    for (item in this) {
        result.add(transform(item))
    }
    return result
}

// 리터럴 함수로 호출
val numbers = listOf(1, 2, 3, 4, 5)

// 람다 사용
val squared = numbers.customMap { it * it }

// 익명 함수 사용
val incremented = numbers.customMap(fun(x: Int) = x + 1)

// 함수 참조 사용
fun triple(x: Int) = x * 3
val tripled = numbers.customMap(::triple)
```

### 2. 컬렉션 처리

```kotlin
data class Order(
    val id: Long,
    val customerId: Long,
    val amount: Money,
    val status: OrderStatus
)

val orders = listOf(/* ... */)

// 람다로 복잡한 쿼리 간결하게 표현
val totalPaidAmount = orders
    .filter { it.status == OrderStatus.PAID }
    .map { it.amount }
    .reduce { acc, amount -> acc + amount }

// 조건부 그룹핑
val ordersByCustomer = orders
    .groupBy { it.customerId }
    .mapValues { (_, orders) -> orders.sumOf { it.amount.value } }

// 정렬
val sortedOrders = orders.sortedByDescending { it.amount.value }
```

### 3. DSL 스타일 코드

```kotlin
// HTML DSL 예시
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}

// 리터럴 함수로 구조 정의
val page = html {
    head {
        title { +"Hello Kotlin" }
    }
    body {
        h1 { +"Welcome" }
        p { +"This is a paragraph" }
    }
}
```

### 4. 비동기 처리 콜백

```kotlin
// Callback 패턴
interface ApiCallback<T> {
    fun onSuccess(data: T)
    fun onError(error: Throwable)
}

// 람다로 간결하게 표현
fun fetchUser(
    userId: Long,
    onSuccess: (User) -> Unit,
    onError: (Throwable) -> Unit
) {
    // API 호출
}

// 사용
fetchUser(
    userId = 123,
    onSuccess = { user -> println("User: ${user.name}") },
    onError = { error -> println("Error: ${error.message}") }
)
```

### 5. 전략 패턴 대체

```kotlin
// 전통적인 전략 패턴 대신 리터럴 함수 사용
class PaymentProcessor(
    private val feeCalculator: (Money) -> Money
) {
    fun process(amount: Money): Money {
        val fee = feeCalculator(amount)
        return amount + fee
    }
}

// 다양한 수수료 전략을 리터럴 함수로 정의
val standardFee: (Money) -> Money = { it * 0.03 }
val premiumFee: (Money) -> Money = { it * 0.01 }
val noFee: (Money) -> Money = { Money(0) }

// 런타임에 전략 선택
val processor = PaymentProcessor(
    if (user.isPremium) premiumFee else standardFee
)
```

## 금융권에서의 고려사항

- **가독성 우선**: 복잡한 비즈니스 로직은 람다보다 명명된 함수 사용
- **테스트 용이성**: 재사용되는 로직은 함수 참조로 추출하여 단위 테스트
- **디버깅**: 스택 트레이스에서 람다는 `invoke` 로 표시되어 추적 어려움
- **성능**: 금융 계산 핫패스에서는 inline 함수와 함께 사용
- **코드 리뷰**: 람다 중첩이 3단계 이상이면 명명된 함수로 분리 권장

## 관련 노트

- [[코틀린-고차함수]]
- [[코틀린-람다와-컬렉션]]
- [[코틀린-함수와-확장]]
- [[리시버-명시적-참조]]

---

**출처**
- Kotlin in Action (Dmitry Jemerov, Svetlana Isakova)
