---
tags: [kotlin, scope, effective-kotlin, best-practices]
---

## 한 줄 요약

변수의 스코프를 최대한 좁게 유지하고, 정의와 동시에 초기화하며, 구조분해를 활용하면 코드의 안전성과 가독성이 향상된다.

## 핵심 정리

**스코프 최소화 원칙**
- 변수는 최대한 좁은 스코프에서 정의
- 변수 정의와 동시에 초기화
- 구조분해를 적극 활용
- 람다에서의 변수 캡처링 주의

**좋은 패턴**
- for문에서 인덱스 변수는 루프 내부에서만 정의
- if-else는 표현식으로 사용하여 즉시 초기화
- withIndex()나 구조분해로 임시 변수 제거

## 상세 내용

### 스코프를 최소화해야 하는 이유

**1. 가독성 향상**

스코프가 넓으면 변수가 어디서 사용되는지 파악하기 어렵다.

```kotlin
// ❌ 스코프가 넓음
var user: User
val hasValue = checkValue()
if (hasValue) {
    user = getUser()
} else {
    user = getDefaultUser()
}
processUser(user)

// ✅ 스코프를 좁힘
val hasValue = checkValue()
val user = if (hasValue) getUser() else getDefaultUser()
processUser(user)
```

**2. 의도치 않은 재사용 방지**

```kotlin
// ❌ 변수 재사용
var result: String
result = calculateFirstResult()
println(result)
result = calculateSecondResult()  // 실수로 같은 변수 사용
println(result)

// ✅ 각각의 스코프에서 정의
val firstResult = calculateFirstResult()
println(firstResult)
val secondResult = calculateSecondResult()
println(secondResult)
```

**3. 메모리 효율**

스코프가 좁으면 더 빨리 가비지 컬렉션 대상이 된다.

### for문에서의 스코프 최소화

**나쁜 예: 루프 밖에서 변수 정의**

```kotlin
class User(val name: String)

fun bad() {
    val users: List<User> = listOf(User("Alice"), User("Bob"))

    var user: User  // 루프 밖에서 정의
    for (i in users.indices) {
        user = users[i]
        println("User at $i is $user")
    }
    // user가 여전히 스코프에 남아있음
}
```

문제점:
- `user` 변수가 루프 밖에서도 접근 가능
- 실수로 루프 밖에서 사용할 위험
- 루프가 끝나도 메모리에 남아있음

**조금 더 좋은 예: 루프 안에서 정의**

```kotlin
fun better() {
    val users: List<User> = listOf(User("Alice"), User("Bob"))

    for (i in users.indices) {
        val user = users[i]  // 루프 안에서 정의
        println("User at $i is $user")
    }
    // user는 루프 밖에서 접근 불가
}
```

**가장 좋은 예: 구조분해 활용**

```kotlin
fun best() {
    val users: List<User> = listOf(User("Alice"), User("Bob"))

    for ((i, user) in users.withIndex()) {
        println("User at $i is $user")
    }
}
```

장점:
- 임시 변수 없음
- 인덱스와 요소를 동시에 추출
- 가독성이 가장 좋음

### 변수 정의와 동시에 초기화

**나쁜 예: 정의 후 초기화**

```kotlin
fun bad(hasValue: Boolean) {
    val user: User  // 선언만
    if (hasValue) {
        user = getUser()  // 나중에 초기화
    } else {
        user = getDefaultUser()
    }
    processUser(user)
}

fun getUser() = User("Real")
fun getDefaultUser() = User("Default")
fun processUser(user: User) = println(user.name)
```

문제점:
- 초기화되지 않은 상태로 존재하는 구간이 있음
- 실수로 초기화를 빼먹을 위험

**좋은 예: if를 표현식으로 사용**

```kotlin
fun good(hasValue: Boolean) {
    val user: User = if (hasValue) {
        getUser()
    } else {
        getDefaultUser()
    }
    processUser(user)
}
```

Kotlin의 if, when, try는 표현식이므로 값을 반환할 수 있다.

```kotlin
// when 표현식
val result = when (type) {
    Type.A -> processA()
    Type.B -> processB()
    else -> processDefault()
}

// try 표현식
val value = try {
    parseValue()
} catch (e: Exception) {
    defaultValue
}
```

### 구조분해를 활용한 스코프 최소화

**map 순회**

```kotlin
// ❌ 나쁜 예
val map = mapOf("a" to 1, "b" to 2)
var key: String
var value: Int
for (entry in map.entries) {
    key = entry.key
    value = entry.value
    println("$key = $value")
}

// ✅ 좋은 예
val map = mapOf("a" to 1, "b" to 2)
for ((key, value) in map) {
    println("$key = $value")
}
```

**데이터 클래스 구조분해**

```kotlin
data class Point(val x: Int, val y: Int)

// ❌ 나쁜 예
val point = Point(10, 20)
val x = point.x
val y = point.y
println("($x, $y)")

// ✅ 좋은 예
val point = Point(10, 20)
val (x, y) = point
println("($x, $y)")
```

**필요한 값만 추출**

```kotlin
data class User(val id: Long, val name: String, val email: String)

// 필요한 값만 추출
val user = getUser()
val (id, name) = user  // email은 무시
println("$id: $name")

// 사용하지 않는 값은 _로 무시
val (_, name, _) = user
println(name)
```

### 람다에서의 캡처링 주의

스코프가 넓으면 람다에서 예기치 않은 변수를 캡처할 수 있다.

```kotlin
// ❌ 의도치 않은 캡처
var counter = 0
val increments = (1..5).map {
    counter++  // 외부 변수 캡처 및 변경
    counter
}
println(increments)  // [1, 2, 3, 4, 5]
println(counter)     // 5 (변경됨)

// ✅ 각 스코프에서 정의
val increments = (1..5).map { value ->
    value  // 외부 상태에 의존하지 않음
}
println(increments)  // [1, 2, 3, 4, 5]
```

## 실무 적용

### 메서드 추출로 스코프 제한

```kotlin
// ❌ 긴 메서드에서 많은 변수 사용
fun processOrder(orderId: Long) {
    val order = orderRepository.findById(orderId)
    val customer = customerRepository.findById(order.customerId)
    val product = productRepository.findById(order.productId)

    // 중간에 복잡한 로직...

    val discount = calculateDiscount(customer, product)
    val totalAmount = order.amount - discount

    // 더 많은 로직...

    saveOrder(order, totalAmount)
}

// ✅ 메서드 추출로 스코프 제한
fun processOrder(orderId: Long) {
    val order = orderRepository.findById(orderId)
    val totalAmount = calculateTotalAmount(order)
    saveOrder(order, totalAmount)
}

private fun calculateTotalAmount(order: Order): Long {
    val customer = customerRepository.findById(order.customerId)
    val product = productRepository.findById(order.productId)
    val discount = calculateDiscount(customer, product)
    return order.amount - discount
}
```

### let/run/also 활용

```kotlin
// ✅ let으로 스코프 제한
val user = getUser()
user?.let { validUser ->
    processUser(validUser)
    sendEmail(validUser.email)
}

// ✅ run으로 복잡한 초기화
val config = readConfig().run {
    validate()  // this는 readConfig() 결과
    applyDefaults()
    this
}
```

## 금융권에서의 고려사항

**거래 처리 로직**
- 거래 단계별로 변수 스코프를 명확히 구분
- 중간 결과는 메서드 추출로 스코프 제한
- 감사 로그에서 변수 추적 용이

**에러 처리**
- try-catch 블록에서 예외 변수 스코프 최소화
- 예외 핸들링 후 불필요한 변수가 남지 않도록

```kotlin
fun processTransaction(request: TransactionRequest): TransactionResult {
    // 검증 단계의 변수는 이 블록에서만
    validate(request)

    // 실행 단계의 변수는 이 블록에서만
    val result = executeTransaction(request)

    // 로깅 단계의 변수는 이 블록에서만
    logTransaction(result)

    return result
}
```

---

**출처**
- Effective Kotlin (마르친 모스칼라)


