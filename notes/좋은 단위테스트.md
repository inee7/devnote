---
tags: [testing, unit-test, first-principles]
---
# **🧪 좋은 단위 테스트의 5대 원칙 (F.I.R.S.T)**

이 문서는 [[테스트의 종류]] 중 단위 테스트를 잘 작성하기 위한 F.I.R.S.T 원칙을 다룹니다.
단위 테스트의 '단위'는 **코드 단위(unit of code)가 아닌 행동 단위(unit of behavior)**여야 한다. 
그 외 단위 테스트(Unit Test)가 진짜 “좋은 테스트”가 되려면 다음 다섯 가지 원칙을 만족해야 한다.

> 좋은 단위 테스트는
> 빠르고(**FAST**), 독립적이며(**ISOLATED**),
> 항상 같은 결과(**REPEATABLE**)를 내고,
> 스스로 판정(**SELF-VALIDATING**)하며,
> 코드와 함께 작성(**TIMELY**)된다.

---
## **1️⃣ FAST — 빠르고 (Fast)**

  ### **💡 의미**

테스트는 **항상 빠르게 실행되어야 한다.**
1초 안에 돌 수 있는 테스트라야 개발자가 수시로 실행하면서 리팩토링을 반복할 수 있다.

### **⚙️ 이유**
- 느린 테스트는 개발 루프(코드 → 실행 → 확인)를 방해한다.
- 속도가 느려지면 “테스트 무시 → 테스트 부패”로 이어진다.

### **✅ 좋은 예**
```kotlin
@Test
fun `할인율 계산`() {
    val price = PriceCalculator().calculate(10000, 0.1)
    assertThat(price).isEqualTo(9000)
}
```

### **❌ 나쁜 예**
```kotlin
@Test
fun `할인율 계산`() {
    val result = PriceService(realDatabaseConnection).calculateDiscount("user123")
    assertThat(result).isEqualTo(9000)
}
```

> 속도에 대한 자세한 내용은 [[좋은 테스트코드가 되기 위한 조건]]의 '빠른 피드백' 원칙도 참고하세요.

---
## **2️⃣ ISOLATED — 고립되어 (Isolated)**

  ### **💡 의미**
각 테스트는 **서로 독립적으로 동작**해야 하며,
외부 환경(DB, 파일, 네트워크)에 의존하지 않아야 한다.

### **⚙️ 이유**
- 테스트 순서가 바뀌어도 결과가 같아야 한다.
- 다른 테스트의 상태(데이터, 캐시, 전역 변수)에 영향을 받으면 안 된다.

### **✅ 좋은 예**
```kotlin
@Test
fun `쿠폰 할인 적용`() {
    val sut = DiscountPolicy()
    val result = sut.applyCoupon(10000, 0.1)
    assertThat(result).isEqualTo(9000)
}
```
### **❌ 나쁜 예**
```kotlin
@Test
fun `이전 테스트에서 저장된 사용자 데이터 활용`() {
    val user = database.findLastInsertedUser()  // 의존
    val result = service.giveReward(user)
    assertThat(result.point).isEqualTo(100)
}
```
> 이전 테스트의 결과에 의존하면 고립성이 깨진다. DB 접근, 네트워크, 파일 I/O 등은 [[테스트더블]]을 이용해 제거해야 한다.

---
## **3️⃣ REPEATABLE — 반복 가능하고 (Repeatable)**

### **💡 의미**
테스트는 **언제 어디서 돌려도 항상 같은 결과**를 내야 한다.
(환경, 순서, 시간, 랜덤값, 네트워크에 영향을 받지 않아야 함)

### **⚙️ 이유**
- “가끔 실패하는 테스트(Flaky Test)”는 가장 위험하다.    
- 신뢰할 수 없으면 아무도 테스트를 믿지 않게 된다.

### **✅ 좋은 예**
```kotlin
@Test
fun `세금 계산`() {
    val result = TaxCalculator().calculate(10000)
    assertThat(result).isEqualTo(1000)
}
```
### **❌ 나쁜 예**
```kotlin
@Test
fun `현재 시각 기준으로 포인트 만료`() {
    val now = LocalDateTime.now()
    val result = service.expirePoint(now)
    assertThat(result).isTrue() // 매번 다름
}
```
> now() 사용으로 결과가 실행 시점마다 달라짐.
> Clock 주입(테스트용 고정 시각)으로 해결해야 한다.

---
## **4️⃣ SELF-VALIDATING — 결과가 자동 검증되어야 (Self-Validating)**

### **💡 의미**

테스트는 **사람이 로그를 눈으로 확인하지 않아도**,
스스로 결과를 판정해야 한다.
즉, “pass / fail”이 자동으로 판정되어야 한다.

### **⚙️ 이유**
- 수동 확인이 필요하면 CI/CD에서 자동 검증 불가.
- 테스트의 본질은 “결과가 자동으로 옳은지 증명”하는 것.

### **✅ 좋은 예**
```kotlin
@Test
fun `포인트 적립`() {
    val point = service.addPoint(100)
    assertThat(point.balance).isEqualTo(100)
}
```

### **❌ 나쁜 예**
```kotlin
@Test
fun `포인트 적립`() {
    val point = service.addPoint(100)
    println(point.balance)  // 눈으로 확인해야 함 ❌
}
```

---
## **5️⃣ TIMELY — 코드 작성 직후 바로 작성되어야 (Timely)**

### **💡 의미**
테스트는 기능 구현 “후에” 쓰는 게 아니라,
**기능 작성과 함께(또는 그 전에)** 만들어야 한다.

### **⚙️ 이유**
- 늦게 쓰면 로직을 잊고 커버리지가 줄어든다.
- “테스트 가능한 구조”로 코드를 설계하게 해준다. (TDD 핵심 효과)
  
### **✅ 좋은 흐름**
1. 실패하는 테스트 작성
2. 최소한의 코드로 통과
3. 리팩토링

### **❌ 나쁜 흐름**
- 기능 다 만든 뒤, 테스트 “형식상 추가” → 결함 못 잡고 시간 낭비.

---
## **📋 정리 요약표**

| **원칙**              | **의미**                  | **나쁜 경우**         |
| ------------------- | ----------------------- | ----------------- |
| **FAST**            | 테스트는 빠르게 실행되어야 한다       | DB, 네트워크 접근 포함    |
| **ISOLATED**        | 다른 테스트나 환경에 의존하지 않아야 한다 | 순서 의존, 공유 데이터     |
| **REPEATABLE**      | 항상 같은 결과를 내야 한다         | now(), 랜덤값 의존     |
| **SELF-VALIDATING** | 사람이 아닌 코드가 결과를 검증해야 한다  | println, 로그 확인 필요 |
| **TIMELY**          | 코드 작성 시점에 함께 만들어야 한다    | 기능 후 작성, 커버리지 부족  |


이 다섯 가지를 지키면
테스트는 단순한 “기능 검증용 코드”가 아니라,
**“안전하게 리팩토링할 수 있는 품질 자산”**이 된다.


## 관련 노트
- [[테스트의 종류]]
- [[좋은 테스트코드가 되기 위한 조건]]
- [[단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실]]

#testcode #테스트코드 