---
tags: [design-pattern, kotlin, behavioral]
---

# 전략 패턴

## 한 줄 요약

런타임에 알고리즘을 교체하여 사용할 수 있도록 하는 패턴

## 핵심 정리

- 런타임에 알고리즘을 바꾸어 사용하는 패턴
- 상태를 가지지 않는 알고리즘이라면 함수로 표현 가능
- 자바에서는 인터페이스와 구현 클래스를 작성해야 하지만, 코틀린에서는 함수를 이용해 클래스 작성 없이 알고리즘을 만들 수 있음

## 상세 내용

### 코틀린에서의 전략 패턴

자바에서는 전략 패턴을 쓰면 인터페이스를 정의하고 모든 구현 클래스를 작성해야 해서 클래스가 많아진다. 코틀린에서는 자바와 다르게 일급 객체인 함수를 활용할 수 있다. 이 점을 이용해 함수를 이용해 클래스 작성 없이 알고리즘을 만들 수 있어 장점이다.

### 구현 예제

```kotlin
// Weapons라는 네임스페이스를 두기 위해 object로 감쌌다
object Weapons {
    // Flies straight
    fun peashooter(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a peashooter")
        return Projectile(x, y, direction)
    }

    // Returns back after reaching end of the screen
    fun banana(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a banana")
        return Projectile(x, y, direction)
    }

    // Explodes on contact
    fun pomegranate(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a pomegranate")
        return Projectile(x, y, direction)
    }
}

class OurHero {
    private var direction = Direction.LEFT
    private var x: Int = 42
    private var y: Int = 173

    var currentWeapon = Weapons::peashooter // 알고리즘 변경

    val shoot = fun() {
        currentWeapon(x, y, direction)
    } // 함수를 프로퍼티로 가지며 위임한다

}

fun main() {
    val hero = OurHero()
    hero.shoot()
    hero.currentWeapon = Weapons::banana
    hero.shoot()
}
```

### 특징

- 함수 참조를 사용하여 전략을 교체
- 네임스페이스 역할을 위해 object 활용
- 프로퍼티로 함수를 가지고 위임하는 방식

## 관련 노트

- [[디자인패턴-상태]] - 상태에 따라 행위가 변경 (전략은 알고리즘 선택)
- [[디자인패턴-템플릿-메서드]] - 상속 기반 (전략은 위임 기반)

---

**출처**
- 코틀린 디자인 패턴
