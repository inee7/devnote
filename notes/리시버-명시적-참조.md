---
tags: [kotlin, scope-function, receiver, effective-kotlin, best-practices]
---

## 한 줄 요약

apply/with 같은 리시버 기반 스코프 함수에서는 암묵적 리시버(this) 대신 명시적 리시버를 사용하거나, also/let으로 대체하여 코드의 명확성을 높여야 한다.

## 핵심 정리

**리시버 참조 문제**
- apply/with는 암묵적 리시버(this)를 사용해 혼란 가능
- 중첩된 스코프에서 어떤 리시버를 참조하는지 불명확
- nullable 타입 처리 시 더욱 혼란스러움

**해결 방법**
- also/let 사용: 명시적 파라미터(it) 강제
- this 명시적 참조: this?, this@ClassName
- 레이블 사용: this@apply, this@OuterClass

**권장 사항**
- nullable 처리는 also/let 선호
- apply 사용 시 리시버를 명시적으로 참조
- 중첩 스코프는 가능한 피하기

## 상세 내용

### 암묵적 리시버의 문제

**문제 상황**

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName")
            .apply { print("Created ${name}") }

    fun create(name: String): Node? = Node(name)
}

fun main() {
    val node = Node("parent")
    node.makeChild("child")  // "Created parent" 출력
}
```

문제점:
- `apply` 블록 안의 `name`은 어떤 객체의 name인가?
- 의도: apply 리시버(새로 생성된 Node)의 name
- 실제: 외부 클래스(Node)의 name을 참조

**왜 이런 일이 발생하는가?**

`apply`는 리시버 객체를 암묵적으로 this로 사용한다. 하지만 this 없이 프로퍼티에 접근하면 스코프 체인을 따라 가장 가까운 변수를 찾는다.

```
스코프 체인:
1. apply 블록의 리시버 (새 Node) ← 여기에 name이 있지만
2. makeChild 메서드 파라미터
3. 외부 클래스 Node의 멤버 ← name을 여기서 찾음
```

### 해결 방법 1: this 명시적 참조

**this?로 nullable 처리**

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName")
            .apply { print("Created ${this?.name}") }  // this 명시

    fun create(name: String): Node? = Node(name)
}

fun main() {
    val node = Node("parent")
    node.makeChild("child")  // "Created parent.child" 출력
}
```

**레이블로 명확히 구분**

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName")
            .apply {
                print("Created ${this?.name} in ${this@Node.name}")
            }

    fun create(name: String): Node? = Node(name)
}

fun main() {
    val node = Node("parent")
    node.makeChild("child")
    // "Created parent.child in parent" 출력
}
```

### 해결 방법 2: also/let 사용 (권장)

**also로 명시적 파라미터 사용**

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName")
            .also { print("Created ${it?.name}") }  // it으로 명시적 참조

    fun create(name: String): Node? = Node(name)
}

fun main() {
    val node = Node("parent")
    node.makeChild("child")  // "Created parent.child" 출력
}
```

**왜 also/let이 더 좋은가?**

1. **명시적**: `it`은 항상 also/let의 인자를 가리킴
2. **강제성**: 리시버를 명시적으로 사용하도록 강제
3. **nullable 처리**: `it?.name` 형태로 safe call 자연스러움

### 스코프 함수 선택 가이드

| 함수 | 리시버 | 반환값 | 사용 예시 |
|------|--------|--------|-----------|
| **apply** | this (암묵적) | this | 객체 초기화, 설정 |
| **also** | it (명시적) | this | 부가 작업, 로깅 |
| **run** | this (암묵적) | 람다 결과 | 계산 + 결과 반환 |
| **let** | it (명시적) | 람다 결과 | null 체크 + 변환 |
| **with** | this (암묵적) | 람다 결과 | 여러 메서드 호출 |

**nullable 처리 시 권장**

```kotlin
// ❌ apply: this? 필요
user?.apply {
    this?.name = "Updated"  // 어색함
}

// ✅ also: it? 자연스러움
user?.also {
    it.name = "Updated"
}

// ✅ let: 변환 + null 체크
val userName = user?.let { it.name }
```

### 중첩된 스코프에서의 혼란

**문제: 여러 레벨의 리시버**

```kotlin
class Order {
    var status: String = "PENDING"

    fun process(user: User) {
        user.apply {
            // 여기서 status는?
            println(status)  // Order의 status? User의 status?
        }
    }
}

class User {
    var status: String = "ACTIVE"
}
```

**해결: 레이블 사용**

```kotlin
class Order {
    var status: String = "PENDING"

    fun process(user: User) {
        user.apply userScope@{
            println(this.status)  // User의 status
            println(this@Order.status)  // Order의 status
        }
    }
}
```

**더 나은 해결: also/let 사용**

```kotlin
class Order {
    var status: String = "PENDING"

    fun process(user: User) {
        user.also { u ->
            println(u.status)  // User의 status (명확)
            println(this.status)  // Order의 status (명확)
        }
    }
}
```

### 실전 예제: 빌더 패턴

**apply를 사용하되 명시적으로**

```kotlin
data class HttpRequest(
    var url: String = "",
    var method: String = "GET",
    var headers: MutableMap<String, String> = mutableMapOf()
)

// ✅ apply는 빌더 패턴에 적합
fun buildRequest() = HttpRequest().apply {
    this.url = "https://api.example.com"  // this 명시
    this.method = "POST"
    this.headers["Content-Type"] = "application/json"
}

// ✅ 또는 레이블 사용
fun buildRequestWithLabel() = HttpRequest().apply builder@{
    url = "https://api.example.com"
    method = "POST"
    headers["Content-Type"] = "application/json"
}
```

## 실무 적용

### Spring에서의 활용

```kotlin
// ❌ 혼란스러운 apply
@Service
class UserService(
    private val userRepository: UserRepository
) {
    fun updateUser(userId: Long, request: UpdateRequest) {
        userRepository.findById(userId).apply {
            // this는 Optional<User>? User?
            // 혼란스러움
        }
    }
}

// ✅ 명확한 let
@Service
class UserService(
    private val userRepository: UserRepository
) {
    fun updateUser(userId: Long, request: UpdateRequest) {
        userRepository.findById(userId).let { optionalUser ->
            optionalUser.ifPresent { user ->
                user.name = request.name
                userRepository.save(user)
            }
        }
    }
}
```

### 로깅과 디버깅

```kotlin
// ✅ also로 부가 작업
fun processOrder(order: Order): Result {
    return order
        .also { log.info("Processing order: ${it.id}") }
        .validate()
        .also { log.info("Validated order: ${it.id}") }
        .execute()
        .also { log.info("Executed order: ${it.id}") }
}
```

### 객체 초기화

```kotlin
// ✅ apply는 초기화에 적합
val dialog = Dialog().apply {
    title = "Confirm"
    message = "Are you sure?"
    positiveButton = "Yes"
    negativeButton = "No"
}

// ❌ also는 초기화에 부자연스러움
val dialog = Dialog().also {
    it.title = "Confirm"  // it을 반복하는 게 번거로움
    it.message = "Are you sure?"
}
```

## 금융권에서의 고려사항

**거래 처리 로깅**
- also로 각 단계마다 로그 남기기
- 명시적 파라미터로 어떤 객체를 로깅하는지 명확히

**객체 변환 체이닝**
- let으로 nullable 체크와 변환을 체이닝
- 각 단계의 입출력이 명확함

```kotlin
fun processTransaction(request: TransactionRequest): TransactionResult {
    return request
        .also { log.info("Received transaction request: ${it.id}") }
        .let { validateRequest(it) }
        .also { log.info("Validated request") }
        .let { executeTransaction(it) }
        .also { log.info("Executed transaction: ${it.transactionId}") }
}
```

---

**출처**
- Effective Kotlin (마르친 모스칼라)

