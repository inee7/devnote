---
tags: [kotlin, class, inheritance, object-oriented-programming]
---

## 한 줄 요약

코틀린은 기본적으로 final이며 public인 클래스 설계 원칙을 통해 안전하고 간결한 객체지향 프로그래밍을 지원한다.

## 핵심 정리

- 인터페이스에 프로퍼티 선언 가능하며, 디폴트 메소드 구현 지원
- 클래스와 메소드는 기본적으로 `final`이며, 상속을 허용하려면 `open` 필요
- `data` 클래스로 equals, hashCode, toString 자동 생성
- `object` 키워드로 싱글턴, 동반 객체, 무명 객체 생성
- 중첩 클래스는 기본적으로 외부 클래스 참조하지 않음 (자바와 반대)
- `sealed` 클래스로 클래스 계층 제한 가능

## 상세 내용

### 인터페이스

코틀린 인터페이스는 자바 8의 디폴트 메소드처럼 구현된 메소드를 포함할 수 있다.

```kotlin
/* 간단한 인터페이스 선언 */
interface Clickable {
    fun click()
}

/* 인터페이스 구현 */
class Button : Clickable {
    override fun click() = println("I was clicked")
}

Button().click()  /* I was clicked */
```

특징:
- 콜론(`:`)으로 인터페이스와 클래스 상속 표현
- 인터페이스는 제한없이 구현 가능, 클래스는 1개만 상속 가능
- `override` 변경자는 필수

#### 디폴트 메소드

```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")  /* 디폴트 메소드 */
}

interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if(b) "got" else "lost"} focus.")
    fun showOff() = println("I'm focusable!")
}

/* 동일한 메소드가 여러 인터페이스에 있으면 반드시 오버라이드 */
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")

    override fun showOff() {
        super<Clickable>.showOff()  /* 부모 타입 지정 */
        super<Focusable>.showOff()
    }
}
```

### 가시성 변경자와 상속 제어

#### open, final, abstract

```kotlin
/* 상속 가능한 클래스 */
open class RichButton : Clickable {
    fun disable() { }           /* final - 오버라이드 불가 */
    open fun animate() { }      /* open - 오버라이드 가능 */
    override fun click() { }    /* override한 메소드는 기본적으로 open */
}

/* 오버라이드 금지 */
open class RichButton : Clickable {
    final override fun click() { }
}

/* 추상 클래스 */
abstract class Animated {
    abstract fun animate()           /* 추상 메소드는 항상 open */
    open fun stopAnimating() { }     /* 비추상 메소드는 기본 final */
    fun animateTwice() { }           /* final */
}
```

상속 제어 변경자 정리:

| 변경자 | 오버라이드 가능 | 설명 |
|--------|----------------|------|
| `final` | 불가 | 클래스 멤버의 기본 상태 |
| `open` | 가능 | 반드시 명시 필요 |
| `abstract` | 필수 | 추상 클래스에서만 사용, 구현 없음 |
| `override` | 가능 | 기본적으로 open, final로 금지 가능 |

#### 가시성 변경자

```kotlin
internal open class TalkativeButton : Focusable {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}

/* 에러: internal을 public에서 참조 불가 */
fun TalkativeButton.giveSpeech() {
    yell()      /* 에러: private */
    whisper()   /* 에러: protected */
}
```

코틀린 가시성 변경자:

| 변경자 | 클래스 멤버 | 최상위 선언 |
|--------|------------|-----------|
| `public` (기본) | 모든 곳 | 모든 곳 |
| `internal` | 같은 모듈 | 같은 모듈 |
| `protected` | 하위 클래스 | (사용 불가) |
| `private` | 같은 클래스 | 같은 파일 |

### 중첩 클래스와 내부 클래스

```kotlin
/* 중첩 클래스 (기본) - 외부 클래스 참조 없음 */
class Button : View {
    override fun getCurrentState(): State = ButtonState()
    override fun restoreState(state: State) { /* ... */ }

    class ButtonState : State { /* ... */ }  /* 자바의 static 중첩 클래스 */
}

/* 내부 클래스 - 외부 클래스 참조 */
class Outer {
    inner class Inner {
        fun getOuterReference(): Outer = this@Outer
    }
}
```

자바와 코틀린 비교:

| 구분 | 자바 | 코틀린 |
|------|------|--------|
| 중첩 클래스 (외부 참조 없음) | `static class A` | `class A` |
| 내부 클래스 (외부 참조 있음) | `class A` | `inner class A` |

### sealed 클래스

`sealed` 클래스는 클래스 계층을 제한하여 when 식에서 else 분기 없이 사용 가능하다.

```kotlin
/* sealed 클래스로 식 표현 */
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr): Int = when(e) {  /* else 불필요 */
    is Expr.Num -> e.value
    is Expr.Sum -> eval(e.right) + eval(e.left)
}
```

### 생성자와 초기화

#### 주 생성자

```kotlin
class User(val nickname: String)

/* 위 코드를 풀어쓰면 */
class User constructor(_nickname: String) {
    val nickname: String

    init {  /* 초기화 블록 */
        nickname = _nickname
    }
}

/* 디폴트 값 지정 */
class User(val nickname: String, val isSubscribed: Boolean = true)

val hyun = User("현석")
println(hyun.isSubscribed)  /* true */

/* 상위 클래스 초기화 */
open class User(val nickname: String)
class TwitterUser(nickname: String) : User(nickname)

/* private 생성자 */
class Secretive private constructor() {}
```

#### 부 생성자

```kotlin
open class View {
    constructor(ctx: Context) {
        /* 코드 */
    }

    constructor(ctx: Context, attr: AttributeSet) {
        /* 코드 */
    }
}

class MyButton : View {
    constructor(ctx: Context) : this(ctx, MY_STYLE) {
        /* ... */
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {
        /* ... */
    }
}
```

### 프로퍼티

#### 인터페이스의 프로퍼티

```kotlin
interface User {
    val nickname: String
}

/* 방법 1: 주 생성자의 프로퍼티 */
class PrivateUser(override val nickname: String) : User

/* 방법 2: 커스텀 게터 */
class SubscribingUser(val email: String) : User {
    override val nickname: String
        get() = email.substringBefore('@')
}

/* 방법 3: 프로퍼티 초기화 */
class FacebookUser(val accountId: Int) : User {
    override val nickname = getFacebookName(accountId)
}
```

#### 게터와 세터에서 뒷받침하는 필드 접근

```kotlin
class User(val name: String) {
    var address: String = "unspecified"
        set(value: String) {
            println("""
                Address was changed for $name:
                "$field" -> "$value".""".trimIndent())
            field = value  /* 뒷받침하는 필드 */
        }
}

val user = User("Alice")
user.address = "Elsenheimerstrasse 47, 80687 Muenchen"
```

#### 접근자 가시성 변경

```kotlin
class LengthCounter {
    var counter: Int = 0
        private set  /* 외부에서 값 변경 불가 */

    fun addWord(word: String) {
        counter += word.length
    }
}
```

### 데이터 클래스

```kotlin
/* 자동으로 equals, hashCode, toString 생성 */
data class Client(val name: String, val postalCode: Int)

val client1 = Client("오현석", 4122)
println(client1)  /* Client(name=오현석, postalCode=4122) */

val client2 = Client("오현석", 4122)
println(client1 == client2)  /* true */

/* copy 메소드 - 불변 객체 복사 */
val lee = Client("이계영", 4122)
println(lee.copy(postalCode = 4000))  /* Client(name=이계영, postalCode=4000) */
```

### 클래스 위임: by

```kotlin
/* 위임 없이 데코레이터 패턴 구현 */
class DelegatingCollection<T> : Collection<T> {
    private val innerList = arrayListOf<T>()
    override val size: Int get() = innerList.size
    override fun isEmpty(): Boolean = innerList.isEmpty()
    override fun contains(element: T): Boolean = innerList.contains(element)
    override fun iterator(): Iterator<T> = innerList.iterator()
    override fun containsAll(elements: Collection<T>): Boolean =
        innerList.containsAll(elements)
}

/* by 키워드로 간결하게 */
class DelegatingCollection<T>(
    innerList: Collection<T> = ArrayList<T>()
) : Collection<T> by innerList {}

/* 일부 메소드만 오버라이드 */
class CountingSet<T>(
    val innerSet: MutableCollection<T> = HashSet<T>()
) : MutableCollection<T> by innerSet {
    var objectsAdded = 0

    override fun add(element: T): Boolean {
        objectsAdded++
        return innerSet.add(element)
    }

    override fun addAll(c: Collection<T>): Boolean {
        objectsAdded += c.size
        return innerSet.addAll(c)
    }
}
```

### object 키워드

#### 객체 선언 (싱글턴)

```kotlin
object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
        for (person in allEmployees) {
            /* ... */
        }
    }
}

Payroll.allEmployees.add(Person(...))
Payroll.calculateSalary()

/* 인터페이스 구현 */
object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
        return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}

val files = listOf(File("/Z"), File("/a"))
println(files.sortedWith(CaseInsensitiveFileComparator))  /* [/a, /Z] */
```

#### 동반 객체

```kotlin
class A {
    companion object {
        fun bar() {
            println("Companion object called")
        }
    }
}

A.bar()  /* Companion object called */

/* 팩토리 메소드 */
class User private constructor(val nickname: String) {
    companion object {
        fun newSubscribingUser(email: String) =
            User(email.substringBefore('@'))

        fun newFacebookUser(accountId: Int) =
            User(getFacebookName(accountId))
    }
}

val subscribingUser = User.newSubscribingUser("bob@gmail.com")
val facebookUser = User.newFacebookUser(4)
```

#### 동반 객체 확장

```kotlin
/* 비즈니스 로직 모듈 */
class Person(val firstName: String, val lastName: String) {
    companion object { }  /* 비어있는 동반 객체 선언 */
}

/* 클라이언트/서버 통신 모듈 */
fun Person.Companion.fromJSON(json: String): Person {
    /* ... */
}

val p = Person.fromJSON(json)
```

#### 무명 객체

```kotlin
window.addMouseListener(
    object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            /* ... */
        }

        override fun mouseEntered(e: MouseEvent) {
            /* ... */
        }
    }
)

/* 로컬 변수 접근 가능 (final이 아니어도 됨) */
fun countClicks(window: Window) {
    var clickCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++  /* 로컬 변수 변경 가능 */
        }
    })
}
```

## 관련 노트

- [[코틀린-기본-문법]] - 코틀린 기본 구조와 클래스 기초
- [[코틀린-타입-시스템]] - 타입 계층과 Any, Unit
- [[코틀린-연산자-오버로딩]] - 연산자 오버로딩과 관례

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 4장
