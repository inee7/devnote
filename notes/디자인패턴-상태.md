---
tags: [design-pattern, kotlin, behavioral]
---

# 상태 패턴

## 한 줄 요약

객체의 내부 상태에 따라 행동을 변경하는 패턴

## 핵심 정리

- 전략 패턴의 일종
- 전략 패턴은 외부의 클라이언트가 전략을 교체하는 반면, 상태 패턴은 오로지 입력에 의해 내부적으로 변경
- 상태 패턴을 사용하면 모든 것을 통제 아래에 둘 수 있음
- if문을 대체하기 위함

## 상세 내용

### 구현 예제

```kotlin
sealed class Mood {
    // Some abstract methods here, like draw(), for example
}
object Still : Mood()
object Aggressive : Mood()
object Retreating : Mood()
object Dead : Mood()

class Snail : WhatCanHappen {
    private var healthPoints = 10
    private var mood: Mood = Still

    override fun seeHero() {
        mood = when (mood) {
            is Still -> {
                println("Aggressive")
                Aggressive
            }
            else -> {
                println("No change")
                mood
            }
        }
    }

    override fun getHit(pointsOfDamage: Int) {
        println("Hit for $pointsOfDamage points")
        healthPoints -= pointsOfDamage

        println("Health: $healthPoints")
        mood = when {
            (healthPoints <= 0) -> {
                println("Dead")
                Dead
            }
            mood is Aggressive -> {
                println("Retreating")
                Retreating
            }
            else -> {
                println("No change")
                mood
            }
        }
    }

    override fun calmAgain() {
    }
}
```

### 특징

- `sealed class`를 사용하여 가능한 모든 상태를 정의
- `when` 표현식으로 상태 전이를 명확하게 표현
- 각 이벤트(seeHero, getHit)에 따라 상태가 내부적으로 변경
- 컴파일 타임에 모든 상태 처리 검증 가능

### 전략 패턴과의 차이

- 상태 패턴: if문을 대체하기 위함
- 전략 패턴: 상속을 대체하기 위함

## 관련 노트

- [[디자인패턴-전략]] - 알고리즘 선택이 목적 (상태는 상태별 행위 변경)

---

**출처**
- 코틀린 디자인 패턴
