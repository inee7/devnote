
---
tags: [mysql, sql, performance, index, like-operator, full-text-search]
---

## LIKE 검색
데이터를 조회할 때 특정 단어가 들어 있는 데이터를 검색하기 위해 LIKE 검색을 사용한다. LIKE 검색은 상당히 편리하지만 대용량 테이블인 경우에는 위험하다. LIKE 검색은 ‘%’ 문자 위치에 따라 다르게 수행된다. [col LIKE ‘abc%’] 이면 abc로 시작하는 문자를 조회한다. [col LIKE ‘%abc%’]이면 abc를 포함한 데이터를 가져온다. 그리고 [col LIKE ‘abc’]는 abc로 끝나는 데이터를 가져온다. LIKE 검색 시 ‘%’ 위치에 따라서는 컬럼에 해당 인덱스가 있을지라도 의미가 없을 수도 있으니 SQL 작성 시 유의해야 한다.

### LIKE ‘xxx%’ 테스트
[LIKE ‘xxx%’]는 인덱스가 있으면 해당 인덱스를 사용하여 쿼리가 빠르게 처리된다. 테스트 한 MySQL Explain 은 다음과 같다.

```sql
EXPLAIN
SELECT * FROM test WHERE s LIKE ‘1311%’;
    id     table     Type    Key       Key_len    Rows
------    -------   -------  ------   ----------  --------
     1     test      RANGE    s        130        24
```
정상적으로 인덱스를 잘 활용하며 결과 또한 빠르게 나온다. 즉, LIKE로 데이터를 검색하더라도 뒷부분에 % 를 붙이면 인덱스를 적절하게 활용할 수 있다.
```sql
EXPLAIN
SELECT * FROM test WHERE s LIKE ‘1%’;
    id     table     Type    Key       Key_len     Rows
------    -------   -------  ------   ----------  --------
     1     test      ALL     NULL      NULL        131072
```
하지만 위의 결과는 앞과 동일한 쿼리지만 LIKE 조건을 ‘1311%’ 에서 ‘1%’로 변경했을 뿐인데, 테이블 풀스캔 변경되었다.
대부분의 DBMS에는 옵티마이저가 있다. 옵티마이저는 데이터 분포도를 따져서 내부적으로 SQL을 최적으로 처리한다. 앞의 예제는 1로 시작하는 데이터 비율이 전체적으로 20% 이상을 차지하므로, 인덱스를 읽고 다시 데이터 파일로 가는 것보다 처음부터 전체 데이터를 읽고 필요한 데이터를 선별하는 것이 더 빠르다고 옵티마이저가 판단했기 때문에 풀스캔을 한 것이다.
인덱스는 데이터가 위치한 곳을 지칭한다. 인덱스도 데이터고 지칭하는 데이터로 차아가려면 실 데이터에 대한 데이터를 다시 읽어야 하기 때문에 중복된 데이터 처리 비용보다는 테이블 풀스캔으로 접근하는 것이 훨씬 빠르다고 옵티마이저가 판단한 것이다. 다음은 1~9의 각 숫자로 시작되는 데이터의 비율이다.
```sql

SELECT left(s, 1) str, count(*) cnt
FROM test
GROUP BY left(s, 1);

Str   Cnt
---  --------
1    27525
2    27460
3    27261
4    27652
5    10292
6     2692
7     2619
8     2839
9     2732
```

### LIKE ‘%xxx%’ 테스트
인덱스는 순차적으로 비교되므로 당연히 테이블 풀스캔이 발생한다.
```sql
EXPLAIN
SELECT * FROM test WHERE s LIKE ‘%1311%’;
    id     table     Type    Key       Key_len     Rows
------    -------   -------  ------   ----------  --------
     1     test      ALL     NULL      NULL        131072
```

### LIKE ‘%xxx’ 테스트
[LIKE %xxx%]의 결과와 마찬가지로 테이블 풀스캔이 발생한다.
```sql
EXPLAIN
SELECT * FROM test WHERE s LIKE ‘%1311’;
    id     table     Type    Key       Key_len     Rows
------    -------   -------  ------   ----------  --------
     1     test      ALL     NULL      NULL        131072
```

### 결론
LIKE 검색을 별생각 없이 사용하다 보면 DBMS 성능이 전체적으로 크게 저하된다. 그렇다고 이런 편리한 기능을 무조건 사용하지 않을 수는 없다. 다음과 같이 SQL 작성 팁 지켜도 LIKE 검색의 성능을 향상시킬 수 있다.
*  LIKE 조건이 ‘검색어%’ 와 같이 검색어가 앞 단에 있다면 데이터 분포도를 따져서 수행한다.
*  LIKE 조건이 ‘%검색어’와 같은 형태로 반드시 수행해야 한다면 LIKE 조건 이외의 조건절을 적응 활용하여 LIKE 처리가 필요한 데이터 범위를 최대한 줄인다.

인덱스는 필요한 데이터를 지칭한다는 점에서 데이터에 접근하기 위한 효율적 요소인 것은 분명하다. 그러나 인덱스 또한 메모리를 차지하고, 디스크를 소모하며, CPU 연산이 필요한 데이터라는 것을 기억해야 한다. DB에서 처리하는 데이터 범위를 MySQL Explain 활용하여 최대한 줄이는 것이 성능 최적화의 가장 기본적인 요소이다.


아래를 쓰면 인덱스걸고 %xx% 쓸수 있음 
**MySQL의 Full-text Index ( 보통 Full-text Index 라고 부름 )**
: Full-text Index의 경우에는 한 컬럼 안에서 많은 형태의 데이터가 담겨있어서 효율적으로 데이터를 찾는 경우 사용하는 것이 일반적입니다.
예를 들면,
컨텐츠 내용과 같이 사용자가 쓰기 나름인 데이터를 토큰 단위로 쪼개서 검색에 용이하게 합니다.
컨텐츠 내용 : "나는 오늘 seoul의 sky를 바라보면서 베스킨라빈스31에서 맛있는 요리를 먹었다! 정말 기분 좋았다." 와 같이 한글, 영어, 숫자가 섞여 있거나 긴 내용을 검색할 때 사용됩니다.
출처:  [https://interconnection.tistory.com/95](https://interconnection.tistory.com/95)  [Ryan Server]