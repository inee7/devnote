---
tags: [oop, coupling, srp, composition-over-inheritance]
---

# 결합도와 단일 책임

## 한 줄 요약

느슨한 결합을 위해 개념적으로 다른 것은 중복을 허용하고, 컴포지션을 활용하며, 클래스 크기를 100-200줄로 유지한다

## 핵심 정리

- 느슨한 결합: 서로 영향을 주지 않음 (RegularDiscountedPrice → RegularPrice)
- 개념이 다르면 중복 허용: DRY 원칙 과도 적용 금지
- 컴포지션 > 상속: 강한 결합 피하기
- 책임 분리: 인스턴스 변수와 메서드 관계 확인
- public 최소화, private 메서드 많으면 책임 과다
- 클래스 크기: 100-200줄 이내

## 상세 내용

### 단일 책임 원칙 (SRP)

**예시:** `DiscountManager.getDiscountPrice`는 일반 할인 가격 계산을 책임지는 메서드다.

여름 할인 가격까지 책임지게 하면 단일 책임 원칙을 깨는 것이다.

**원칙:** Product에서 상품명과 가격이 타당한지 판단해야 한다. 다른 클래스에서 판단하면 안 된다.

### 느슨한 결합 예시

```java
class RegularPrice {
    private static final int MIN_AMOUNT = 0;
    final int amount;

    RegularPrice(final int amount) {
        if (amount < MIN_AMOUNT) {
            throw new IllegalArgumentException("금액은 0 이상이어야 합니다");
        }
        this.amount = amount;
    }
}

class RegularDiscountedPrice {
    private static final int MIN_AMOUNT = 0;
    private static final int DISCOUNT_AMOUNT = 4000;
    final int amount;

    RegularDiscountedPrice(final RegularPrice price) {
        int discountedAmount = price.amount - DISCOUNT_AMOUNT;
        if (discountedAmount < MIN_AMOUNT) {
            discountedAmount = MIN_AMOUNT;
        }
        amount = discountedAmount;
    }
}
```

`RegularDiscountedPrice` → `RegularPrice` 로 느슨한 결합을 이루어 서로 영향을 주지 않는다.

### 개념이 다르면 중복 허용

`RegularDiscountedPrice`와 비슷한 구조에 룰만 달라지면 어떻게 될까?

DRY 원칙으로 중복을 줄이기 위해 작업해야 할까?

**아니다.** 룰이 달라진다는 것은 **개념이 달라지는 것**이다. 중복을 허용해야 한다.

개념적으로 다른 것까지도 무리하게 중복 제거하면 **강한 결합**이 된다.

### 상속보다 컴포지션

강한 결합을 피해야 SRP가 지켜진다.

**상속을 피하자!** 컴포지션으로 해결하자.

```java
// ❌ 상속: 강한 결합
class SummerDiscountedPrice extends RegularDiscountedPrice {
    // 부모 클래스 변경 시 영향 받음
}

// ✅ 컴포지션: 느슨한 결합
class SummerDiscountedPrice {
    private final RegularPrice regularPrice;

    SummerDiscountedPrice(RegularPrice price) {
        this.regularPrice = price;
    }
}
```

### 책임 분리 판별법

클래스에 인스턴스 변수들이 있고 `예약취소`, `다크모드전환`, `메일보내기` 메서드가 있다면 책임 분리가 필요하다.

**판별 방법:**
1. 각 메서드가 인스턴스 변수를 활용하고 있는지 확인
2. 메서드 간에 의존이 있는지 확인
3. 의존이 없다면 각각 클래스로 분리 가능

**도구:** 영향 스케치로 의존관계를 그릴 수 있는데, **jig**라는 도구가 있다.

### 접근 제한자 원칙

- **public을 처음부터 쓰지 말자**
- **private 메서드가 너무 많으면** 책임이 너무 많다는 신호

### 거대 데이터 클래스의 문제

거대 데이터 클래스는 다양한 데이터를 가지고 수많은 유스케이스에 사용된다.

**문제점:**
- 동기화하느라 성능 저하
- 전역변수와 동일한 폐해 발생

### 적절한 클래스 크기

SRP에 따라 설계된 클래스는 **아무리 많아도 100~200줄 정도**이다.

**SRP에 도움이 되는 패턴:**
- 조기 리턴
- 전략 패턴
- 일급 컬렉션

## 실무 적용

### Spring에서의 책임 분리

```java
// ❌ 하나의 Service에 모든 책임
@Service
class UserService {
    void register() { }
    void sendEmail() { }
    void updateDarkMode() { }
    void cancelReservation() { }
}

// ✅ 책임별로 분리
@Service
class UserRegisterService { }

@Service
class EmailService { }

@Service
class ThemeService { }

@Service
class ReservationService { }
```

### Jig 활용

[Jig](https://github.com/dddjava/jig)는 자바 코드의 의존관계를 자동으로 다이어그램으로 그려주는 도구다.

```bash
./gradlew jig
```

클래스 간 의존관계를 시각화하여 강한 결합을 발견하는 데 도움이 된다.

## 관련 노트

- [[단일-책임-원칙]]
- [[객체지향-설계-원칙#응집도]]
- [[DRY 잘못된 적용으로 깨지는 SRP]]
- [[조건분기]]
- [[객체지향-설계-원칙#일급 컬렉션]]

---

**출처**
- 내 코드가 그렇게 이상한가요 (마츠오카 켄타로), 8장