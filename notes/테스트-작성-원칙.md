---
tags: [testing, unit-test, first-principles, refactoring-resistance, maintainability]
---

## 한 줄 요약

좋은 테스트는 F.I.R.S.T 원칙(빠르고, 독립적이며, 반복 가능하고, 자동 검증되며, 적시에 작성)과 4가지 품질 조건(회귀 방지, 리팩토링 저항성, 유지보수성, 빠른 피드백)을 만족한다.

## 핵심 정리

- 단위 테스트의 '단위'는 코드 단위(unit of code)가 아닌 **행동 단위(unit of behavior)**
- F.I.R.S.T: Fast(빠름), Isolated(고립), Repeatable(반복 가능), Self-Validating(자동 검증), Timely(적시 작성)
- 4가지 품질 조건: 회귀 방지 > 리팩토링 저항성 > 유지보수성 > 빠른 피드백 (우선순위 순)
- 리팩토링 저항성: 내부 구현이 아닌 외부 동작(결과)을 검증
- 회귀 방지: 버그가 다시 들어오는 걸 막는 방패 역할
- 유지보수성: 테스트는 문서처럼 읽혀야 함
- 빠른 피드백: 느린 테스트는 개발자가 무시하게 됨

## 상세 내용

### F.I.R.S.T 원칙

단위 테스트(Unit Test)가 진짜 "좋은 테스트"가 되려면 다음 다섯 가지 원칙을 만족해야 합니다.

> 좋은 단위 테스트는
> 빠르고(**FAST**), 독립적이며(**ISOLATED**),
> 항상 같은 결과(**REPEATABLE**)를 내고,
> 스스로 판정(**SELF-VALIDATING**)하며,
> 코드와 함께 작성(**TIMELY**)된다.

#### 1. FAST — 빠르고 (Fast)

**의미**

테스트는 **항상 빠르게 실행되어야 한다.**
1초 안에 돌 수 있는 테스트라야 개발자가 수시로 실행하면서 리팩토링을 반복할 수 있다.

**이유**
- 느린 테스트는 개발 루프(코드 → 실행 → 확인)를 방해한다
- 속도가 느려지면 "테스트 무시 → 테스트 부패"로 이어진다

**좋은 예**

```kotlin
@Test
fun `할인율 계산`() {
    val price = PriceCalculator().calculate(10000, 0.1)
    assertThat(price).isEqualTo(9000)
}
```

**나쁜 예**

```kotlin
@Test
fun `할인율 계산`() {
    val result = PriceService(realDatabaseConnection).calculateDiscount("user123")
    assertThat(result).isEqualTo(9000)
}
```

#### 2. ISOLATED — 고립되어 (Isolated)

**의미**

각 테스트는 **서로 독립적으로 동작**해야 하며,
외부 환경(DB, 파일, 네트워크)에 의존하지 않아야 한다.

**이유**
- 테스트 순서가 바뀌어도 결과가 같아야 한다
- 다른 테스트의 상태(데이터, 캐시, 전역 변수)에 영향을 받으면 안 된다

**좋은 예**

```kotlin
@Test
fun `쿠폰 할인 적용`() {
    val sut = DiscountPolicy()
    val result = sut.applyCoupon(10000, 0.1)
    assertThat(result).isEqualTo(9000)
}
```

**나쁜 예**

```kotlin
@Test
fun `이전 테스트에서 저장된 사용자 데이터 활용`() {
    val user = database.findLastInsertedUser()  // 의존
    val result = service.giveReward(user)
    assertThat(result.point).isEqualTo(100)
}
```

이전 테스트의 결과에 의존하면 고립성이 깨진다. DB 접근, 네트워크, 파일 I/O 등은 [[테스트더블]]을 이용해 제거해야 한다.

#### 3. REPEATABLE — 반복 가능하고 (Repeatable)

**의미**

테스트는 **언제 어디서 돌려도 항상 같은 결과**를 내야 한다.
(환경, 순서, 시간, 랜덤값, 네트워크에 영향을 받지 않아야 함)

**이유**
- "가끔 실패하는 테스트(Flaky Test)"는 가장 위험하다
- 신뢰할 수 없으면 아무도 테스트를 믿지 않게 된다

**좋은 예**

```kotlin
@Test
fun `세금 계산`() {
    val result = TaxCalculator().calculate(10000)
    assertThat(result).isEqualTo(1000)
}
```

**나쁜 예**

```kotlin
@Test
fun `현재 시각 기준으로 포인트 만료`() {
    val now = LocalDateTime.now()
    val result = service.expirePoint(now)
    assertThat(result).isTrue() // 매번 다름
}
```

`now()` 사용으로 결과가 실행 시점마다 달라짐.
Clock 주입(테스트용 고정 시각)으로 해결해야 한다.

#### 4. SELF-VALIDATING — 결과가 자동 검증되어야 (Self-Validating)

**의미**

테스트는 **사람이 로그를 눈으로 확인하지 않아도**,
스스로 결과를 판정해야 한다.
즉, "pass / fail"이 자동으로 판정되어야 한다.

**이유**
- 수동 확인이 필요하면 CI/CD에서 자동 검증 불가
- 테스트의 본질은 "결과가 자동으로 옳은지 증명"하는 것

**좋은 예**

```kotlin
@Test
fun `포인트 적립`() {
    val point = service.addPoint(100)
    assertThat(point.balance).isEqualTo(100)
}
```

**나쁜 예**

```kotlin
@Test
fun `포인트 적립`() {
    val point = service.addPoint(100)
    println(point.balance)  // 눈으로 확인해야 함 ❌
}
```

#### 5. TIMELY — 코드 작성 직후 바로 작성되어야 (Timely)

**의미**

테스트는 기능 구현 "후에" 쓰는 게 아니라,
**기능 작성과 함께(또는 그 전에)** 만들어야 한다.

**이유**
- 늦게 쓰면 로직을 잊고 커버리지가 줄어든다
- "테스트 가능한 구조"로 코드를 설계하게 해준다 (TDD 핵심 효과)

**좋은 흐름**

1. 실패하는 테스트 작성
2. 최소한의 코드로 통과
3. 리팩토링

**나쁜 흐름**

기능 다 만든 뒤, 테스트 "형식상 추가" → 결함 못 잡고 시간 낭비

#### F.I.R.S.T 요약표

| **원칙**              | **의미**                  | **나쁜 경우**         |
| ------------------- | ----------------------- | ----------------- |
| **FAST**            | 테스트는 빠르게 실행되어야 한다       | DB, 네트워크 접근 포함    |
| **ISOLATED**        | 다른 테스트나 환경에 의존하지 않아야 한다 | 순서 의존, 공유 데이터     |
| **REPEATABLE**      | 항상 같은 결과를 내야 한다         | now(), 랜덤값 의존     |
| **SELF-VALIDATING** | 사람이 아닌 코드가 결과를 검증해야 한다  | println, 로그 확인 필요 |
| **TIMELY**          | 코드 작성 시점에 함께 만들어야 한다    | 기능 후 작성, 커버리지 부족  |

이 다섯 가지를 지키면
테스트는 단순한 "기능 검증용 코드"가 아니라,
**"안전하게 리팩토링할 수 있는 품질 자산"**이 된다.

### 좋은 테스트의 4가지 품질 조건

F.I.R.S.T 원칙 외에도 좋은 테스트는 다음 4가지 품질 조건을 만족해야 합니다.

#### 1. 회귀에 대한 보호 (Protection against Regressions)

**의미**

과거에 정상 작동하던 기능이 **나중에 망가졌을 때 이를 빠르게 잡아내는 능력**.
즉, **버그 방지망** 역할.
이게 테스트가 존재하는 **가장 본질적인 이유**이기도 함.

**예시**

변경으로 인해 프로모션 만료 조건이 누락됐는데, 테스트가 실패함 → ✅ 좋은 테스트

반대로 테스트가 그걸 캐치하지 못하면, "그 테스트는 있으나 마나한 테스트"임.

**요약**

> "테스트는 코드가 바뀌어도, **버그가 다시 들어오는 걸 막는 방패**여야 한다."

#### 2. 리팩토링에 대한 저항성 (Resistance to Refactoring)

**의미**

코드 내부 구조가 바뀌어도(예: 함수 분리, 메서드명 변경, 리포지토리 교체)
테스트가 **깨지지 않고 그대로 통과**하는 성질.

즉, **"내부 구현"이 아니라 "외부 동작(결과)"**을 검증하는 테스트.

이 개념은 [[단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실]]에서도 중요하게 다루어집니다.

**예시**

**나쁜 예**:

```kotlin
verify(repo).save(any())    // 내부 호출 방식에 의존
```

구현이 바뀌면 테스트 깨짐

**좋은 예**:

```kotlin
assertThat(result.id).isNotNull()    // 결과(효과) 중심 검증
```

**요약**

> "테스트는 코드 리팩토링의 발목을 잡으면 안 된다."

#### 3. 유지보수성 (Maintainability)

**의미**

테스트 코드를 **쉽게 읽고, 수정하고, 이해할 수 있는가**

테스트가 "문서처럼" 읽혀야 하며, **복잡한 설정과 중복**이 없어야 함.

**예시**

**나쁜 예**:
- JSON 문자열을 수십 줄 하드코딩
- 테스트마다 복잡한 Mock 설정 반복

**좋은 예**:
- **Fixture 메서드**나 **Builder**를 통해 재사용
- 테스트 이름이 시나리오처럼 자연스러움

```kotlin
@Test fun `만료된 프로모션은 조회되지 않는다`() { ... }
```

**요약**

> "테스트는 한 번 쓰고 버리는 게 아니라, **함께 진화해야 하는 코드**다."

#### 4. 빠른 피드백 (Fast Feedback)

**의미**

테스트가 **자주, 빠르게 돌 수 있어야** 개발자에게 유용함.

너무 느린 테스트는 개발 흐름을 끊고, 결국 **아무도 실행하지 않게 됨.**

이 원칙은 F.I.R.S.T의 'FAST' 원칙과 일맥상통합니다.

**예시**

**나쁜 예**:
- 통합 테스트만 수백 개 (DB, 외부 API 전부 띄움)
- 실행에 수분 걸림 → CI에서만 도는 "죽은 테스트"

**좋은 예**:
- 핵심 유스케이스는 빠른 단위 테스트로 커버
- 느린 통합/엔드투엔드 테스트는 스케줄로 분리 (야간 빌드 등)

**요약**

> "테스트가 느리면, **개발자가 테스트를 무시하기 시작한다.**"

#### 우선순위 (실무 기준)

| **우선순위** | **항목**        | **이유**                                 |
| -------- | ------------- | -------------------------------------- |
| 🥇 1     | **회귀에 대한 보호** | 테스트의 존재 이유 자체. 회귀를 막지 못하면 테스트의 가치가 없음. |
| 🥈 2     | **리팩토링 저항성**  | 버그를 잡더라도, 리팩토링 때마다 깨지면 유지비 폭발.         |
| 🥉 3     | **유지보수성**     | 읽히지 않고 수정 어려운 테스트는 결국 제거됨.             |
| 🏅 4     | **빠른 피드백**    | 속도는 중요하지만, 방패 역할보다 약간 후순위. CI로도 커버 가능. |

### 종합 정리

> 좋은 테스트는
> - **버그를 다시 들어오지 못하게(회귀 방지)** 하면서
> - **구현 변경에 흔들리지 않고(리팩토링 저항성)**
> - **읽고 고치기 쉬우며(유지보수성)**
> - **빠르게 결과를 보여주는(피드백 속도)**
> 테스트다.

**우선순위: 회귀 방지 > 리팩토링 저항성 > 유지보수성 > 빠른 피드백**

## 실무 적용

### 테스트 작성 체크리스트

**F.I.R.S.T 원칙 체크**
- [ ] 테스트가 1초 이내에 실행되는가? (FAST)
- [ ] 다른 테스트나 외부 환경에 의존하지 않는가? (ISOLATED)
- [ ] 항상 같은 결과를 내는가? (REPEATABLE)
- [ ] 자동으로 pass/fail을 판정하는가? (SELF-VALIDATING)
- [ ] 기능 코드와 함께 작성했는가? (TIMELY)

**4가지 품질 조건 체크**
- [ ] 버그가 재발하면 이 테스트가 잡아낼 수 있는가? (회귀 방지)
- [ ] 내부 구현 변경 시 테스트가 깨지지 않는가? (리팩토링 저항성)
- [ ] 테스트 코드가 읽기 쉽고 이해하기 쉬운가? (유지보수성)
- [ ] 테스트가 충분히 빠른가? (빠른 피드백)

### 안티패턴과 해결

**안티패턴 1: 내부 구현 검증**

```kotlin
// ❌ 나쁜 예
@Test
fun `사용자 저장`() {
    service.saveUser(user)
    verify(repository).save(any())  // 내부 호출 검증
}

// ✅ 좋은 예
@Test
fun `사용자 저장`() {
    val savedUser = service.saveUser(user)
    assertThat(savedUser.id).isNotNull()  // 결과 검증
}
```

**안티패턴 2: 복잡한 테스트 설정**

```kotlin
// ❌ 나쁜 예
@Test
fun `프로모션 적용`() {
    val user = User(id = 1, name = "test", email = "test@test.com", point = 0, ...)
    val product = Product(id = 1, name = "product", price = 10000, ...)
    val promotion = Promotion(id = 1, name = "promo", discount = 0.1, ...)
    // ...
}

// ✅ 좋은 예
@Test
fun `프로모션 적용`() {
    val user = createUser()  // Fixture 메서드
    val product = createProduct()
    val promotion = createPromotion()
    // ...
}
```

**안티패턴 3: Flaky Test**

```kotlin
// ❌ 나쁜 예
@Test
fun `쿠폰 만료 확인`() {
    val coupon = Coupon(expiredAt = LocalDateTime.now().plusDays(1))
    assertThat(coupon.isExpired()).isFalse()
}

// ✅ 좋은 예
@Test
fun `쿠폰 만료 확인`() {
    val fixedNow = LocalDateTime.of(2025, 1, 1, 0, 0)
    val coupon = Coupon(expiredAt = fixedNow.plusDays(1))
    assertThat(coupon.isExpired(fixedNow)).isFalse()
}
```

### 테스트 레벨별 적용

**Unit (단위 테스트)**
- F.I.R.S.T 원칙을 가장 엄격하게 적용
- 회귀 방지와 리팩토링 저항성 우선
- 모든 외부 의존성은 [[테스트더블]]로 대체

**Slice (슬라이스 테스트)**
- 특정 계층만 테스트하므로 FAST 유지 가능
- [[슬라이스 테스트]] 참고

**Integration (통합 테스트)**
- FAST는 어느 정도 포기 (Testcontainers 사용)
- 회귀 방지가 최우선

**E2E (엔드투엔드 테스트)**
- 빠른 피드백은 포기, 회귀 방지에 집중
- 핵심 경로만 스모크 테스트

자세한 내용은 [[테스트의 종류]]를 참고하세요.

## 금융권에서의 고려사항

- **회귀 방지 최우선**: 금융 거래 로직은 버그 재발이 치명적
- **리팩토링 저항성**: 레거시 시스템 개선 시 테스트가 발목을 잡으면 안 됨
- **유지보수성**: 규제 변경 시 테스트도 빠르게 수정 가능해야 함
- **자동 검증 필수**: 수동 확인은 감사에서 인정받기 어려움
- **Flaky Test 금지**: 간헐적 실패는 운영에 혼란 초래
- **테스트 커버리지**: 핵심 거래 로직은 100% 커버리지 목표
- **테스트 환경 격리**: 운영 DB/MQ와 완전히 분리된 환경 필수

---

**출처**
- Clean Code (Robert C. Martin)
- Unit Testing Principles, Practices, and Patterns (Vladimir Khorikov)

## 관련 노트

- [[테스트의 종류]]
- [[테스트더블]]
- [[슬라이스 테스트]]
- [[단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실]]
- [[Junit]]
