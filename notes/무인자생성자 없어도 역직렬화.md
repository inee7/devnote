---
tags: [kotlin, jackson, deserialization, reflection, no-arg-constructor, jackson-module-kotlin, data-class]
---
# Kotlin에서 무인자 생성자 없이 역직렬화하기

## 한 줄 요약

Java의 Jackson 역직렬화는 무인자 생성자를 필요로 하지만, jackson-module-kotlin은 리플렉션으로 생성자 파라미터 정보를 읽어 Kotlin의 주 생성자를 직접 호출하여 data class를 역직렬화한다.

## 핵심 정리

- **Java 역직렬화**: 무인자 생성자로 객체 생성 → setter로 필드 주입
- **Kotlin 문제**: data class는 모든 필드가 생성자 파라미터 → 무인자 생성자 없음
- **해결책**: jackson-module-kotlin 모듈 추가
- **동작 원리**: 리플렉션으로 생성자 파라미터 정보 획득 → 주 생성자 직접 호출
- **장점**: data class의 불변성 유지, 기본값 지원, null 안전성 활용
- **주의사항**: @JsonCreator 남용 금지, 생성자 여러 개면 모호성 발생

## 상세 내용

### Java의 역직렬화 메커니즘

**Jackson의 기본 전략**

Java에서 Jackson은 다음 순서로 역직렬화한다:

1. **무인자 생성자 호출**: 객체를 먼저 생성
2. **리플렉션으로 setter 호출**: JSON 값을 필드에 주입

```java
// Java POJO
public class User {
    private Long id;
    private String name;

    // 무인자 생성자 (필수)
    public User() {}

    // Jackson이 이 setter들을 호출
    public void setId(Long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
}
```

**Jackson의 역직렬화 과정**

```java
// 내부적으로 이런 순서
User user = new User();           // 1. 무인자 생성자 호출
user.setId(json.get("id"));       // 2. setter로 값 주입
user.setName(json.get("name"));   // 2. setter로 값 주입
```

**왜 무인자 생성자가 필요한가?**

리플렉션은 생성자 파라미터의 이름 정보를 기본적으로 읽을 수 없다.

```java
// 컴파일 후 바이트코드에서는 파라미터 이름이 사라짐
public User(Long arg0, String arg1) { ... }
// 원래: public User(Long id, String name)
```

따라서 Jackson은:
- 무인자 생성자로 "빈 껍데기" 객체 생성
- JSON 키와 setter 이름 매칭으로 값 주입

### Kotlin의 문제점

**data class는 무인자 생성자가 없다**

```kotlin
// Kotlin data class
data class User(
    val id: Long,
    val name: String
)

// 컴파일 후: 주 생성자만 존재
// public User(Long id, String name) { ... }
// 무인자 생성자 없음!
```

**불변 객체의 특성**

```kotlin
data class User(
    val id: Long,        // val = setter 없음
    val name: String     // val = setter 없음
)
```

- `val`은 생성자에서만 값 설정 가능
- setter가 없어서 생성 후 값 변경 불가
- Java 방식(무인자 생성자 + setter)으로는 역직렬화 불가능

### jackson-module-kotlin의 해결책

**의존성 추가**

```gradle
// build.gradle.kts
dependencies {
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
}
```

**모듈 등록**

```kotlin
// ObjectMapper 설정
val objectMapper = ObjectMapper().registerModule(KotlinModule())

// 또는 (더 간단)
val objectMapper = jacksonObjectMapper()

// Spring Boot는 자동 설정
```

**동작 원리**

jackson-module-kotlin은 다음과 같이 동작한다:

1. **리플렉션으로 생성자 파라미터 정보 획득**
   ```kotlin
   // Kotlin은 메타데이터에 파라미터 이름 보존
   constructor.parameters // [id: Long, name: String]
   ```

2. **JSON 키를 생성자 파라미터와 매칭**
   ```kotlin
   val json = """{"id": 123, "name": "Alice"}"""
   val id = json["id"]      // 123
   val name = json["name"]  // "Alice"
   ```

3. **주 생성자 직접 호출**
   ```kotlin
   // 내부적으로
   User(id = 123, name = "Alice")
   ```

**Java 방식과 비교**

| | Java | Kotlin (module-kotlin) |
|---|---|---|
| 생성 방식 | 무인자 생성자 | 주 생성자 직접 호출 |
| 값 주입 | setter | 생성자 파라미터 |
| 파라미터 정보 | 없음 | 메타데이터에 보존 |
| 불변성 | 어려움 | 자연스럽게 지원 |

### 기본값 지원

**Kotlin의 기본값이 그대로 동작**

```kotlin
data class User(
    val id: Long,
    val name: String,
    val email: String? = null,        // 기본값
    val age: Int = 0,                 // 기본값
    val active: Boolean = true        // 기본값
)

val json = """{"id": 1, "name": "Bob"}"""
val user = objectMapper.readValue<User>(json)

// User(id=1, name="Bob", email=null, age=0, active=true)
```

**Java에서는 불가능**

```java
// Java는 생성자 기본값 개념 없음
public User(Long id, String name, String email, Integer age, Boolean active) {
    this.id = id != null ? id : 0L;          // 수동 처리
    this.name = name != null ? name : "";    // 수동 처리
    // ...
}
```

### private 생성자도 가능

**리플렉션은 접근 제어를 무시**

```kotlin
data class User private constructor(
    val id: Long,
    val name: String
) {
    companion object {
        fun create(id: Long, name: String): User {
            require(id > 0) { "ID must be positive" }
            return User(id, name)
        }
    }
}

// Jackson은 private 생성자도 호출 가능
val json = """{"id": 1, "name": "Alice"}"""
val user = objectMapper.readValue<User>(json)  // 성공!
```

**주의사항**

- 팩토리 메서드의 검증 로직이 우회됨
- 역직렬화로 생성 시 유효성 검사 필요

## 실무 적용

### 1. 기본 data class

```kotlin
data class Order(
    val orderId: Long,
    val customerId: Long,
    val amount: Money,
    val status: OrderStatus = OrderStatus.PENDING,
    val createdAt: LocalDateTime = LocalDateTime.now()
)

// JSON → 객체
val json = """
{
    "orderId": 12345,
    "customerId": 67890,
    "amount": {"value": 10000, "currency": "KRW"}
}
"""

val order = objectMapper.readValue<Order>(json)
// status와 createdAt는 기본값 사용
```

### 2. sealed class 역직렬화

```kotlin
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonSubTypes(
    JsonSubTypes.Type(value = CardPayment::class, name = "card"),
    JsonSubTypes.Type(value = BankTransfer::class, name = "bank")
)
sealed class Payment {
    abstract val amount: Money
}

data class CardPayment(
    override val amount: Money,
    val cardNumber: String,
    val cvv: String
) : Payment()

data class BankTransfer(
    override val amount: Money,
    val accountNumber: String,
    val bankCode: String
) : Payment()

// JSON → sealed class
val json = """
{
    "type": "card",
    "amount": {"value": 50000, "currency": "KRW"},
    "cardNumber": "1234-5678-9012-3456",
    "cvv": "123"
}
"""

val payment = objectMapper.readValue<Payment>(json)
// CardPayment 타입으로 역직렬화
```

### 3. value class 처리

```kotlin
@JvmInline
value class UserId(val value: Long)

@JvmInline
value class Email(val value: String)

data class User(
    val id: UserId,
    val email: Email,
    val name: String
)

// Jackson 2.13+는 value class 지원
val json = """
{
    "id": 123,
    "email": "user@example.com",
    "name": "Alice"
}
"""

val user = objectMapper.readValue<User>(json)
```

### 4. 중첩 객체

```kotlin
data class Address(
    val zipCode: String,
    val city: String,
    val street: String
)

data class Customer(
    val id: Long,
    val name: String,
    val address: Address,                    // 중첩 객체
    val phoneNumbers: List<String> = emptyList()
)

val json = """
{
    "id": 1,
    "name": "Bob",
    "address": {
        "zipCode": "12345",
        "city": "Seoul",
        "street": "Gangnam-daero"
    }
}
"""

val customer = objectMapper.readValue<Customer>(json)
```

### 5. nullable 처리

```kotlin
data class UserProfile(
    val userId: Long,
    val nickname: String,
    val bio: String?,              // nullable
    val avatarUrl: String?         // nullable
)

// JSON에 값이 없으면 null
val json1 = """{"userId": 1, "nickname": "alice"}"""
val profile1 = objectMapper.readValue<UserProfile>(json1)
// bio = null, avatarUrl = null

// JSON에 명시적 null
val json2 = """{"userId": 1, "nickname": "alice", "bio": null}"""
val profile2 = objectMapper.readValue<UserProfile>(json2)
// bio = null
```

## 주의사항 및 트러블슈팅

### 1. 생성자가 여러 개인 경우

**문제 상황**

```kotlin
data class User(
    val id: Long,
    val name: String
) {
    // secondary 생성자
    constructor(id: Long) : this(id, "Unknown")
}
```

**해결 방법**

```kotlin
// @JsonCreator로 명시
data class User @JsonCreator constructor(
    @JsonProperty("id") val id: Long,
    @JsonProperty("name") val name: String
)
```

### 2. @JvmOverloads 주의

```kotlin
// ❌ 문제 발생 가능
data class User @JvmOverloads constructor(
    val id: Long,
    val name: String = "Unknown"
)

// 바이트코드에 여러 생성자 생성
// User(Long)
// User(Long, String)
```

**해결책**: jackson-module-kotlin은 기본적으로 주 생성자를 선택하지만, 명시적으로 지정하는 것이 안전

```kotlin
data class User constructor(
    val id: Long,
    val name: String = "Unknown"
)
```

### 3. 기본값 vs null

```kotlin
data class Config(
    val timeout: Int = 30,
    val retryCount: Int = 3
)

// JSON에 키가 없으면 기본값 사용
val json1 = """{}"""
val config1 = objectMapper.readValue<Config>(json1)
// Config(timeout=30, retryCount=3)

// JSON에 null이면 역직렬화 실패
val json2 = """{"timeout": null}"""
// 예외 발생! Int는 null 불가
```

**해결책**: nullable로 선언하고 기본값 처리

```kotlin
data class Config(
    val timeout: Int? = 30,
    val retryCount: Int? = 3
)
```

### 4. 알 수 없는 프로퍼티 처리

```kotlin
// JSON에 없는 필드가 있으면 기본적으로 예외
val json = """{"id": 1, "name": "Alice", "unknown": "value"}"""

// 해결 1: 전역 설정
objectMapper.configure(
    DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,
    false
)

// 해결 2: 어노테이션
@JsonIgnoreProperties(ignoreUnknown = true)
data class User(val id: Long, val name: String)
```

### 5. 불변성 보장

```kotlin
// ❌ 나쁜 예: var 사용
data class User(
    var id: Long,         // 변경 가능
    var name: String      // 변경 가능
)

// ✅ 좋은 예: val 사용
data class User(
    val id: Long,         // 불변
    val name: String      // 불변
)
```

## 금융권에서의 고려사항

- **불변성 필수**: 금융 데이터는 생성 후 변경되면 안 됨 (val 사용)
- **유효성 검증**: 역직렬화 후 반드시 도메인 규칙 검증 (init 블록 활용)
- **감사 로그**: 역직렬화된 객체 생성 시점 기록
- **버전 관리**: JSON 스키마 변경 시 하위 호환성 유지 (@JsonAlias 활용)
- **에러 처리**: 역직렬화 실패 시 명확한 에러 메시지와 함께 로깅

**예시**

```kotlin
data class Transaction(
    val transactionId: String,
    val amount: Money,
    val type: TransactionType
) {
    init {
        // 유효성 검증
        require(transactionId.isNotBlank()) {
            "Transaction ID must not be blank"
        }
        require(amount.value > 0) {
            "Transaction amount must be positive"
        }
    }
}
```


---

**출처**
- Jackson Documentation
- jackson-module-kotlin GitHub
