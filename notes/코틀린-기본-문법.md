---
tags: [kotlin, basic-syntax, programming-language]
---

## 한 줄 요약

코틀린은 간결한 문법, null 안전성, 함수형 프로그래밍 지원을 통해 자바보다 개선된 JVM 언어를 제공한다.

## 핵심 정리

- 함수를 최상위 수준에 정의 가능하며, 클래스 밖에서도 선언 가능
- `val`(불변)과 `var`(가변) 키워드로 변수 선언, 기본적으로 `val` 사용 권장
- `when`은 자바의 switch보다 강력하며, 분기 조건에 객체 사용 가능
- 스마트 캐스트로 타입 체크 후 자동 캐스팅
- 범위(range) 표현식으로 반복문을 간결하게 작성
- 예외는 모두 unchecked exception으로 처리

## 상세 내용

### 자바와의 주요 차이점

코틀린은 최상위 수준에 함수를 정의할 수 있어, 자바처럼 모든 메소드를 클래스 안에 넣을 필요가 없다.

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

주요 특징:
- 배열도 클래스로 처리되며 특별한 문법이 없음
- 세미콜론 생략 가능
- 모든 제어구조가 식(expression)이며, 대입은 문(statement)

### 식이 본문인 함수

```kotlin
/* 간소화 이전 */
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}

/* 식이 본문인 함수 - 타입 추론 가능 */
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 등호와 식으로 이루어진 함수를 **식이 본문인 함수**라고 함
- 타입 추론으로 리턴 타입 생략 가능

### 블록이 본문인 함수

중괄호로 감싼 함수는 **블록이 본문인 함수**이며, 반드시 리턴 타입을 명시해야 한다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

### 변수

코틀린은 타입 추론을 지원하며, 두 가지 변수 선언 키워드를 제공한다.

- `val` (value): 변경 불가능한 참조. 자바의 `final`에 해당. 한 번만 초기화 가능
- `var` (variable): 변경 가능한 참조. 자바의 일반 변수에 해당

```kotlin
/* val 변수의 조건부 초기화 */
val message: String
if (isSuccess()) {
    message = "Success"
} else {
    message = "Failed"
}
```

**주의사항:**
- `val` 변수는 참조 자체가 불변이지만, 참조하는 객체 내부의 값은 변경 가능

```kotlin
val lang = arrayListOf("Java")  /* 불변 참조 선언 */
lang.add("Kotlin")              /* 객체 내부 변경 가능 */
lang = arrayListOf("C")         /* 에러! 참조 변경 불가 */
```

- `var` 변수는 값 변경 가능하나, 초기화 시점의 변수 타입은 고정

```kotlin
var answer = 42
answer = "no answer"  /* 컴파일 에러! Type mismatch */
```

### 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if(args.size > 0) args[0] else "Kotlin"
    println("Hello, $name")
    println("Hello, ${name}")  /* 중괄호 사용 권장 */
}
```

- `$변수명` 형태로 문자열 템플릿 사용
- 중괄호 사용 `${변수명}`이 안전하고 권장됨 (특히 한글과 함께 사용 시)

### 클래스와 프로퍼티

자바의 장황한 코드를 코틀린에서 간결하게 표현:

```java
/* 자바 */
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

```kotlin
/* 코틀린 */
class Person(val name: String)
```

프로퍼티는 필드와 접근자를 대체:

```kotlin
class Person(
    val name: String,        /* 읽기전용 프로퍼티 */
    var isMarried: Boolean   /* 쓰기 가능한 프로퍼티 */
)

val person = Person("Bob", true)  /* new 키워드 불필요 */
println(person.name)
println(person.isMarried)
```

커스텀 접근자:

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() = height == width
}

val rect = Rectangle(41, 43)
println(rect.isSquare)  /* false */
```

### enum과 when

#### enum 선언

```kotlin
/* 간단한 enum */
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}

/* 프로퍼티와 메소드가 있는 enum */
enum class Color(
    val r: Int,
    val g: Int,
    val b: Int
) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    INDIGO(75, 0, 130),
    VIOLET(238, 130, 238);  /* 세미콜론 필수 */

    fun rgb() = (r * 256 + g) * 256 + b
}
```

#### when 식

`when`은 자바의 switch보다 강력한 분기문:

```kotlin
fun getMnemonic(color: Color) = when (color) {
    Color.RED -> "Richard"
    Color.ORANGE -> "Of"
    Color.YELLOW -> "York"
    Color.GREEN -> "Gave"
    Color.BLUE -> "Battle"
    Color.INDIGO -> "In"
    Color.VIOLET -> "Vain"
}

/* 여러 값을 한 분기에 사용 */
fun getWarmth(color: Color) = when (color) {
    Color.RED, Color.ORANGE, Color.YELLOW -> "warm"
    Color.GREEN -> "neutral"
    Color.BLUE, Color.INDIGO, Color.VIOLET -> "cold"
}
```

특징:
- `break` 불필요
- 여러 값을 쉼표로 구분하여 사용 가능
- 상수뿐만 아니라 임의의 객체도 분기 조건으로 사용 가능

### 스마트 캐스트와 when

```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr): Int = when (e) {
    is Num -> e.value  /* is로 타입 체크 후 자동 캐스팅 */
    is Sum -> eval(e.right) + eval(e.left)
    else -> throw IllegalArgumentException("Unknown expression")
}
```

### 루프

#### for 루프와 범위(range)

```kotlin
/* 범위를 사용한 for 루프 */
for (i in 1..100) {
    print(fizzBuzz(i))
}

/* 역순 및 증가값 지정 */
for (i in 100 downTo 1 step 2) {
    print(fizzBuzz(i))
}
```

#### 맵 이터레이션

```kotlin
val binaryReps = TreeMap<Char, String>()
for (c in 'A'..'F') {
    val binary = Integer.toBinaryString(c.toInt())
    binaryReps[c] = binary
}

for ((letter, binary) in binaryReps) {
    println("$letter = $binary")
}
```

#### 컬렉션 이터레이션

```kotlin
val list = arrayListOf("10", "11", "1001")
for ((index, element) in list.withIndex()) {
    println("$index: $element")
}
```

#### in으로 범위 검사

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c !in '0'..'9'

println(isLetter('q'))      /* true */
println(isNotDigit('x'))    /* true */
```

### 예외 처리

```kotlin
/* throw는 식이며 중괄호 필수 */
if (percentage !in 0..100) {
    throw IllegalArgumentException(
        "A percentage value must be between 0 and 100: $percentage"
    )
}
```

특징:
- `throw`는 식(expression)
- `new` 키워드 불필요
- **unchecked exception만 존재** - 예외를 잡지 않아도 됨
- `throws` 절이 없음

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 2장
