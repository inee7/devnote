---
tags: [concurrency, lock, atomic-operation, pessimistic-lock, optimistic-lock, distributed-lock]
---

## 한 줄 요약

동시성 제어는 상황에 따라 원자적 연산, DB 락, 분산 락 중에서 선택하며, 외부 연동이 있으면 비관적 락 또는 아웃박스 패턴을 사용한다.

## 핵심 정리

- 잠금(뮤텍스)은 한 번에 하나의 스레드만 실행 허용
- 세마포어는 동시 실행 스레드 수 제한
- 읽기-쓰기 잠금은 읽기는 동시 허용, 쓰기는 배타적 실행
- 원자적(Atomic) 연산으로 잠금 없이 동시성 제어 가능
- 비관적 락은 안전하지만 느리고, 낙관적 락은 빠르지만 재시도 발생
- 트랜잭션 중 외부 요청이 있으면 비관적 락 또는 아웃박스 패턴 사용
- 카운터 증감은 증분 쿼리(`SET count = count + 1`)로 원자적 처리

## 상세 내용

### 동시성 제어 기본 개념

#### 뮤텍스 (Mutex)

**정의**: 상호 배제(Mutual Exclusion)를 위한 잠금

```kotlin
val lock = ReentrantLock()

fun updateSharedResource() {
    lock.lock()
    try {
        // 한 번에 하나의 스레드만 실행
        sharedValue += 1
    } finally {
        lock.unlock()
    }
}
```

특징:
- 한 스레드가 잠금을 획득하면 다른 스레드는 대기
- 임계 영역(Critical Section) 보호

#### 세마포어 (Semaphore)

**정의**: 동시 실행 허용 스레드 수를 정한 잠금

```kotlin
val semaphore = Semaphore(3)  // 최대 3개 스레드 동시 실행

fun accessLimitedResource() {
    semaphore.acquire()
    try {
        // 최대 3개 스레드가 동시 실행 가능
        expensiveOperation()
    } finally {
        semaphore.release()
    }
}
```

사용 예:
- DB 커넥션 풀 (최대 연결 수 제한)
- API 호출 제한 (Rate Limiting)

#### 읽기-쓰기 잠금 (ReadWrite Lock)

**정의**: 읽기는 동시 허용, 쓰기는 배타적 실행

```kotlin
val rwLock = ReentrantReadWriteLock()

fun read(): String {
    rwLock.readLock().lock()
    try {
        // 여러 스레드가 동시에 읽기 가능
        return sharedData
    } finally {
        rwLock.readLock().unlock()
    }
}

fun write(value: String) {
    rwLock.writeLock().lock()
    try {
        // 쓰기는 배타적 (다른 읽기/쓰기 차단)
        sharedData = value
    } finally {
        rwLock.writeLock().unlock()
    }
}
```

특징:
- 읽기가 많고 쓰기가 적은 경우 효율적
- 쓸 때는 읽거나 다른 쓰기 불가
- 읽을 때 다른 쓰기 불가, 하지만 다른 읽기는 가능

### 원자적 연산 (Atomic Operations)

#### 잠금의 성능 문제

```kotlin
// 잠금 사용 → 느림
val lock = ReentrantLock()
var counter = 0

fun increment() {
    lock.lock()
    try {
        counter++
    } finally {
        lock.unlock()
    }
}
```

문제:
- 잠금 획득/해제 오버헤드
- 스레드 대기로 인한 성능 저하

#### 원자적 연산으로 해결

```kotlin
// AtomicInteger 사용 → 빠름
val counter = AtomicInteger(0)

fun increment() {
    counter.incrementAndGet()  // 원자적 증가
}
```

원리:
- CPU 레벨의 CAS(Compare-And-Swap) 명령 사용
- 잠금 없이 동시성 제어
- 여러 스레드가 동시에 변경해도 안전

사용 가능한 타입:
- `AtomicInteger`, `AtomicLong`, `AtomicBoolean`
- `AtomicReference<T>` (객체 참조)

### DB와 동시성 제어

#### 비관적 락 (Pessimistic Lock)

**원리**: 트랜잭션 시작 시 DB에 락을 걸어 다른 트랜잭션 차단

```kotlin
@Transactional
fun deductPoints(userId: Long, amount: Int) {
    // SELECT ... FOR UPDATE
    val user = userRepository.findByIdWithLock(userId)
        ?: throw UserNotFoundException()

    user.points -= amount
    userRepository.save(user)
}

// Repository
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT u FROM User u WHERE u.id = :id")
fun findByIdWithLock(@Param("id") id: Long): User?
```

특징:
- DB에 `SELECT ... FOR UPDATE` 쿼리 실행
- 다른 트랜잭션은 대기
- 락이 풀릴 때까지 블로킹

장점:
- 원자적 보장 (데이터 일관성 확실)
- 충돌 발생 시 재시도 불필요

단점:
- 대기 시간으로 인한 성능 저하
- 데드락 위험

#### 낙관적 락 (Optimistic Lock)

**원리**: 락을 걸지 않고, 변경 시 버전 확인으로 충돌 감지

```kotlin
@Entity
class User(
    @Id val id: Long,
    var points: Int,

    @Version  // 낙관적 락을 위한 버전 필드
    var version: Long = 0
)

@Transactional
fun deductPoints(userId: Long, amount: Int) {
    val user = userRepository.findById(userId)
        .orElseThrow { UserNotFoundException() }

    user.points -= amount
    userRepository.save(user)
    // version이 변경되었으면 OptimisticLockException 발생
}
```

동작 방식:
1. SELECT 시점에 version 읽기
2. UPDATE 시 `WHERE id = ? AND version = ?` 조건 추가
3. version이 변경되었으면 UPDATE 실패 → 예외 발생
4. 애플리케이션에서 재시도

장점:
- 대기 없어서 빠름
- 데드락 위험 없음

단점:
- 충돌 시 재시도 필요 (애플리케이션 복잡도 증가)
- 충돌이 잦으면 오히려 비효율적

#### 언제 어떤 락을 사용할까?

**비관적 락 사용 시기**
- 충돌이 자주 발생하는 경우
- 트랜잭션 중간에 외부 요청이 있는 경우 (중요!)
- 데이터 일관성이 최우선인 경우

```kotlin
// 외부 연동이 있을 때는 비관적 락
@Transactional
fun processPayment(orderId: Long) {
    val order = orderRepository.findByIdWithLock(orderId)
        ?: throw OrderNotFoundException()

    // 외부 결제 API 호출
    val result = paymentService.charge(order.amount)

    if (result.isSuccess) {
        order.status = OrderStatus.PAID
        orderRepository.save(order)
    }
}
```

이유:
- 낙관적 락을 쓰면 트랜잭션 중간에 다른 트랜잭션이 데이터 변경 가능
- 외부 요청은 성공했는데 DB는 롤백될 수 있음
- 비관적 락으로 트랜잭션 동안 데이터 고정

**낙관적 락 사용 시기**
- 충돌이 드문 경우
- 외부 연동 없이 DB 작업만 있는 경우
- 빠른 응답이 중요한 경우

외부 연동이 있지만 낙관적 락을 쓰고 싶다면:
- [[트랜잭션-아웃박스-패턴]] 적용하여 외부 연동 처리

### 분산 락 (Distributed Lock)

#### Redis 분산 락

**사용 시기**: 여러 서버가 공유 자원에 동시 접근하는 경우

```kotlin
class RedisLockService(
    private val redisTemplate: RedisTemplate<String, String>
) {
    fun executeWithLock(
        lockKey: String,
        timeout: Long = 10,
        block: () -> Unit
    ) {
        val acquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "locked", timeout, TimeUnit.SECONDS)

        if (acquired == true) {
            try {
                block()
            } finally {
                redisTemplate.delete(lockKey)
            }
        } else {
            throw LockAcquisitionException("Failed to acquire lock: $lockKey")
        }
    }
}

// 사용 예
fun processGlobalCounter() {
    redisLockService.executeWithLock("counter-lock") {
        val current = redisTemplate.opsForValue().get("counter")?.toInt() ?: 0
        redisTemplate.opsForValue().set("counter", (current + 1).toString())
    }
}
```

특징:
- DB 락보다 빠름
- 여러 서버 간 동시성 제어 가능
- TTL로 데드락 방지

더 강력한 구현:
- Redisson 라이브러리 사용 (분산 락 구현 내장)

### 카운터 증감 최적화

#### 문제: 동시에 카운터가 늘어나는 경우

```kotlin
// 비관적 락 사용 → 느림
@Transactional
fun incrementViewCount(postId: Long) {
    val post = postRepository.findByIdWithLock(postId)
        ?: throw PostNotFoundException()

    post.viewCount += 1
    postRepository.save(post)
}
```

성능 문제:
- 조회수가 많은 게시글은 락 경합 심함
- 대기 시간 증가

#### 해결: 증분 쿼리 (Increment Query)

```kotlin
@Modifying
@Query("UPDATE Post p SET p.viewCount = p.viewCount + 1 WHERE p.id = :id")
fun incrementViewCount(@Param("id") id: Long)

// 사용
fun incrementViewCount(postId: Long) {
    postRepository.incrementViewCount(postId)
    // 원자적으로 처리됨, 락 불필요
}
```

원리:
- `SET count = count + 1`은 DB에서 원자적으로 처리
- 락 없이 동시성 보장
- 성능 향상

**주의**: DB에 따라 원자적이지 않을 수 있으므로 확인 필요
- MySQL, PostgreSQL: 원자적 보장
- NoSQL은 DB마다 다름 → 문서 확인

### 논블로킹 I/O와 동시성

경량 스레드(Virtual Thread, Coroutine)도 한계가 있음:
- 스레드 수가 많아지면 컨텍스트 스위칭 증가
- CPU 코어 수보다 많은 스레드는 비효율

논블로킹 I/O 사용 시:
- 소수의 스레드로 많은 요청 처리
- 이벤트 루프 (Reactor, Event Loop) 활용
- I/O 대기 중에도 다음 작업 수행

## 실무 적용

### 동시성 제어 선택 가이드

1. **애플리케이션 레벨 (단일 서버)**
   - 잠금/세마포어: 간단한 동시성 제어
   - 원자적 연산: 카운터, 플래그 등

2. **DB 레벨 (여러 서버, 같은 DB)**
   - 비관적 락: 충돌 잦음, 외부 연동 있음
   - 낙관적 락: 충돌 적음, DB만 사용
   - 증분 쿼리: 카운터 증감

3. **분산 환경 (여러 서버, Redis)**
   - Redis 분산 락: 빠르고 유연
   - Redisson 권장 (분산 락 구현 제공)

### 체크리스트

- [ ] 동시성 이슈가 실제로 발생하는가?
- [ ] 충돌 빈도는 어느 정도인가?
- [ ] 외부 연동이 트랜잭션 내에 있는가?
- [ ] 성능과 안정성 중 무엇이 우선인가?
- [ ] 단일 서버인가, 분산 환경인가?

### 금융권에서의 고려사항

- 포인트, 잔액 등 금액 관련은 비관적 락 사용
- 외부 연동(결제 등)이 있으면 반드시 비관적 락 또는 아웃박스 패턴
- 낙관적 락 사용 시 재시도 로직 철저히 테스트
- 분산 락은 TTL 설정으로 데드락 방지
- 증분 쿼리 사용 시 DB 벤더별 원자성 확인

---

**출처**
- 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식 (최범균)
