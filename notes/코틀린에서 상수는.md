---
tags: [kotlin, constant, const, companion-object, best-practices, jvm]
---
# Kotlin 상수 (const)

## 한 줄 요약

Kotlin에서 상수는 최상위 수준에 `const val`로 선언하는 것이 권장되며, companion object보다 바이트코드 효율이 높고 명확하다.

## 핵심 정리

- **권장 방식**: 최상위 수준(top-level)에 `const val` 선언
- **네이밍 컨벤션**: 대문자와 언더스코어 사용 (예: `MY_CONSTANT`)
- **companion object 방식**: 가능하지만 불필요한 객체 생성으로 비효율적
- **타입 제약**: const는 원시 타입(primitive type)과 String만 가능
- **컴파일 타임 상수**: const val은 컴파일 시점에 값이 결정되어야 함
- **@JvmField**: 객체 타입 상수나 런타임 초기화가 필요한 경우 사용

## 상세 내용

### const val vs val

**const val (컴파일 타임 상수)**

```kotlin
const val MAX_COUNT = 100
const val API_URL = "https://api.example.com"
```

- 컴파일 시점에 값이 인라인됨
- 원시 타입(Int, Long, Float, Double, Boolean)과 String만 가능
- 함수 호출이나 객체 생성 결과는 할당 불가

**val (런타임 상수)**

```kotlin
val currentTime = System.currentTimeMillis()  // 런타임에 계산
val config = Config()  // 객체 생성
```

- 런타임에 값이 결정됨
- 모든 타입 사용 가능
- 함수 호출 결과나 객체 할당 가능

**차이점 비교**

| 특성 | const val | val |
|------|-----------|-----|
| 초기화 시점 | 컴파일 타임 | 런타임 |
| 사용 가능 타입 | 원시 타입, String | 모든 타입 |
| 함수 호출 결과 할당 | 불가 | 가능 |
| 바이트코드 | 값이 직접 인라인 | getter 호출 |
| 사용 위치 | 최상위, object, companion object | 모든 위치 |

### 선언 위치별 비교

#### 1. 최상위 수준 선언 (권장)

**클래스 파일과 같은 위치에 선언**

```kotlin
// OrderService.kt
private const val MAX_ORDER_QUANTITY = 100  // 이 파일 내부에서만 사용

class OrderService {
    fun validateQuantity(quantity: Int) {
        require(quantity <= MAX_ORDER_QUANTITY) {
            "주문 수량은 $MAX_ORDER_QUANTITY 를 초과할 수 없습니다"
        }
    }
}
```

**전용 상수 파일**

프로젝트 전역에서 사용하는 상수는 별도 파일로 관리:

```kotlin
// Constants.kt
package com.example.project

const val API_BASE_URL = "https://api.example.com"
const val API_TIMEOUT_SECONDS = 30L
const val MAX_RETRY_COUNT = 3
const val DEFAULT_PAGE_SIZE = 20
```

사용:

```kotlin
import com.example.project.API_BASE_URL

class ApiClient {
    private val baseUrl = API_BASE_URL
}
```

**장점**
- 불필요한 객체 생성 없음
- 바이트코드가 간결함 (public static final 필드로 변환)
- 명확한 스코프 관리 (private으로 파일 내부 제한 가능)

#### 2. companion object에 선언 (비권장)

```kotlin
class PaymentService {
    companion object {
        private const val COMMISSION_RATE = 0.03
        const val MAX_AMOUNT = 1_000_000  // public, PaymentService.MAX_AMOUNT로 접근
    }

    fun calculateCommission(amount: Int): Int {
        return (amount * COMMISSION_RATE).toInt()
    }
}

// 사용
val maxAmount = PaymentService.MAX_AMOUNT
```

**문제점**

바이트코드 분석:

```java
// Kotlin
companion object {
    const val MAX_AMOUNT = 1_000_000
}

// 생성되는 Java 바이트코드
public final class PaymentService {
    public static final int MAX_AMOUNT = 1000000;
    public static final Companion companion = new Companion();  // 불필요한 객체!

    public static final class Companion {
        // 빈 클래스지만 인스턴스가 생성됨
    }
}
```

companion object를 선언하면 **Companion 객체가 생성**되어 메모리 낭비가 발생한다.

#### 3. object 선언

```kotlin
object AppConfig {
    const val VERSION = "1.0.0"
    const val DEBUG = false
}

// 사용
println(AppConfig.VERSION)
```

companion object와 동일하게 불필요한 객체가 생성되므로 비권장.

#### 4. val without const (최악)

```kotlin
class Config {
    companion object {
        val API_URL = "https://api.example.com"  // const 없음
    }
}
```

**생성되는 바이트코드**

```java
public final class Config {
    private static final String API_URL = "https://api.example.com";
    public static final Companion companion = new Companion();

    public static final class Companion {
        // getter 메서드 생성!
        public final String getAPI_URL() {
            return Config.API_URL;
        }
    }
}
```

문제점:
1. Companion 객체 생성
2. getter 메서드 생성
3. 매번 메서드 호출 오버헤드

**성능 비교**

```kotlin
// 1. const val at top-level (최고 효율)
const val URL = "https://api.com"
// 바이트코드: public static final String URL = "https://api.com";

// 2. const val in companion object (중간)
companion object {
    const val URL = "https://api.com"
}
// 바이트코드: Companion 객체 생성 + public static final 필드

// 3. val in companion object (최악)
companion object {
    val URL = "https://api.com"
}
// 바이트코드: Companion 객체 + getter 메서드
```

### 네이밍 컨벤션

Kotlin의 상수 네이밍은 Java와 동일하게 **대문자와 언더스코어** 사용:

```kotlin
// ✅ 올바른 상수 네이밍
const val MAX_RETRY_COUNT = 3
const val DEFAULT_TIMEOUT_MS = 5000L
const val API_BASE_URL = "https://api.example.com"
const val COMMISSION_RATE = 0.03

// ❌ 잘못된 네이밍
const val maxRetryCount = 3  // camelCase 사용 금지
const val default_timeout_ms = 5000L  // 소문자 사용 금지
```

### 타입 제약과 const

**const 사용 가능한 타입**

```kotlin
const val INT_VALUE: Int = 100
const val LONG_VALUE: Long = 100L
const val FLOAT_VALUE: Float = 3.14f
const val DOUBLE_VALUE: Double = 3.14
const val BOOLEAN_VALUE: Boolean = true
const val STRING_VALUE: String = "text"
```

**const 사용 불가능한 경우**

```kotlin
// ❌ 컴파일 에러: 함수 호출 결과
const val CURRENT_TIME = System.currentTimeMillis()

// ❌ 컴파일 에러: 객체 생성
const val DEFAULT_CONFIG = Config()

// ❌ 컴파일 에러: 배열
const val NUMBERS = intArrayOf(1, 2, 3)

// ❌ 컴파일 에러: 컬렉션
const val ITEMS = listOf("a", "b", "c")
```

### @JvmField 사용

**언제 사용하는가?**

const를 사용할 수 없는 경우 (객체 타입, 런타임 초기화) `@JvmField`를 사용:

```kotlin
object DatabaseConfig {
    @JvmField
    val DEFAULT_POOL_SIZE = Runtime.getRuntime().availableProcessors()  // 런타임 계산

    @JvmField
    val SUPPORTED_DRIVERS = listOf("postgresql", "mysql", "oracle")  // 컬렉션
}
```

**바이트코드**

```java
// Kotlin
@JvmField
val DEFAULT_POOL_SIZE = 10

// Java 바이트코드
public static final int DEFAULT_POOL_SIZE = 10;  // getter 없이 public static final
```

**@JvmField의 역할**
- companion object나 object의 프로퍼티를 **public static final 필드**로 노출
- getter 메서드 생성을 방지
- Java에서 접근 시 `Config.INSTANCE.getPoolSize()` 대신 `Config.POOL_SIZE`로 직접 접근 가능

**주의사항**

```kotlin
// ❌ const와 @JvmField 동시 사용 불가
@JvmField const val VALUE = 100  // 컴파일 에러

// ✅ const는 이미 public static final이므로 불필요
const val VALUE = 100

// ✅ @JvmField는 객체 타입이나 런타임 값에 사용
@JvmField val config = Config()
```

**성능 비교**

```kotlin
object Config {
    // 1. const val: 가장 빠름 (컴파일 타임 인라인)
    const val TIMEOUT = 5000

    // 2. @JvmField val: 빠름 (getter 없음)
    @JvmField val poolSize = Runtime.getRuntime().availableProcessors()

    // 3. val: 느림 (매번 getter 호출)
    val retryCount = 3
}
```

## 실무 적용

### 1. 상수 파일 구조

```kotlin
// config/Constants.kt
package com.example.config

// API 관련
const val API_BASE_URL = "https://api.example.com"
const val API_VERSION = "v1"
const val API_TIMEOUT_SECONDS = 30L

// 페이징 관련
const val DEFAULT_PAGE_SIZE = 20
const val MAX_PAGE_SIZE = 100

// 비즈니스 규칙
const val MAX_ORDER_QUANTITY = 999
const val MIN_ORDER_AMOUNT = 1000
const val COMMISSION_RATE = 0.03
```

### 2. 도메인별 상수 그룹핑

```kotlin
// domain/order/OrderConstants.kt
package com.example.domain.order

const val MAX_ORDER_QUANTITY = 999
const val MIN_ORDER_AMOUNT = 1000
const val ORDER_EXPIRY_MINUTES = 30L

// domain/payment/PaymentConstants.kt
package com.example.domain.payment

const val MAX_PAYMENT_AMOUNT = 10_000_000
const val COMMISSION_RATE = 0.03
const val REFUND_DEADLINE_DAYS = 7
```

### 3. 환경별 상수 관리

**권장하지 않음** (상수는 컴파일 타임 값):

```kotlin
// ❌ 환경별로 다른 값을 가진 상수는 부적절
const val API_URL = if (BuildConfig.DEBUG) "dev-api.com" else "api.com"
```

**대신 설정 클래스 사용**:

```kotlin
// ✅ 환경별 설정은 런타임 값으로 관리
object AppConfig {
    @JvmField
    val apiUrl = if (BuildConfig.DEBUG) {
        "https://dev-api.example.com"
    } else {
        "https://api.example.com"
    }

    // 또는 외부 설정에서 주입
    @JvmField
    val apiUrl = System.getenv("API_URL") ?: "https://api.example.com"
}
```

### 4. Java 상호 운용

**Kotlin 상수**:

```kotlin
// Constants.kt
const val MAX_COUNT = 100

object Config {
    @JvmField
    val instance = Config()
}
```

**Java에서 사용**:

```java
// const val은 자동으로 public static final
int max = ConstantsKt.MAX_COUNT;

// @JvmField는 getter 없이 직접 접근
Config config = Config.instance;

// @JvmField 없으면 getter 사용
Config config = Config.INSTANCE.getInstance();  // 비효율적
```

## 주의사항

### 1. const는 최상위 또는 object에만 사용 가능

```kotlin
// ✅ 가능
const val TOP_LEVEL = 1

object MyObject {
    const val IN_OBJECT = 2
}

class MyClass {
    companion object {
        const val IN_COMPANION = 3
    }
}

// ❌ 불가능
class MyClass {
    const val IN_CLASS = 4  // 컴파일 에러

    fun myFunction() {
        const val IN_FUNCTION = 5  // 컴파일 에러
    }
}
```

### 2. const val은 다른 const val로만 초기화 가능

```kotlin
const val BASE_URL = "https://api.com"

// ✅ 다른 const val 사용 가능
const val API_V1_URL = "$BASE_URL/v1"  // 문자열 템플릿 가능

// ❌ 함수 호출 불가
const val CURRENT_TIME = System.currentTimeMillis()  // 컴파일 에러

// ❌ 변수 사용 불가
val version = 1
const val API_URL = "$BASE_URL/v$version"  // 컴파일 에러
```

### 3. companion object 상수의 가시성

```kotlin
class Service {
    companion object {
        private const val INTERNAL_CONSTANT = 1  // 클래스 내부에서만 사용
        const val PUBLIC_CONSTANT = 2  // Service.PUBLIC_CONSTANT로 외부 접근 가능
    }
}

// 외부에서
println(Service.PUBLIC_CONSTANT)  // OK
println(Service.INTERNAL_CONSTANT)  // 컴파일 에러
```

### 4. 매직 넘버 제거

```kotlin
// ❌ 매직 넘버
fun calculateCommission(amount: Int): Int {
    return (amount * 0.03).toInt()  // 0.03이 무엇을 의미하는지 불명확
}

// ✅ 명명된 상수
private const val COMMISSION_RATE = 0.03

fun calculateCommission(amount: Int): Int {
    return (amount * COMMISSION_RATE).toInt()
}
```

### 5. 상수 변경의 영향 범위

**const val 변경 시 주의**:

```kotlin
// Library 모듈
const val DEFAULT_TIMEOUT = 5000

// App 모듈
fun request() {
    // DEFAULT_TIMEOUT 값이 인라인되어 컴파일됨
    Thread.sleep(DEFAULT_TIMEOUT)
}
```

Library 모듈에서 `DEFAULT_TIMEOUT`을 변경하면:
- Library 모듈만 재컴파일해서는 변경 반영 안 됨
- **App 모듈도 재컴파일 필요** (const val은 컴파일 타임에 인라인)

**해결책**:
- 자주 변경되는 값은 `val` 사용 (getter를 통해 접근)
- 또는 외부 설정 파일에서 관리

## 금융권에서의 고려사항

- **매직 넘버 금지**: 모든 비즈니스 규칙 값은 명명된 상수로 관리
- **감사 추적**: 상수 변경 이력을 Git으로 명확히 추적
- **문서화**: 각 상수의 비즈니스 의미와 변경 근거를 주석으로 기록
- **중앙 관리**: 금융 규제 관련 상수(한도, 수수료율 등)는 별도 파일로 관리
- **타입 안전성**: 금액은 상수가 아닌 Value Object(Money 등)로 표현 권장
- **컴파일 타임 검증**: 잘못된 상수 값을 컴파일 타임에 검증 가능하도록 설계

**예시**

```kotlin
// financial/Limits.kt
package com.example.financial

/**
 * 주문 한도 상수
 * 근거: 2025년 1월 금융감독원 가이드라인
 * 최종 변경: 2025-01-05
 */
const val MAX_SINGLE_ORDER_AMOUNT = 10_000_000  // 단건 최대 금액

/**
 * 수수료율
 * 근거: 내부 정책 문서 FIN-2025-001
 */
const val STANDARD_COMMISSION_RATE = 0.03  // 표준 수수료율 3%
const val PREMIUM_COMMISSION_RATE = 0.01   // 프리미엄 수수료율 1%

/**
 * 환불 정책
 */
const val REFUND_DEADLINE_DAYS = 7  // 환불 가능 기한 (영업일 기준)
```

## 관련 노트

- [[코틀린-클래스와-상속]] (companion object 개념)
- [[코틀린-기본-문법]] (val/var 차이)
- [[가변성-제한]] (val 사용 권장)
- [[변수-스코프-최소화]]

---

**출처**
- [Constants in Kotlin - Stack Overflow](https://stackoverflow.com/questions/44038721/constants-in-kotlin-whats-a-recommended-way-to-create-them)
- Kotlin in Action (Dmitry Jemerov, Svetlana Isakova)
