---
tags: [kotlin, 고차함수, 인라인함수, 함수형프로그래밍]
---

## 한 줄 요약

코틀린의 고차함수와 인라인 함수는 함수형 프로그래밍 스타일을 효율적으로 지원하며, 성능 오버헤드 없이 람다를 활용할 수 있게 한다.

## 핵심 정리

- 고차함수는 함수를 인자로 받거나 반환하는 함수
- 함수 타입 `(Int, Int) -> Int`으로 람다를 변수에 저장 가능
- `inline` 함수로 람다 호출 오버헤드 제거
- `noinline`으로 특정 람다만 인라인하지 않도록 제어
- `return` 사용 시 non-local return, `return@label`로 local return
- 자바의 함수형 인터페이스와 자연스러운 상호운용

## 상세 내용

### 고차함수

고차함수는 함수를 인자로 받거나 반환하는 함수다.

```kotlin
/* 함수 타입 선언 */
val sum: (Int, Int) -> Int = { x, y -> x + y }

println(sum(1, 2))  /* 3 */

/* 고차함수 정의 */
fun twoAndThree(operation: (Int, Int) -> Int) {
    val result = operation(2, 3)
    println("The result is $result")
}

twoAndThree { a, b -> a + b }  /* The result is 5 */
twoAndThree { a, b -> a * b }  /* The result is 6 */
```

#### 함수 타입

```kotlin
/* 반환 타입이 있는 함수 타입 */
val canReturnNull: (Int, Int) -> Int? = { x, y -> null }

/* null이 될 수 있는 함수 타입 */
val funOrNull: ((Int, Int) -> Int)? = null

/* 파라미터 이름 지정 */
fun performRequest(
    url: String,
    callback: (code: Int, content: String) -> Unit
) {
    /* ... */
}

val url = "http://kotl.in"
performRequest(url) { code, content -> /* ... */ }
```

#### 디폴트 값과 null이 될 수 있는 함수 타입

```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = "",
    transform: ((T) -> String)? = null
): String {
    val result = StringBuilder(prefix)

    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        val str = transform?.invoke(element)
            ?: element.toString()
        result.append(str)
    }

    result.append(postfix)
    return result.toString()
}

val letters = listOf("Alpha", "Beta")
println(letters.joinToString())  /* Alpha, Beta */
println(letters.joinToString { it.toLowerCase() })  /* alpha, beta */
println(letters.joinToString(separator = "! ", postfix = "! ",
    transform = { it.toUpperCase() }))  /* ALPHA! BETA!  */
```

### 함수를 반환하는 함수

```kotlin
enum class Delivery { STANDARD, EXPEDITED }

class Order(val itemCount: Int)

fun getShippingCostCalculator(
    delivery: Delivery
): (Order) -> Double {
    if (delivery == Delivery.EXPEDITED) {
        return { order -> 6 + 2.1 * order.itemCount }
    }

    return { order -> 1.2 * order.itemCount }
}

val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
println("Shipping costs ${calculator(Order(3))}")  /* Shipping costs 12.3 */
```

### 인라인 함수

```kotlin
/* inline 함수 */
inline fun <T> synchronized(lock: Lock, action: () -> T): T {
    lock.lock()
    try {
        return action()
    } finally {
        lock.unlock()
    }
}

val l = ReentrantLock()
synchronized(l) {
    /* ... */
}
```

인라인 함수 특징:
- 컴파일 시 함수 본문이 호출 지점에 직접 삽입됨
- 람다 호출의 무명 클래스 생성 오버헤드 제거
- 표준 라이브러리의 많은 함수가 `inline`으로 선언됨

#### noinline

```kotlin
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    /* ... */
}
```

### 컬렉션 인라인 함수

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(Person("Alice", 29), Person("Bob", 31))

println(people.filter { it.age < 30 })  /* [Person(name=Alice, age=29)] */

/* 체이닝 - 중간 리스트 생성 */
println(people.filter { it.age > 30 }
              .map(Person::name))  /* [Bob] */

/* 시퀀스로 최적화 가능 (대량 데이터의 경우) */
```

### 자원 관리 인라인 함수

```kotlin
/* use 함수 - 자바의 try-with-resources */
fun readFirstLineFromFile(path: String): String {
    BufferedReader(FileReader(path)).use { br ->
        return br.readLine()
    }
}
```

### 고차함수 안에서의 흐름 제어

#### non-local return

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(Person("Alice", 29), Person("Bob", 31))

fun lookForAlice(people: List<Person>) {
    people.forEach {
        if (it.name == "Alice") {
            println("Found!")
            return  /* lookForAlice 함수를 종료 */
        }
    }
    println("Alice is not found")
}

lookForAlice(people)  /* Found! */
```

#### local return

```kotlin
fun lookForAlice(people: List<Person>) {
    people.forEach label@{
        if (it.name == "Alice") return@label  /* 람다만 종료 */
    }
    println("Alice might be somewhere")
}

/* 함수 이름을 레이블로 사용 */
fun lookForAlice(people: List<Person>) {
    people.forEach {
        if (it.name == "Alice") return@forEach
    }
    println("Alice might be somewhere")
}

lookForAlice(people)  /* Alice might be somewhere */
```

#### 무명 함수

```kotlin
fun lookForAlice(people: List<Person>) {
    people.forEach(fun (person) {
        if (person.name == "Alice") return  /* 무명 함수 종료 */
        println("${person.name} is not Alice")
    })
}

lookForAlice(people)
/* Bob is not Alice
   Alice might be somewhere */
```

---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 8장
