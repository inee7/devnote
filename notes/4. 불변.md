---
tags: [oop, immutable, functional-programming, side-effect]
---

# 불변

## 한 줄 요약

불변 객체는 부수효과를 방지하고 예측 가능한 코드를 만들며, 값 변경 시에는 새 인스턴스를 생성한다

## 핵심 정리

- 부수효과 원인: 가변 인스턴스, 매개변수 변경, 전역변수 변경, 외부 데이터 조작
- 이상적인 함수: 상태를 매개변수로 받고 변경하지 않으며 값만 반환
- 인스턴스 변수는 불변으로 만들어 영향 전달 차단
- 객체지향에서는 클래스 내부에서 동일 인스턴스 변수 사용 허용
- 값 변경 시 새 인스턴스 생성

## 상세 내용

### 부수효과란?

함수가 외부 상태를 변경하거나 예상치 못한 영향을 주는 것을 부수효과(Side Effect)라고 한다.

**부수효과 발생 원인:**
1. **가변 인스턴스 사용**: 객체의 상태를 직접 변경
2. **매개변수 변경**: 전달받은 매개변수를 수정
3. **전역변수 변경**: 함수 밖의 변수를 변경
4. **외부 데이터 조작**: 파일, I/O, 네트워크 등

### 부수효과를 막는 방법

**이상적인 함수:**
- 상태를 매개변수로 받는다
- 상태를 변경하지 않는다
- 값을 리턴하기만 한다

```java
// ❌ 부수효과 있음
class Counter {
    int count = 0;

    void increment() {
        count++;  // 상태를 직접 변경
    }
}

// ✅ 부수효과 없음
class Counter {
    final int count;

    Counter(int count) {
        this.count = count;
    }

    Counter increment() {
        return new Counter(count + 1);  // 새 인스턴스 반환
    }
}
```

### 인스턴스 변수는 사용하면 안 되나?

**아니다.** 인스턴스 변수는 불변으로 만들어 영향이 전달되지 않게 할 수 있다.

객체지향 언어는 **클래스 내부에서 동일 인스턴스 변수를 사용하는 것을 허용**한다.

```java
class Money {
    private final int amount;  // 불변
    private final Currency currency;  // 불변

    Money add(Money other) {
        // 인스턴스 변수를 사용하지만 불변이므로 안전
        return new Money(this.amount + other.amount, this.currency);
    }
}
```

### 불변 객체에서 값 변경하기

불변이라면 값을 변경할 때 **인스턴스를 새로 생성**해야 한다.

```java
Money money = new Money(1000, Currency.KRW);
Money increased = money.add(new Money(500, Currency.KRW));

// money는 그대로 1000원
// increased는 새로운 인스턴스로 1500원
```

## 실무 적용

### 불변의 장점

1. **스레드 안전**: 여러 스레드에서 동시 접근해도 안전
2. **예측 가능**: 생성 후 상태가 변하지 않아 디버깅 쉬움
3. **캐싱 가능**: 값이 변하지 않으므로 안전하게 재사용 가능
4. **버그 감소**: 의도치 않은 상태 변경 방지

### Kotlin의 불변성

```kotlin
data class Money(
    val amount: Int,  // val = 불변
    val currency: Currency
) {
    fun add(other: Money) = Money(amount + other.amount, currency)
}

// 컬렉션도 불변으로
val immutableList = listOf(1, 2, 3)
val mutableList = mutableListOf(1, 2, 3)  // 명시적으로 가변 선언
```

### 주의사항

- 모든 것을 불변으로 만들 필요는 없음
- 성능이 중요한 부분에서는 가변 객체 사용 고려
- JPA Entity 같은 경우 프레임워크 제약으로 가변 필드 필요

## 관련 노트

- [[3.2 성숙한 클래스로 성장시키기]]
- [[5장. 응집도]]
- [[1.3 로직과 떨어진 데이터 클래스]]

#immutable #oop #functional-programming