---
tags: [oop, design, anti-pattern, data-class]
---

# 로직과 떨어진 데이터 클래스

## 한 줄 요약

데이터와 로직이 분리된 데이터 클래스는 응집도를 낮추고 버그, 중복 코드, 수정 누락을 유발한다

## 핵심 정리

- 데이터 클래스: 데이터만 갖고 로직은 다른 클래스에 있는 구조
- 문제점: 코드 중복, 수정 누락, 가독성 저하, NPE, 유효성 검증 부재
- 낮은 응집도: 데이터와 로직이 멀리 떨어져 있음
- 해결: 데이터와 로직을 같은 클래스에 배치 ([[3.2 성숙한 클래스로 성장시키기]])

## 상세 내용

### 데이터 클래스란?

클래스 밖에서도 자유롭게 변경할 수 있는 구조에 데이터를 갖고 있기만 하고 로직은 다른 클래스에 있는 클래스를 데이터 클래스라고 부른다.
~~~java
public class contractAmount {
	public int amountIncludingTax;
	public BigDecimal salesTaxRate;
}

public class ContractManager { 
	public ContractAmount contractAmount; 
	
	public void conclude() {
		//생략
		contractAmount = new ContractAmount();
		contractAmount.amountIncludingTax = 1000;
		//생략
	}
}
~~~
![](resources/images/logic-data-class-separation-sketch.png)

이처럼 데이터 클래스 하나를 여러 Manager에서 로직을 들고 있으면 버그가 발생할 확률이 높아진다.

**응집도가 낮은 구조:** 데이터와 로직 등이 분산되어 있는 것을 응집도가 낮은 구조라고 한다.

### 데이터 클래스의 문제점

#### 1. 코드 중복

관련된 코드가 서로 멀리 떨어져 있으면 데이터 클래스만 보고 "아직 구현되지 않은 로직"이라 생각하고 중복 코드를 만들게 된다.

#### 2. 수정 누락

코드 중복이 많으면 사양 변경 시 중복된 코드를 모두 고쳐야 한다. 하지만 일부를 놓칠 수 있기에 결국 버그를 유발한다.

#### 3. 가독성 저하

분산된 코드는 중복된 코드를 포함해서 관련된 정보를 찾는 데 시간이 오래 걸린다.

#### 4. 초기화되지 않는 상태 (NPE)

```java
ContractAmount amount = new ContractAmount();
amount.salesTaxRate.toString(); // NullPointerException 발생
```

필드가 초기화되지 않은 상태에서 사용하면 NPE가 발생할 수 있다.

#### 5. 잘못된 값 할당

생성자에서 유효성 검사를 하지 않으면, 추후 로직에서 검증 로직이 필요하게 된다. 검증 로직이 분산되면 누락될 위험이 있다.

## 실무 적용

### 해결 방법

데이터 클래스 문제는 **데이터와 로직을 같은 클래스에 배치**하여 해결한다:

1. 생성자에서 유효성 검증 ([[3.2 성숙한 클래스로 성장시키기]])
2. 데이터를 조작하는 메서드를 같은 클래스에 배치
3. 불변 객체로 만들어 예상치 못한 변경 방지 ([[4. 불변]])
4. 응집도 높이기 ([[5장. 응집도]])

### 관련 개념

- Manager 클래스에 로직이 모이는 것도 같은 문제 (트랜잭션 스크립트 패턴)
- 도메인 주도 설계(DDD)에서는 이를 빈약한 도메인 모델(Anemic Domain Model)이라 부름

## 관련 노트

- [[3.2 성숙한 클래스로 성장시키기]]
- [[4. 불변]]
- [[5장. 응집도]]
- [[단일 책임 원칙]]

#oop #design #anti-pattern