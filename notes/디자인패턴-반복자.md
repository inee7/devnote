---
tags: [design-pattern, kotlin, behavioral]
---

# 반복자 패턴

## 한 줄 요약

컬렉션의 내부 구조를 노출하지 않고 순차적으로 요소에 접근할 수 있게 하는 패턴

## 핵심 정리

- 합성 패턴을 완성시키는 패턴
- `operator fun iterator()`를 구현해야 함
- `Iterator<T>` 인터페이스를 구현하는 익명 객체를 반환
- `fun hasNext(): Boolean`, `fun next(): T` 구현 필요

## 상세 내용

### 기본 구조

다음 코드는 반복자 메서드가 없어 실행되지 않는다:

```kotlin
for (trooper in platoon) {
    println(trooper)
}
```

반복자 메서드를 가져야 한다. `operator fun iterator()`를 구현해야 한다.

### 구현 예제

```kotlin
class Squad(private val units: List<Trooper>) : Trooper() {
    constructor(vararg units: Trooper) : this(units.toList())

    operator fun iterator(): Iterator<Trooper> {
        return TrooperIterator(units)
    }
}

class TrooperIterator(private val units: List<Trooper>) : Iterator<Trooper> {
    private var i = 0
    private var iterator: Iterator<Trooper> = this

    override fun hasNext(): Boolean {
        if (i >= units.size) {
            return false
        }
        if (i == units.size - 1) {
            if (iterator != this) {
                return iterator.hasNext()
            }
        }
        return true
    }

    override fun next(): Trooper {
        if (iterator != this) {
            if (iterator.hasNext()) {
                return iterator.next()
            } else {
                i++
                iterator = this
            }
        }

        return when (val e = units[i]) {
            is Squad -> {
                iterator = e.iterator()
                this.next()
            }
            else -> {
                i++
                e
            }
        }
    }
}
```

### 특징

- `operator` 키워드로 for-in 루프 사용 가능
- 중첩된 구조도 재귀적으로 순회 가능
- `hasNext()`와 `next()` 구현 필수
- 컬렉션의 내부 구조를 숨기면서 순회 제공

### 합성 패턴과의 관계

합성 패턴 그 자체로는 다소 불완전하다는 사실이 반복자 패턴으로 완성시킬 수 있다.

---

**출처**
- 코틀린 디자인 패턴
