---
tags: [oop, srp, solid, design-principle, actor, responsibility]
---
# 단일 책임 원칙 (SRP: Single Responsibility Principle)

## 한 줄 요약

단일 책임 원칙은 "하나의 일만 해야 한다"가 아니라 "변경의 이유가 하나, 오직 하나뿐이어야 한다"는 의미이며, 하나의 모듈은 하나의 Actor(동일한 책임을 기대하는 사용자 집합)에게만 책임져야 한다.

## 핵심 정리

- **흔한 오해**: "하나의 모듈은 하나의 일만 해야 한다" (함수 수준 원칙과 혼동)
- **진짜 의미**: "변경의 이유가 하나, 오직 하나뿐이어야 한다"
- **Actor 개념**: 특정 모듈에 동일한 책임을 기대하는 사용자들의 집합
- **재정의**: "하나의 모듈은 하나의 Actor에 대해서만 책임져야 한다"
- **위배 시 문제**: 우발적 중복, Merge Conflict, 버그 증가, 개발 속도 저하
- **적용 수준**: Class/Method(SRP) → Component(CCP) → Architecture(Axis of Change)

## 상세 내용

### SRP의 흔한 오해

**잘못된 이해**
- "하나의 모듈은 하나의 일만 해야 한다"
- "하나의 함수는 하나의 일만 해야 한다"와 혼동

**문제점**
- 위 원칙은 함수 설계의 저수준 원칙
- SRP는 더 높은 수준의 원칙

### SRP의 진짜 정의

> 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

**변경의 이유**
- 사용자가 이 모듈에 기대하는 책임이 변화할 때
- 사용자가 둘 이상이면 변경 이유도 둘 이상

**예시**
1. A 사용자가 기대하는 책임이 변화 → 변경 이유 1
2. B 사용자가 기대하는 책임이 변화 → 변경 이유 2

### Actor 개념

**Actor란?**
- 특정 모듈에 **동일한 책임을 기대하는 사용자들의 집합**
- 여러 사용자가 있어도 같은 책임을 기대하면 하나의 Actor

**SRP 재정의**

> 단일 모듈은 하나의 Actor에 대해서만 책임져야 한다.

### SRP 위배 시 발생하는 문제

#### 1. 우발적 중복 (Accidental Duplication)

**시나리오**

```java
class Employee {
    // Actor 1: 회계팀
    Money calculatePay() {
        return new Money(checkTime() * hourlyRate);
    }

    // Actor 2: 인사팀
    Hours reportHours() {
        return checkTime();
    }

    // 공유 메서드
    private Hours checkTime() {
        // 시간 계산 로직
    }
}
```

| Actor | Responsibility |
|-------|----------------|
| 회계팀 | calculatePay |
| 인사팀 | reportHours |

**문제**
- 회계팀이 급여 계산을 위해 `checkTime()` 로직 변경
- `reportHours()`가 `checkTime()`을 사용한다는 사실 간과
- 인사팀의 근무시간 보고 기능이 의도치 않게 변경됨

**원인**
- 하나의 모듈에 두 개 이상의 Actor 존재
- 서로 다른 Actor가 같은 코드에 의존

#### 2. Merge Conflict

**시나리오**
- 회계팀과 인사팀이 동시에 Employee 모듈 체크아웃
- 각자 `checkTime()` 관련 로직 수정
- Merge 시 Conflict 발생

**문제**
- Conflict 해결 과정에서 버그 양산
- 개발 속도 저하
- 코드 품질 악화

**해결책**
- 서로 다른 Actor를 뒷받침하는 코드를 분리

### SRP 적용 수준

SRP는 다양한 수준에서 다른 형태로 나타난다.

#### Class/Method 수준
- 단일 책임 원칙 (SRP)
- 하나의 클래스는 하나의 Actor에 대해서만 책임

#### Component 수준
- 공통 폐쇄 원칙 (Common Closure Principle, CCP)
- 같은 이유로 변경되는 것들은 함께 묶고, 다른 이유로 변경되는 것들은 분리

#### Architecture 수준
- 변경의 축 (Axis of Change)
- 아키텍처 경계를 정의하는 기준

## 실무 적용

### 안티패턴: God Class

```kotlin
// ❌ 나쁜 예: 여러 Actor에게 책임
@Service
class UserService(
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val paymentService: PaymentService
) {
    // Actor 1: 인증팀
    fun authenticate(credentials: Credentials): User {
        // 인증 로직
    }

    // Actor 2: 마케팅팀
    fun sendPromotionEmail(userId: Long) {
        // 이메일 발송 로직
    }

    // Actor 3: 결제팀
    fun processPayment(userId: Long, amount: Money) {
        // 결제 처리 로직
    }

    // Actor 4: 통계팀
    fun generateUserReport(userId: Long): Report {
        // 리포트 생성 로직
    }
}
```

**문제점**
- 4개의 Actor가 하나의 클래스에 의존
- 한 팀의 요구사항 변경이 다른 팀에 영향
- Merge Conflict 빈번
- 테스트 어려움

### 올바른 분리

```kotlin
// ✅ 좋은 예: Actor별로 분리

// Actor 1: 인증팀
@Service
class AuthenticationService(
    private val userRepository: UserRepository
) {
    fun authenticate(credentials: Credentials): User {
        // 인증 로직
    }
}

// Actor 2: 마케팅팀
@Service
class PromotionService(
    private val userRepository: UserRepository,
    private val emailService: EmailService
) {
    fun sendPromotionEmail(userId: Long) {
        // 이메일 발송 로직
    }
}

// Actor 3: 결제팀
@Service
class PaymentService(
    private val paymentGateway: PaymentGateway
) {
    fun processPayment(userId: Long, amount: Money) {
        // 결제 처리 로직
    }
}

// Actor 4: 통계팀
@Service
class ReportService(
    private val userRepository: UserRepository
) {
    fun generateUserReport(userId: Long): Report {
        // 리포트 생성 로직
    }
}
```

**장점**
- 각 서비스가 하나의 Actor에게만 책임
- 독립적인 변경 가능
- Merge Conflict 최소화
- 테스트 용이

### Domain Model에서의 적용

```kotlin
// ❌ 나쁜 예: Order가 여러 책임
class Order(
    val items: List<OrderItem>,
    val customer: Customer
) {
    // Actor 1: 주문팀
    fun calculateTotal(): Money {
        return items.sumOf { it.price }
    }

    // Actor 2: 회계팀
    fun generateInvoice(): Invoice {
        // 송장 생성 로직
    }

    // Actor 3: 물류팀
    fun prepareShipping(): ShippingLabel {
        // 배송 준비 로직
    }

    // Actor 4: 마케팅팀
    fun sendConfirmationEmail() {
        // 확인 이메일 발송
    }
}
```

```kotlin
// ✅ 좋은 예: 책임 분리

// Actor 1: 주문팀
class Order(
    val items: List<OrderItem>,
    val customer: Customer
) {
    fun calculateTotal(): Money {
        return items.sumOf { it.price }
    }
}

// Actor 2: 회계팀
class InvoiceGenerator {
    fun generate(order: Order): Invoice {
        // 송장 생성 로직
    }
}

// Actor 3: 물류팀
class ShippingService {
    fun prepareShipping(order: Order): ShippingLabel {
        // 배송 준비 로직
    }
}

// Actor 4: 마케팅팀
class OrderNotificationService {
    fun sendConfirmation(order: Order) {
        // 확인 이메일 발송
    }
}
```

### 판단 기준

**질문**
1. 이 클래스를 변경해야 하는 이유가 몇 개인가?
2. 어떤 사용자들이 이 클래스에 관심을 가지는가?
3. 다른 팀의 요구사항 변경이 이 클래스에 영향을 주는가?

**신호**
- Merge Conflict가 자주 발생
- 한 기능 변경이 예상치 못한 부작용 발생
- 클래스가 너무 크고 복잡
- private 메서드가 여러 public 메서드 그룹에서만 사용됨

## 금융권에서의 고려사항

- **Actor 식별**: 금융 업무는 팀별로 명확히 구분됨 (결제팀, 정산팀, 리스크팀 등)
- **감사 추적**: 각 Actor별 변경 이력을 명확히 추적 필요
- **규제 대응**: 규제 변경 시 영향 범위를 최소화하기 위해 SRP 필수
- **장애 격리**: 한 Actor의 문제가 다른 Actor에 영향 최소화
- **배포 독립성**: Actor별로 독립적인 배포 가능하도록 설계


---

**출처**
- Clean Architecture (Robert C. Martin)
