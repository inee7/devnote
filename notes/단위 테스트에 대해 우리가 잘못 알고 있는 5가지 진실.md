---
tags: [unit-test, test-code, testing-strategy, mocking, refactoring-resistance, code-coverage]
---
# 단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실

## 한 줄 요약

단위 테스트의 진짜 목표는 버그 찾기가 아니라 지속 가능한 성장이며, 커버리지 수치보다 리팩토링 저항성이 중요하고, 목 객체는 애플리케이션 경계에만 사용해야 한다.

## 핵심 정리

- **지속 가능한 성장**: 테스트의 본질은 버그 찾기가 아니라 장기적 개발 속도 유지
- **커버리지의 함정**: 높은 커버리지가 좋은 테스트를 보장하지 않음 (나쁜 긍정적 지표)
- **리팩토링 저항성**: 구현 세부사항이 아닌 관찰 가능한 동작(observable behavior)을 검증
- **목 객체 원칙**: 시스템 간(inter-system) 통신에만 사용, 시스템 내부(intra-system) 통신에는 사용 금지
- **복잡성 격리**: 클래스가 아닌 복잡성을 격리하고, 복잡한 코드일수록 협력자를 줄여야 함

## 상세 내용

### 1. 테스트의 진짜 목표: 지속 가능한 성장

테스트의 근본적인 목표는 버그 찾기가 아니라 **소프트웨어 프로젝트의 지속 가능한 성장**이다.

**소프트웨어 엔트로피(Software Entropy)**
- 코드베이스 변경 시마다 시스템의 무질서도(엔트로피)는 증가
- 테스트가 없으면 개발 속도가 급격히 저하
- 좋은 테스트는 엔트로피 증가를 역전시키는 안전망

**테스트의 역할**
- 새 기능 추가 시 기존 기능의 정상 동작 보장
- 리팩토링 시 안전한 코드 개선 가능
- 장기적인 개발 속도 유지

### 2. 코드 커버리지의 함정

**커버리지 지표의 이중성**
- **좋은 부정적 지표**: 커버리지가 낮으면 테스트가 부족하다는 명확한 신호
- **나쁜 긍정적 지표**: 커버리지가 높아도 테스트 품질을 보장하지 않음

**목표 수치의 위험성**
- 특정 수치(80%, 100%)를 목표로 삼으면 왜곡된 인센티브 발생
- 중요한 로직 테스트 대신 커버리지 숫자 채우기에 집중
- 코드를 '실행'하는 것과 결과를 '검증'하는 것은 다른 문제

**원칙**
- 커버리지는 지표일 뿐, 목표가 되어선 안 됨
- 비즈니스 핵심 로직에 집중
- 의미 없는 테스트보다 적더라도 가치 있는 테스트

### 3. 리팩토링에 대한 저항성

**거짓 양성(False Positive) 문제**
- 기능은 정상 동작하는데 내부 구현 변경으로 테스트 실패
- 깨지기 쉬운(brittle) 테스트는 팀의 신뢰를 무너뜨림
- 리팩토링을 주저하게 만들어 코드 품질 저하 유발

**좋은 테스트의 원칙**
- 구현 세부사항(implementation details)을 테스트하지 말 것
- 관찰 가능한 동작(observable behavior)을 검증할 것
- 최종 사용자와 비즈니스에 의미 있는 결과에 집중

**예시**

```kotlin
// ❌ 나쁜 예: 내부 구현 검증
verify(repository).save(any())

// ✅ 좋은 예: 결과 검증
assertThat(result.id).isNotNull()
assertThat(result.status).isEqualTo(Status.ACTIVE)
```

### 4. 목(Mock) 객체의 올바른 사용

**두 종류의 통신**
- **시스템 내부(intra-system) 통신**: 내부 클래스 간 상호작용 → 구현 세부사항
- **시스템 간(inter-system) 통신**: 외부 시스템과의 상호작용 → 관찰 가능한 동작

**핵심 원칙**
- 시스템 내부 통신을 목으로 테스트하면 리팩토링 시 깨짐
- 외부 시스템과의 통신은 계약(contract)이므로 목 사용 정당
- **목은 애플리케이션 경계를 넘나드는 통신에만 사용**

**올바른 사용**
```kotlin
// ✅ 외부 시스템과의 통신 검증
verify(emailClient).send(any())
verify(paymentGateway).charge(amount)
```

**잘못된 사용**
```kotlin
// ❌ 내부 도메인 클래스 간 통신 검증
verify(orderCalculator).calculate(any())
verify(discountPolicy).apply(any())
```

### 5. 격리해야 할 것은 복잡성

**코드 분류 프레임워크 (2x2 사분면)**

두 축을 기준으로 코드를 분류:
- **세로 축**: 복잡성/도메인 중요도
- **가로 축**: 협력자 수

**네 가지 유형**

1. **도메인 모델/알고리즘 (좌상단)**
   - 복잡도: 높음, 협력자: 적음
   - 핵심 비즈니스 로직, 복잡한 계산
   - **단위 테스트의 최고 가치 영역**
   - 테스트 비용: 낮음, 회귀 방지: 높음

2. **사소한 코드 (좌하단)**
   - 복잡도: 낮음, 협력자: 적음
   - 간단한 데이터 클래스, 속성
   - 테스트할 가치가 거의 없음

3. **컨트롤러 (우하단)**
   - 복잡도: 낮음, 협력자: 많음
   - 여러 컴포넌트 조율 역할
   - 단위 테스트보다 소수의 통합 테스트로 검증

4. **과도하게 복잡한 코드 (우상단)**
   - 복잡도: 높음, 협력자: 많음
   - **설계 문제의 신호 → 리팩토링 필요**
   - **험블 객체(Humble Object) 패턴**으로 분리
     - 복잡한 로직 → 좌상단 (단위 테스트)
     - 조율 로직 → 우하단 (통합 테스트)

**핵심 원칙**
- 코드가 복잡하거나 중요할수록 협력자를 줄여야 함
- 클래스가 아닌 복잡성을 격리

## 실무 적용

### 테스트 작성 우선순위

1. **도메인 모델/알고리즘**: 단위 테스트 집중
2. **컨트롤러/서비스 흐름**: 통합 테스트
3. **핵심 경로**: 최소한의 E2E 테스트
4. **사소한 코드**: 테스트 생략

### Spring Boot에서의 적용

**도메인 모델 단위 테스트**
```kotlin
@Test
fun `프로모션 할인 계산`() {
    val promotion = Promotion(discountRate = 0.1)
    val price = Money(10000)

    val discounted = promotion.apply(price)

    assertThat(discounted.amount).isEqualTo(9000)
}
```

**컨트롤러는 통합 테스트**
```kotlin
@SpringBootTest
@AutoConfigureMockMvc
class OrderIntegrationTest {
    @Test
    fun `주문 생성 전체 흐름`() {
        mockMvc.post("/orders") {
            contentType = MediaType.APPLICATION_JSON
            content = orderRequest
        }.andExpect {
            status { isCreated() }
            jsonPath("$.orderId") { exists() }
        }
    }
}
```

### 금융권에서의 고려사항

- **지속 가능성 최우선**: 규제 변경과 기능 추가가 잦은 환경에서 테스트는 필수
- **커버리지 맹신 금지**: 숫자보다 핵심 거래 로직의 품질이 중요
- **리팩토링 저항성**: 레거시 개선 시 테스트가 발목을 잡으면 안 됨
- **목 객체 신중 사용**: 외부 연동(은행, 카드사)만 목으로 대체
- **복잡성 격리**: 금융 계산 로직은 협력자를 최소화하고 단위 테스트


---

**출처**
- Unit Testing Principles, Practices, and Patterns (Vladimir Khorikov)
