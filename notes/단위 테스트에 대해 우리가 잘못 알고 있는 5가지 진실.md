---
tags: [unit-test, test-code, testing-strategy, mocking]
---
# 단위 테스트에 대해 우리가 잘못 알고 있는 5가지 진실

### 소개: 테스트는 왜 우리를 배신하는가?

우리는 당연하게 단위 테스트를 작성하지만, 이 테스트들이 정말 프로젝트를 더 나아지게 만들고 있을까요, 아니면 그저 유지보수 부담만 가중시키고 있을까요? 단위 테스트는 프로젝트의 지속 가능한 성장을 가능하게 하는 안전망이 되어야 합니다. 새로운 기능을 추가하거나 코드를 리팩토링할 때, 잘 만들어진 테스트는 기존 기능이 고장 나지 않았다는 확신을 줍니다. 그러나 잘못 작성된 테스트는 오히려 프로젝트의 발목을 잡는 덫이 될 수 있습니다. 이 글을 통해 테스트의 진정한 가치를 재정의할 5가지 핵심 통찰을 제시하고자 합니다.

--------------------------------------------------------------------------------

### 1. 테스트의 진짜 목표는 버그 찾기가 아니라 '지속 가능한 성장'이다

단위 테스트의 주된 목표가 단순히 버그를 찾는 것이라고 생각하기 쉽지만, 이는 부수적인 효과일 뿐입니다. 물론 테스트는 버그를 찾아내지만, 이는 2차적인 이점이지 우리의 핵심 전략 목표는 아닙니다. 테스트의 근본적인 목표는 소프트웨어 프로젝트의 **'지속 가능한 성장'**을 가능하게 하는 것입니다. 테스트가 없는 프로젝트는 초반에는 빠르게 진행되는 것처럼 보이지만, 시간이 지날수록 '소프트웨어 엔트로피(software entropy)' 현상으로 인해 개발 속도가 급격히 저하됩니다.

코드베이스에 무언가를 변경할 때마다 시스템의 무질서, 즉 엔트로피는 증가합니다. 테스트는 이러한 경향을 뒤집는 데 도움을 줍니다.

좋은 테스트 스위트는 이러한 엔트로피 증가 경향을 뒤집는 강력한 도구입니다. 새로운 기능을 추가하거나 기존 코드를 리팩토링할 때, 테스트는 기존 기능이 여전히 잘 동작한다는 확신을 주는 '안전망' 역할을 합니다. 이는 단순한 버그 수정 활동을 넘어, 장기적인 개발 속도를 유지하고 프로젝트가 꾸준히 성장할 수 있도록 만드는 핵심 전략입니다.

### 2. '코드 커버리지 100%'라는 위험한 함정

코드 커버리지는 테스트 스위트가 소스 코드의 몇 줄을 실행했는지 보여주는 지표입니다. 브랜치 커버리지는 한 걸음 더 나아가 `if`나 `switch` 같은 분기문의 각 경로를 얼마나 테스트했는지 측정합니다. 이 지표들은 테스트 스위치의 품질을 측정하는 데 '좋은 부정적 지표'는 될 수 있지만, '나쁜 긍정적 지표'이기도 합니다. 즉, 커버리지가 낮다면 명백히 테스트가 부족하다는 신호지만, 높다고 해서 테스트 품질이 좋다는 보장은 전혀 없습니다.

특정 커버리지 수치(예: 80% 또는 100%)를 목표로 삼는 것은 개발팀에 '삐뚤어진 인센티브'를 제공하는 위험한 행위입니다. 개발자들은 비즈니스적으로 중요한 로직을 테스트하는 데 집중하는 대신, 단순히 커버리지 숫자를 높이기 위해 의미 없는 테스트를 양산하게 됩니다. 테스트가 단순히 코드를 '실행'하는 것과, 그 결과를 실제로 '검증'하는 것은 완전히 다른 차원의 이야기입니다.

이 개념을 병원 환자의 체온에 비유해볼 수 있습니다. 높은 체온은 문제의 '지표'일 뿐, 에어컨으로 억지로 체온을 낮추는 것이 '목표'가 될 수는 없습니다. 코드 커버리지도 마찬가지입니다. 커버리지 수치는 유용한 지표일 뿐, 그 자체가 목표가 되어서는 안 됩니다.

### 3. 좋은 테스트의 잊혀진 덕목: '리팩토링에 대한 저항성'

좋은 테스트의 핵심 속성 중 하나는 '리팩토링에 대한 저항성'이며, 이는 테스트가 '거짓 양성(false positive)'을 얼마나 적게 발생시키는지로 측정됩니다. 리팩토링이란 기능적 변경 없이 코드의 내부 구조를 개선하는 행위입니다. 그런데 기능은 완벽히 정상 동작함에도 불구하고, 단지 내부 구현이 바뀌었다는 이유만으로 테스트가 실패하는 경우가 바로 거짓 양성 문제입니다.

이러한 '깨지기 쉬운(brittle) 테스트'는 개발팀의 신뢰를 좀먹습니다. 잘못된 경고가 반복되면 개발자들은 테스트 스위트 자체를 불신하게 되고, 결국 리팩토링을 주저하게 만듭니다. 이는 코드 품질의 점진적인 저하로 이어집니다. 좋은 테스트는 코드의 '구현 세부 정보'에 얽매이지 않아야 합니다. 대신 최종 사용자와 비즈니스에 의미 있는 **'관찰 가능한 동작(observable behavior)'**의 결과에 집중해야 합니다.

잘못된 경고를 계속 울리는 테스트 스위트에 대한 신뢰를 잃게 되면, 개발자들은 점차 리팩토링을 주저하게 되고 코드베이스는 악화될 수밖에 없습니다.

### 4. 목(Mock) 객체의 진짜 위험성: 내부 통신을 테스트하는 순간 깨져버린다

목(Mock) 객체는 테스트를 취약하게 만드는 주범이 될 수 있습니다. 이를 제대로 이해하려면 두 종류의 통신을 구분해야 합니다. 첫째는 시스템 내부 클래스 간의 통신인 **'시스템 내부(intra-system) 통신'**이고, 둘째는 외부 시스템(데이터베이스, 외부 API, 메시지 버스 등)과의 통신인 **'시스템 간(inter-system) 통신'**입니다.

시스템 내부 클래스 간의 상호작용은 '구현 세부 정보'에 해당합니다. 따라서 이 부분을 목으로 테스트하면 리팩토링 시 테스트가 아주 쉽게 깨지는 원인이 됩니다. 반면, 외부 시스템과의 통신은 우리 애플리케이션의 '관찰 가능한 동작'이자 외부와의 명백한 **'계약(contract)'**입니다. 이 계약은 안정적으로 유지되어야 하므로, 우리 시스템의 관찰 가능한 동작의 일부가 됩니다. 따라서 이 경계를 넘나드는 통신을 검증할 때 목을 사용하는 것은 정당하고 매우 유용합니다. 핵심 지침은 이것입니다: "목은 애플리케이션 경계를 넘나드는 통신을 검증할 때만 사용해야 합니다."

- **올바른 사용:** 외부 시스템(예: 이메일 발송, 결제 게이트웨이)과의 상호작용 검증
- **잘못된 사용:** 내 도메인 모델의 다른 클래스와의 상호작용 검증

### 5. 격리해야 할 것은 클래스가 아니라 '복잡성'이다

어떤 코드를 집중적으로 테스트해야 할까요? 모든 코드가 동일한 테스트 가치를 갖지는 않습니다. 아키텍트로서 우리는 코드를 분석하고 테스트 전략을 수립하기 위한 프레임워크가 필요합니다. 코드를 두 가지 핵심 축으로 나누어 2x2 사분면 모델로 분석할 수 있습니다.

1. **세로 축: 복잡성/도메인 중요도(Complexity/Domain Significance)**
2. **가로 축: 협력자 수(Number of Collaborators)**

이 두 축을 기준으로 코드를 네 가지 유형으로 분류할 수 있습니다.

- **도메인 모델 및 알고리즘 (좌상단):** 복잡성은 높지만 협력자는 적은 코드입니다. 비즈니스의 핵심 로직과 복잡한 계산이 여기에 해당합니다. 이곳이 바로 단위 테스트가 가장 큰 가치를 발휘하는 영역입니다. 테스트 작성 비용은 낮고, 회귀(regression) 방지 효과는 매우 높습니다.
- **사소한 코드 (좌하단):** 복잡성도 낮고 협력자도 적은 코드입니다. 간단한 데이터 클래스나 속성들이 여기에 속하며, 테스트할 가치가 거의 없습니다.
- **컨트롤러 (우하단):** 복잡성은 낮지만 협력자는 많은 코드입니다. 다른 여러 컴포넌트들의 작업을 조율하는 역할을 합니다. 단위 테스트보다는 소수의 통합 테스트로 검증하는 것이 효율적입니다.
- **과도하게 복잡한 코드 (우상단):** 복잡성도 높고 협력자도 많은 코드입니다. 이는 코드 설계의 '위험 신호'이며 테스트하기 매우 어렵습니다. 이런 코드를 발견하면 리팩토링이 필요합니다. **험블 객체(Humble Object) 패턴**을 사용해 복잡한 로직(좌상단으로 이동하여 테스트 대상)과 오케스트레이션(우하단으로 이동)으로 분리해야 합니다.

코드가 더 중요하거나 복잡할수록, 더 적은 수의 협력자를 가져야 합니다.

--------------------------------------------------------------------------------

### 결론: 더하는 테스트가 아닌, 빼는 테스트의 가치

우리는 단위 테스트의 진정한 목표가 버그 찾기를 넘어 '지속 가능한 성장'을 가능하게 하는 것임을 확인했습니다. 우리는 코드 커버리지라는 수치에 맹목적으로 의존하는 것이 얼마나 위험한지, 좋은 테스트는 반드시 리팩토링에 저항해야 한다는 것을 깨달았습니다. 또한, 목 객체는 애플리케이션 경계를 넘는 '계약'을 검증할 때만 현명하게 사용되어야 하며, 우리의 소중한 테스트 자원은 '복잡하고 중요한' 코드에 집중되어야 함을 배웠습니다.

이 다섯 가지 통찰은 하나의 통합된 철학으로 귀결됩니다. 진정한 테스트는 무언가를 더하는 행위(더 많은 테스트, 더 높은 커버리지)가 아니라, 전략적으로 빼고 집중하는 행위라는 것입니다. 프로젝트의 성장을 저해하는 가치 없는 테스트는 과감히 제거하고, 소프트웨어의 심장부인 핵심 로직에 노력을 집중하는 것. 이것이 바로 테스트의 진정한 가치입니다.

마지막으로 스스로에게 이 질문을 던져보시기 바랍니다. "당신의 테스트 스위트에 가장 가치 있는 변화는 새로운 테스트를 추가하는 것일까요, 아니면 당신의 발목을 잡는 테스트를 과감히 삭제하는 것일까요?"