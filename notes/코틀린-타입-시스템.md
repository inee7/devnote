---
tags: [kotlin, type-system, null-safety, primitive-types]
---

## 한 줄 요약

코틀린의 타입 시스템은 null 안전성을 컴파일 시점에 보장하고, 원시 타입과 참조 타입을 자연스럽게 통합한다.

## 핵심 정리

- null이 될 수 있는 타입을 명시적으로 구분 (`String` vs `String?`)
- 안전한 호출(`?.`), 엘비스 연산자(`?:`), null 아님 단언(`!!`) 제공
- 원시 타입과 래퍼 타입을 구분하지 않고 통일된 인터페이스 제공
- `Any`는 모든 타입의 최상위 타입, `Unit`은 void 역할
- `Nothing` 타입으로 정상 종료되지 않는 함수 표현
- 읽기 전용 컬렉션과 변경 가능한 컬렉션 구분

## 상세 내용

### null 가능성

#### null이 될 수 있는 타입

```kotlin
/* 코틀린 - null 불가 */
fun strLen(s: String) = s.length

strLen(null)  /* ERROR: null can not be a value of non-null type String */

/* null 허용 - 타입 뒤에 ? 추가 */
fun strLenSafe(s: String?) = ...
```

특징:
- 기본적으로 모든 타입은 null이 될 수 없음
- null을 허용하려면 타입 이름 뒤에 `?` 필수
- null 가능 타입은 직접 메소드 호출 불가

```kotlin
/* if 검사를 통해 null 처리 */
fun strLenSafe(s: String?): Int =
    if (s != null) s.length else 0

val x: String? = null
println(strLenSafe(x))  /* 0 */
println(strLenSafe("abc"))  /* 3 */
```

#### 안전한 호출 연산자: ?.

```kotlin
/* 안전한 호출 */
s?.toUpperCase()  /* s가 null이면 null 반환, 아니면 toUpperCase() 호출 */

/* 프로퍼티 접근 */
class Employee(val name: String, val manager: Employee?)

fun managerName(employee: Employee): String? = employee.manager?.name

val ceo = Employee("Da Boss", null)
val developer = Employee("Bob Smith", ceo)

println(managerName(developer))  /* Da Boss */
println(managerName(ceo))  /* null */

/* 안전한 호출 연쇄 */
class Person(val name: String, val company: Company?)
class Company(val name: String, val address: Address?)
class Address(val streetAddress: String, val zipCode: Int,
              val city: String, val country: String)

fun Person.countryName(): String {
    val country = this.company?.address?.country
    return if (country != null) country else "Unknown"
}
```

#### 엘비스 연산자: ?:

```kotlin
/* 엘비스 연산자로 디폴트 값 지정 */
fun strLenSafe(s: String?): Int = s?.length ?: 0

println(strLenSafe("abc"))  /* 3 */
println(strLenSafe(null))  /* 0 */

fun Person.countryName() = company?.address?.country ?: "Unknown"

/* throw와 함께 사용 */
fun printShippingLabel(person: Person) {
    val address = person.company?.address
        ?: throw IllegalArgumentException("No address")

    with (address) {
        println(streetAddress)
        println("$zipCode $city, $country")
    }
}
```

#### 안전한 캐스트: as?

```kotlin
/* 안전한 캐스트로 equals 구현 */
class Person(val firstName: String, val lastName: String) {
    override fun equals(o: Any?): Boolean {
        val otherPerson = o as? Person ?: return false

        return otherPerson.firstName == firstName &&
            otherPerson.lastName == lastName
    }

    override fun hashCode(): Int =
        firstName.hashCode() * 37 + lastName.hashCode()
}

val p1 = Person("Dmitry", "Jemerov")
val p2 = Person("Dmitry", "Jemerov")

println(p1 == p2)  /* true */
println(p1.equals(42))  /* false */
```

#### null 아님 단언: !!

```kotlin
/* null 아님 단언 */
fun ignoreNulls(s: String?) {
    val sNotNull: String = s!!
    println(sNotNull.length)
}

ignoreNulls(null)  /* kotlin.KotlinNullPointerException */

/* 피해야 할 사용법 */
person.company!!.address!!.country  /* 어디서 예외가 발생했는지 알 수 없음 */
```

#### let 함수

```kotlin
fun sendEmailTo(email: String) {
    println("Sending email to $email")
}

/* let으로 null 체크 후 함수 호출 */
var email: String? = "yole@example.com"
email?.let { sendEmailTo(it) }  /* Sending email to yole@example.com */

email = null
email?.let { sendEmailTo(it) }  /* 실행되지 않음 */

/* 여러 null 체크는 if 사용 권장 */
```

#### 나중에 초기화할 프로퍼티: lateinit

```kotlin
/* lateinit 사용하지 않은 경우 */
class MyTest {
    private var myService: MyService? = null

    @Before fun setUp() {
        myService = MyService()
    }

    @Test fun testAction() {
        Assert.assertEquals("foo", myService!!.performAction())
    }
}

/* lateinit 사용 */
class MyTest {
    private lateinit var myService: MyService

    @Before fun setUp() {
        myService = MyService()
    }

    @Test fun testAction() {
        Assert.assertEquals("foo", myService.performAction())
    }
}
```

#### null이 될 수 있는 타입 확장

```kotlin
/* null 가능 타입에 대한 확장 함수 */
fun verifyUserInput(input: String?) {
    if (input.isNullOrBlank()) {
        println("Please fill in the required fields")
    }
}

verifyUserInput(" ")  /* Please fill in the required fields */
verifyUserInput(null)  /* Please fill in the required fields */

/* isNullOrBlank 구현 */
fun String?.isNullOrBlank(): Boolean =
    this == null || this.isBlank()
```

#### 타입 파라미터의 null 가능성

```kotlin
/* 타입 파라미터는 기본적으로 null 가능 */
fun <T> printHashCode(t: T) {
    println(t?.hashCode())
}

printHashCode(null)  /* T는 Any?로 추론 */

/* non-null 타입으로 제한 */
fun <T : Any> printHashCode(t: T) {
    println(t.hashCode())
}

printHashCode(null)  /* ERROR */
printHashCode(42)  /* 42 */
```

### 원시 타입

#### Int, Boolean 등

```kotlin
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
```

특징:
- 원시 타입과 래퍼 타입 구분 없음
- 대부분 자바 `int`로 컴파일됨
- 제네릭 클래스에서는 `java.lang.Integer`로 컴파일됨

#### null이 될 수 있는 원시 타입

```kotlin
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
        if (age == null || other.age == null)
            return null
        return age > other.age
    }
}

println(Person("Sam", 35).isOlderThan(Person("Amy", 42)))  /* false */
println(Person("Sam", 35).isOlderThan(Person("Jane")))  /* null */
```

#### 숫자 변환

```kotlin
/* 자동 변환 불가 */
val i = 1
val l: Long = i  /* ERROR: type mismatch */

/* 명시적 변환 필요 */
val l: Long = i.toLong()

/* 변환 함수 */
val x = 1
println(x.toLong() in listOf(1L, 2L, 3L))  /* true */
```

### 최상위 타입

#### Any, Any?

```kotlin
val answer: Any = 42  /* 자동 박싱 */
```

특징:
- `Any`는 모든 non-null 타입의 최상위 타입
- `Any?`는 모든 타입의 최상위 타입
- 내부적으로 `java.lang.Object`로 컴파일됨

#### Unit

```kotlin
fun f(): Unit { ... }
fun f() { ... }  /* Unit 생략 가능 */

/* 제네릭에서 Unit 활용 */
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() {
        /* return 없어도 Unit 자동 반환 */
    }
}
```

#### Nothing

```kotlin
/* 정상 종료되지 않는 함수 */
fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}

fail("Error occurred")

/* 엘비스 연산자와 함께 사용 */
val address = company.address ?: fail("No address")
println(address.city)
```

### 컬렉션과 배열

#### 읽기 전용과 변경 가능한 컬렉션

```kotlin
fun <T> copyElements(
    source: Collection<T>,
    target: MutableCollection<T>
) {
    for (item in source) {
        target.add(item)
    }
}

val source: Collection<Int> = arrayListOf(3, 5, 7)
val target: MutableCollection<Int> = arrayListOf(1)

copyElements(source, target)
println(target)  /* [1, 3, 5, 7] */
```

주의:
- `Collection`은 읽기 전용이지만 Thread-safe하지 않음
- 다른 참조가 같은 컬렉션을 변경할 수 있음

#### 배열

```kotlin
fun main(args: Array<String>) {
    for (i in args.indices) {
        println("Argument $i is: ${args[i]}")
    }
}

/* 배열 생성 */
val letters = Array<String>(26) { i -> ('a' + i).toString() }
println(letters.joinToString(""))  /* abcdefghijklmnopqrstuvwxyz */

/* 원시 타입 배열 */
val fiveZeros = IntArray(5)
val fiveZerosToo = intArrayOf(0, 0, 0, 0, 0)
val squares = IntArray(5) { i -> (i + 1) * (i + 1) }
```


---

**출처**
- Kotlin in Action (드미트리 제메로프, 스베트라나 이사코바), 6장
