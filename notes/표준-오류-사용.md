---
tags: [kotlin, exception, effective-kotlin, best-practices, error-handling]
---

## 한 줄 요약

사용자 정의 예외보다 표준 예외(IllegalArgumentException, IllegalStateException 등)를 사용하면 코드의 이해도가 높아지고 유지보수가 쉬워진다.

## 핵심 정리

**표준 오류 사용의 장점**
- 널리 알려진 예외라 더 쉽게 이해 가능
- API 사용자가 예외의 의미를 즉시 파악
- 문서화가 잘 되어 있음
- 불필요한 예외 클래스 생성 방지

**주요 표준 예외**
- IllegalArgumentException: 잘못된 인자
- IllegalStateException: 잘못된 상태
- IndexOutOfBoundsException: 인덱스 범위 초과
- UnsupportedOperationException: 지원하지 않는 연산
- NoSuchElementException: 요소가 없음
- ConcurrentModificationException: 동시 수정 금지 위반

**사용자 정의 예외를 만들어야 할 때**
- 비즈니스 예외 (복구 가능한 예외)
- 도메인 특화 예외 필요 시
- 추가 컨텍스트 정보가 필요할 때

## 상세 내용

### 표준 예외를 사용해야 하는 이유

**1. 이해도 향상**

```kotlin
// ❌ 사용자 정의 예외 - 의미를 알기 어려움
throw InvalidUserAgeException("나이는 0보다 커야 합니다")

// ✅ 표준 예외 - 의미가 명확
throw IllegalArgumentException("나이는 0보다 커야 합니다")
```

표준 예외는 개발자들이 이미 잘 알고 있어서 추가 학습 비용이 없다.

**2. 일관성**

```kotlin
// ❌ 팀마다 다른 예외
throw UserValidationException()  // A팀
throw InvalidUserException()     // B팀
throw UserErrorException()       // C팀

// ✅ 표준 예외로 통일
throw IllegalArgumentException("Invalid user")
```

**3. 문서화**

표준 예외는 Kotlin/Java 공식 문서에 이미 설명되어 있다. 별도 문서를 작성할 필요가 없다.

### 주요 표준 예외와 사용 예시

#### IllegalArgumentException

메서드의 인자가 적절하지 않을 때 사용한다.

```kotlin
fun setAge(age: Int) {
    require(age > 0) { "나이는 0보다 커야 합니다" }
    // require는 실패 시 IllegalArgumentException 발생
}

// 또는 직접
fun setAge(age: Int) {
    if (age <= 0) {
        throw IllegalArgumentException("나이는 0보다 커야 합니다")
    }
}
```

**Kotlin의 require**

```kotlin
fun divide(a: Int, b: Int): Int {
    require(b != 0) { "0으로 나눌 수 없습니다" }
    return a / b
}
```

#### IllegalStateException

객체의 상태가 메서드 호출에 적합하지 않을 때 사용한다.

```kotlin
class Connection {
    private var isConnected = false

    fun sendData(data: String) {
        check(isConnected) { "연결되지 않은 상태입니다" }
        // check는 실패 시 IllegalStateException 발생
    }
}

// 또는 직접
fun sendData(data: String) {
    if (!isConnected) {
        throw IllegalStateException("연결되지 않은 상태입니다")
    }
}
```

#### IndexOutOfBoundsException

인덱스가 유효한 범위를 벗어났을 때 사용한다.

```kotlin
class MyList<T>(private val items: MutableList<T>) {
    fun get(index: Int): T {
        if (index < 0 || index >= items.size) {
            throw IndexOutOfBoundsException(
                "Index: $index, Size: ${items.size}"
            )
        }
        return items[index]
    }
}
```

Kotlin의 `List.get()`도 이 예외를 던진다.

#### UnsupportedOperationException

현재 객체에서 사용할 수 없는 메서드를 호출했을 때 사용한다.

```kotlin
// 읽기 전용 리스트에서 수정 메서드 호출 시
val readOnlyList = listOf(1, 2, 3)
// readOnlyList.add(4)  // UnsupportedOperationException

// 구현하지 않은 추상 메서드
abstract class Shape {
    open fun draw() {
        throw UnsupportedOperationException("draw() not implemented")
    }
}
```

**인터페이스 분리 원칙(ISP) 위반 시**

```kotlin
// ❌ 나쁜 예: 모든 메서드를 하나의 인터페이스에
interface Collection {
    fun add(item: Any)
    fun remove(item: Any)
    fun get(index: Int): Any
}

class ReadOnlyCollection : Collection {
    override fun add(item: Any) {
        throw UnsupportedOperationException()  // ISP 위반
    }
    override fun remove(item: Any) {
        throw UnsupportedOperationException()  // ISP 위반
    }
    override fun get(index: Int) = TODO()
}

// ✅ 좋은 예: 인터페이스 분리
interface ReadableCollection {
    fun get(index: Int): Any
}

interface MutableCollection : ReadableCollection {
    fun add(item: Any)
    fun remove(item: Any)
}
```

#### NoSuchElementException

사용자가 요청한 요소가 존재하지 않을 때 사용한다.

```kotlin
class UserRepository {
    private val users = mutableMapOf<Long, User>()

    fun getUser(id: Long): User {
        return users[id]
            ?: throw NoSuchElementException("User not found: $id")
    }
}

// Iterator에서도 사용
val iterator = listOf(1, 2, 3).iterator()
iterator.next()
iterator.next()
iterator.next()
// iterator.next()  // NoSuchElementException
```

#### ConcurrentModificationException

동시 수정이 금지된 상황에서 수정이 발생했을 때 사용한다.

```kotlin
val list = mutableListOf(1, 2, 3, 4, 5)

// ❌ 반복 중 수정 - ConcurrentModificationException
for (item in list) {
    if (item % 2 == 0) {
        list.remove(item)  // 예외 발생
    }
}

// ✅ Iterator의 remove 사용
val iterator = list.iterator()
while (iterator.hasNext()) {
    val item = iterator.next()
    if (item % 2 == 0) {
        iterator.remove()  // 안전
    }
}
```

### 사용자 정의 예외를 만들어야 할 때

#### 비즈니스 예외 (복구 가능)

```kotlin
// ✅ 도메인 예외는 사용자 정의
class InsufficientBalanceException(
    val requestedAmount: Long,
    val currentBalance: Long
) : Exception("잔액 부족: 요청 $requestedAmount, 현재 $currentBalance")

class AccountLockedException(
    val accountId: Long,
    val reason: String
) : Exception("계좌 잠김: $accountId - $reason")

// 비즈니스 로직에서 사용
fun withdraw(amount: Long) {
    if (balance < amount) {
        throw InsufficientBalanceException(amount, balance)
    }
    balance -= amount
}
```

#### 추가 컨텍스트가 필요할 때

```kotlin
// ✅ 상세한 컨텍스트 제공
class ValidationException(
    val field: String,
    val invalidValue: Any?,
    val reason: String
) : Exception("Validation failed: $field = $invalidValue ($reason)")

// 사용
fun validateEmail(email: String) {
    if (!email.contains("@")) {
        throw ValidationException(
            field = "email",
            invalidValue = email,
            reason = "@ 기호가 없습니다"
        )
    }
}
```

### DomainException 패턴에 대한 고찰

많은 프로젝트에서 `DomainException`에 `ExceptionCode`를 정의해서 쓰는 패턴을 사용한다.

```kotlin
// 일반적인 패턴
enum class ExceptionCode {
    USER_NOT_FOUND,
    INVALID_PASSWORD,
    INSUFFICIENT_BALANCE
}

class DomainException(
    val code: ExceptionCode,
    message: String
) : RuntimeException(message)
```

**장점**
- 예외 코드로 분류 가능
- 동료 개발자가 새로운 코드를 추가하면서 확장 가능
- 한번 정의되면 팀 내에서 표준처럼 사용

**단점**
- 새로운 개발자가 ExceptionCode를 학습해야 함
- IllegalArgumentException과 의미상 차이가 없는 경우가 많음

**권장 사항**
- 비즈니스 예외(복구 가능)와 기술 예외(복구 불가)를 구분
- 기술 예외는 표준 예외 사용
- 비즈니스 예외는 도메인 예외 사용

```kotlin
// ✅ 비즈니스 예외와 기술 예외 구분
// 기술 예외 - 표준 예외 사용
fun setAge(age: Int) {
    require(age > 0) { "나이는 양수여야 합니다" }  // IllegalArgumentException
}

// 비즈니스 예외 - 도메인 예외 사용
fun withdraw(amount: Long) {
    if (balance < amount) {
        throw InsufficientBalanceException(amount, balance)
    }
}
```

## 실무 적용

### Spring에서의 예외 처리

```kotlin
@RestController
class UserController(
    private val userService: UserService
) {
    @PostMapping("/users")
    fun createUser(@RequestBody request: CreateUserRequest): UserResponse {
        // 검증 - 표준 예외
        require(request.age > 0) { "나이는 양수여야 합니다" }
        require(request.email.contains("@")) { "이메일 형식이 올바르지 않습니다" }

        // 비즈니스 로직 - 도메인 예외
        return userService.createUser(request)
    }

    @ExceptionHandler(IllegalArgumentException::class)
    fun handleIllegalArgument(e: IllegalArgumentException): ResponseEntity<ErrorResponse> {
        return ResponseEntity.badRequest()
            .body(ErrorResponse("INVALID_ARGUMENT", e.message))
    }

    @ExceptionHandler(InsufficientBalanceException::class)
    fun handleInsufficientBalance(e: InsufficientBalanceException): ResponseEntity<ErrorResponse> {
        return ResponseEntity.badRequest()
            .body(ErrorResponse("INSUFFICIENT_BALANCE", e.message))
    }
}
```

### 계층별 예외 전략

```kotlin
// Controller: 입력 검증 - 표준 예외
@RestController
class OrderController {
    @PostMapping("/orders")
    fun createOrder(@RequestBody request: OrderRequest) {
        require(request.quantity > 0) { "수량은 양수여야 합니다" }
    }
}

// Service: 비즈니스 규칙 - 도메인 예외
@Service
class OrderService {
    fun createOrder(request: OrderRequest) {
        if (inventory.getStock(request.productId) < request.quantity) {
            throw OutOfStockException(request.productId, request.quantity)
        }
    }
}

// Repository: 데이터 접근 - 표준 예외
@Repository
class OrderRepository {
    fun findById(id: Long): Order {
        return orders[id]
            ?: throw NoSuchElementException("Order not found: $id")
    }
}
```

## 금융권에서의 고려사항

**비즈니스 예외는 명확히**
- 거래 실패, 한도 초과, 계좌 잠김 등은 도메인 예외로 정의
- 복구 가능한 예외와 불가능한 예외를 명확히 구분

**기술 예외는 표준 사용**
- 파라미터 검증, 상태 검증은 표준 예외 사용
- IllegalArgumentException, IllegalStateException 적극 활용

**감사 로그**
- 도메인 예외는 감사 로그에 상세 정보 기록
- 표준 예외는 기술 오류로 분류

```kotlin
// 비즈니스 예외
class TransactionLimitExceededException(
    val accountId: Long,
    val requestedAmount: Long,
    val dailyLimit: Long
) : BusinessException(
    "일일 한도 초과: 요청 $requestedAmount, 한도 $dailyLimit"
)

// 사용
fun processTransaction(accountId: Long, amount: Long) {
    val account = accountRepository.findById(accountId)
        ?: throw NoSuchElementException("계좌를 찾을 수 없습니다: $accountId")  // 표준

    if (account.getDailyTransactionSum() + amount > account.dailyLimit) {
        throw TransactionLimitExceededException(  // 도메인
            accountId,
            amount,
            account.dailyLimit
        )
    }
}
```

---

**출처**
- Effective Kotlin (마르친 모스칼라)

## 관련 노트

- [[모든 예외는 unchecked이다]]
- [[코틀린에서 제약 처리]]
