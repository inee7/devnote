# 코틀린 마이크로서비스 개발
jdk8, maven
 [acornpub.co.kr/book/ml-with-kotlin](http://acornpub.co.kr/book/ml-with-kotlin) 
# 1. 마이크로서비스 이해
마이크로서비스의 근거 원칙이 있는데 DDD와 clean architecture(프레임워크에 의존적이지 않고 테스트용이한 구조)가 그 원칙을 강화시킨다.
**마이크로서비스란**
* 느슨한 서비스
* 관심사항 물리적으로 분리해 독립 설계,개발,테스트,배포
* 애자일, 데브옵스 문화를 수용 가능
* CI/CD에 이상적

마이크로서비스원칙
* 비지니스 역량 중심 모델
* 느슨한 결합
* 단일 책임
* 구현 은닉
* 격리
* 독립배포
* 실패를 위한 빌드
* 확장성
* 자동화

# 2. 스프링부트2.0
메이븐 명령 (순차적으로 실행)
* clean
  * 빌드파일 제거
* validate
  * POM파일 검증
* compile
  * 테스트제외하고 컴파일. 소스파일 변동 없으면 작업 안함
* test
  * 유닛테스트 실행
* package
  * 패키징해서 배포하거나 설치할 준비

메이븐 플러그인은 특정 단계에 연결된다. (예를들어 코틀린 플러그인은 컴파일에 연결)
mvnw 플러그인:목표
메이븐 parent
BOM파일을 통해 필요한 버전을 알린다.
# 3. RESTful
눈으로 봄
여기선 ResponseEntity 권장하더라
컬렉션에서 빈값을 204로 내리네
# 4. 리액티브 마이크로서비스
스프링 웹 플럭스
네티서버 기반
리액티브 스트림패턴 구현하기 위해 리액터프레임워크를 사용
dependencies 는 Reactive Web (spring-boot-starter-webflux)선택
블로킹 IO 방식에서는 서버의 페이지를 요청하면 모든 페이지 내용을 읽고 이를 요청한 클라이언트로 페이지를 전송
읽는 동안 오퍼레이션 차단
넌블로킹IO 는 페이지를 읽기 시작하고 즉시 정보를 보낸다.
블로킹은 리액티브가 아니다!
subscribe publish
일련의 이벤트가 감지되면 필요한 사용자에게 전송
UI에서 버튼누르기 등 액션에 대해 subscriber가 반응한다.
마우스 클릭하면 이벤트를 발생시키는 이런 책임을 가지는게 publisher
UI프레임워크는 모든것을 연결하고 버튼을 클릭하면 publisher가 이벤트를 생성하고 subscriber에게 이벤트를 알림
반환값을 Mono<DTO> 로 바꿔버리네
Mono는 publisher
Flux는 여러개 보내는 publisher
이렇게 반환해서 리액티브하게 논블로킹 가능한듯?
모노는 반환값이 아니라 구독을 하게 되며 준비 됐을떄 그값을 얻을것이다라는 약속
함수형 웹 프로그래밍
```kotlin
@Component
class CustomerRouter {
	@Bean
	fun customerRoutes():  RouterFunction<*> = router {
		"/functional".nest {
			"/customer".nest {
				GET("/") {
					ServerResponse.ok().body("hello world".toMono(), String::class.java)
				}
			}
		}
}
```
나머지는 직접 코딩 해봐겠다
 [https://github.com/inee7/study-webflux-kotlin](https://github.com/inee7/study-webflux-kotlin) /tree/main/webflux
# 5. 리액티브 스프링 데이터
몽고DB
 [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)  에서 다운로드해서
해당 디렉토리 밑에 data 디렉토리 만들고
bin디렉토리에서 >./mongod -dbpath data로 서버 시작
./mongo 로 클라이언트 실행
몽고에 db2개가 기본으로 있음
어드민db는 보안과 관리, local db는 해당인스턴스에 필요한 데이터
use microservices 로 microservice db 생성
db.createCollection("customers") 컬렉션 생성
db.customers.insertOne({"name":"spring"}) 고객 insert
db.customers.insertMany([{"name":"reactive"}, {"name":"microservices"}]) 복수 추가
db.customers.update({ "_id" : ObjectId("6060846f5033d308270ef6b4")}, {"name" : "super spring"}) 업데이트
db.customers.remove({ "_id" : ObjectId("606082355033d308270ef6b3")}) 삭제
mongo port : 27017
show collections customers
 [https://github.com/inee7/study-webflux-kotlin](https://github.com/inee7/study-webflux-kotlin) /tree/main/reactive-db
# 6. 클라우드 네이티브 마이크로서비스 만들기
# 7. 도커만들기
# 8. 마이크로서비스 확장
# 9. 테스트
# 10. 모니터링
# 11. 배포
# 12. 모범사례
코틀린 타입추론 애용해라
표현식을 쓰면 좋다
기본 매개변수 써라
다 아는 얘기 다 좋은 얘기

#dev/book
#ing