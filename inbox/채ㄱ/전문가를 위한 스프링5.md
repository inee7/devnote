# 전문가를 위한 스프링5
 [www.github.com/gilbutitbook/006987](http://www.github.com/gilbutitbook/006987) 
# 1. 스프링소개
버전 내용
5.0x
* 벨로시티, 구아바, 하이버네이트3 지원중단
* 자바8 기능 최대한 활용위해 기능개선
* 프로젝트리엑터(리엑티브스트림 사양구현한 프로젝트)를 기반, 이벤트 루프 실행 모델 방식인 스프링 웹플로우 도입
* JUnit5지원
* 병렬테스트 지원
* 기타등등

5.1.x
* 자바11 지원
* 하이버네이트 5.3 지원
* 기동시간향상, 힙메모리감소위한 리플렉션 기능 최적화
* 웹플럭스 HTTP/2 확장 지원
* 기타등등

말그대로 소개 정도 였다.
# 2. 스프링시작
빈 만드는것에 대한 설명
# 3. 스프링 Ioc와 DI 소개
의존성 주입 컨테이너의 핵심은 **BeanFactory 인터페이스**
BeanFactory 인터페이스를 구현한 클래스의 인스턴스 생성하고 빈과 의존성 정보를 구성하는데
웹에서 자동으로 이루어진다. 스프링의 Applicationcontext는 웹 컨테이너가 웹 시작하는 도중에 web.xml디스크립터에 선언한 ContextLoaderListener클래스를 이용해서 부트스트랩함.
대부분 BeanFactory 구현체의 설정 직접 해야함
BeanFactory내에서 사용자 빈을 식별하는데 ID나 이름으로 식별하고 이름 갯수 제한은 없다.
DefaultListableBeanFactory 로 BeanFactory 구현체를 이용 하면 됨
ApplicationContext인터페이스는 BeanFactory상속함.
DI, 트랜잭션, APi, 국제화메시지, 이벤트 처리 등을 제공
스프링 기반 개발할때는 ApplicationContext를 이용해 사용 권장
스프링은 ApplicationContext를 직접 코드로 부트스트랩하거나 웹에서 ContextLoaderListener를 이용해 부트스트랩.
빈등록 이야기는 스킵
Autowired 될때 이름 혹은 타입으로 빈을 찾는데
생성자 주입일때는 인자가 많은 생성자 쪽으로 Autowired 된다.
스프링은 생성자방식과 byType 방식을 자동으로 선택
자동구성 비추하는데 무슨말일까
# 4. 스프링 구성 상세와 스프링 부트
쭉 봤는데 실제로 쓸 만한 예제는 별로 없더라
# 5. AOP
AOP는 OOP를 보완한다.
**스프링AOP vs AspectJ**
절대적으로 성능이 필요하지 않으면 스프링AOP쓰고 굳이 한가지 방식만 택할 필요는 없다.
스프링AOP는 동적 , AspectJ는 정적 컴파일시점
**AOP개념**
조인포인트: 애플리케이션 실행 과정내 지점. 메소드의 호출, 클래스 초기화, 인스턴스생성 등등 (스프링AOP에서는 메소드호출만 지원함)
어드바이스 : 특정 조인포인트에 실행되는 코드 , 비포에프터로 나눠져있음
포인트컷 : 언제 어드바이스 실행할지 정의할때 사용하는 조인포인트의 모음
애스팩트 : 클래스에 캡슐화된 어드바이스와 포인트컷의 조합. 로직과 로직이 어디서 실행돼야하는지 정의 (스프링AOP에서는 어드바이저 인터페이스를 구현한 인스턴스, 스프링에서 인스턴스 제공해준다. PointCutAdvisor, IntroductionAdvisor 있음)
위빙 : 위치에 애스팩트 삽입하는 과정 (스프링에서 ProxyFactory가 수행한다.)
타겟 : AOP에 의해 수정된 객체
인트로덕션 : 추가 메서드 필드 도입해 객체 구조 수정하는 과정
```java
package com.apress.prospring5.ch5;

public class Agent {
    public void speak() {  <-- 호출이 조인포인트!
        System.out.print("Bond");
    }
}

// 적용할 클래스는 아무런 외부 의존성이 없음.
package com.apress.prospring5.ch5;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class AgentDecorator implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.print("James "); 

        Object retVal = invocation.proceed();

        System.out.println("!"); 
        return retVal;
    }
}

//MethodInterceptor는 어라운드 어드바이스를 구현할 때 사용하는 인터페이스
package com.apress.prospring5.ch5;

import org.springframework.aop.framework.ProxyFactory;

public class AgentAOPDemo {
    public static void main(String... args) {
        Agent target = new Agent(); //타겟 생성

        ProxyFactory pf = new ProxyFactory(); // 프록시 팩토리
        pf.addAdvice(new AgentDecorator()); // 어드바이스 전달
        pf.setTarget(target); // 위빙 대상 지정 

        Agent proxy = (Agent) pf.getProxy(); // 프록시 생성

        target.speak(); // 타겟 원본(?) 실행
        System.out.println("");
        proxy.speak();// AOP 통한 실행 
    }
}
```
위 방식은 프로그래밍 프록시 방식이지만
스프링AOP에서는 선언적 방식을 사용한다.
런타임 시점에 ApplicationContext의 빈에 정의된 횡단 관심사를 분석 → 프록시 빈을 동적 생성 → 호출하는쪽에 프록시 빈 주입 —> 프록시빈은 적절한 어드바이스 위빙
스프링AOP에서 Aspect는 어드바이저 인터페이스를 구현한 클래스의 인스턴스
스프링에서 편리한 어드바이저 구현체를 제공

**ProxyFactory 클래스**
프록시 생성전에 항상 어드바이스를 적용하는 객체와 대상 객체를 지정하는데 ProxyFactory는 내부적으로 DefaultAopProxyFactory의 인스턴스에 위임한다. 설정에 따라 Cglib2AopProxy 또는 JdkDynamicAopProxy에 프록시 생성을 다시 위임.

**스프링에서 어드바이스**
Before, After-Returning, After 등이 있음
표준인터페이스로 어드바이스 예제 코드로 봄
가능한 범위를 좁혀 어드바이스 선택

**스프링에서 포인트컷**
org.springframework.aop.support 안에 있는 클래스들로 예
포인트컷에는 정적과 동적 방식이 있는데
정적은 해당 클래스타입과 메소드네임을 이용해서 처리 한다면 동적은 거기서 인자값을 체크한다.
동적 포인트컷은 더 큰 유연성을 주지만 런타임 성능 오버헤드 주기에 꼭 필요할때만 쓴다.
포인트컷은 보니깐 원하는 지점인지 체크하는거고 어드바이스는 그 지점에 처리할 로직
어노테이션 기반
어노테이션 만들고 원하는곳에 포인트컷을 걸고
AnnotationMachingPointcut.forMethodAnnotation(어노테이션.class)

#dev/book
#ing