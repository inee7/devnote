# 자바웹 next steps
프러덕션 코드와 테스트 코드를 분리하라.

JUnit : 단위 테스트 프레임워크

구현-테스트-리펙토링

else는 되도록 안쓰는게 좋다.

JUnit 활용 잘 할 때 TDD 해보자.

JUnit을 좀 쓰겠으면

테스트주도개발 : 고품질 쾌속 개발을 위한 TDD 실천법과 도구 [https://goo.gl/2ny56w](https://goo.gl/2ny56w)

로 감을 잡은 후

테스트 주도 개발 (kent beck) , 리펙토링:코드품질을 개선하는 객체지향 사고법(마틴파울러)

로 심화

정규 표현식 관련 학습도 하자.

손에 잡히는 정규표현식(벤포터)

프레임워크를 직접 구현해 보면 도움이 된다.

JAVA8, Github, Maven으로 진행

애자일 프로세스는 현 시점에 가장 가치있는 동작하는 소프트웨어 만드는 것을 원칙으로 한다.

이걸 이 스터디에도 쓴다면 내가 가진 역량으로 쓸 수 있는 수준까지 빠르게 끝마치는 것을 목표로 한다.

그래야 빠르게 성취감을 얻고 피드백도 빨리 받을수있다.

**JAVA로 HTTP 웹 서버를 구현해본다.**

먼저 JAVA의 쓰레드, 스트림에 대한 이해가 필요하다.

ServerSocket 클래스가 요청에 클라이언트와 연결을 담당한다.

요청이 오면 쓰레드를 실행 시킨다. (여러 요청에 대한 응답을 하기 위해)

요청이 오면 HTTP 메시지에는

POST /user/create HTTP/1.1 - request line

이 오고 여기서 url을 파싱한다.

그 밑에 HOST와 기타정보들이 들어있다. - request header

그리고 빈공백 라인 뒤에

userId=inee - request body

응답메시지에는 한가지만 다르다 request line이 아니라 status line !

브라우저는 index.html받아도 js,css,image등 태그가 있으면 계속 요청하게 되어있다.

POST방식으로 헤더에 content-length 가 표시된다.

html은 get과 post만 지원한다. ( form태그만 get,post 지원 )

AJAX정도 지원해야 PUT, DELETE 쓸 수 있다.

get, post만 쓴다면 get은 읽기용 , post는 변경작업 이라두고 추후 put, delete등으로 세분화 할 수 있다.

많은 프레임워크에서 리다이렉트 302상태코드에 대응하고 있다.

2.x 성공

3.x 리다이렉션

4.x 클라이언트 문제

5.x 서버 오류

웹서버에서 응답헤더에 set-cookie 설정을 하면 브라우저는 쿠키를 가지고 있게 된다. 그러다 다시 웹서버에 요청하게 되면 그 cookie를 요청때 다시 보내준다.

웹서버에서 content-type을 css도 지원해야 브라우저가 css를 받아 표현 할 수 있다.

**리펙토링 해보자.**

- - -

테스트코드 기반으로 개발하면

1. 클래스의 버그를 빨리 찾을 수 있다.
2. 디버깅하기가 쉽다.
3. 마음 놓고 리펙토링 할 수 있다. 보통 테스트하는데 시간을 많이 소요하는데 프로덕션 코드 수정해도 테스트코드가 있으면 금방 테스트 가능하다.

로직의 복잡도가 높아 추가적인 테스트가 필요하는 메소드가 private이면?!

1. defalut접근제어자로 수정하고 메소드 처리 결과를 반환하도록 수정해 테스트 할 수 있다.
2. 메소드 구현 로직을 새로운 클래스로 분리한다.

객체지향 설계 연습할때 요구사항 명확한 체스게임, 지뢰찾기 게임등으로 연습 필요.

OCP - 변화는 최소화 하면서 기능 확장에 유용해야된다.

분기로 복잡도가 높으면 메소드들도 추출해보자.

그리고 나서 메소드들이 혹시 원형이 같다면 인터페이스로 분리 해보자.

인터페이스로 분리하고 나니 새로운 기능 추가될때 인터페이스와 매핑만 추가하면 된다.

여기서 더 추가해서 인터페이스 - 추상클래스 로 상속구조를 만들어 추상클래스에 get/post에 따라 추상메소드를 만들면 더욱 세분화 할 수 있다.

서블릿이 구현한 웹서버의 Controller, HttpRequest, HttpResponse를 추상화해 인터페이스로 정의해 놓은 표준.

서블릿 컨테이너(톰캣,Jetty,JBoss)가 서블릿에 대한 구현을 한 것이다.

서버가 시작 될 때 서블릿 인스턴스를 생성해, 요청 URL과 서블릿 인스턴스를 연결한다.

**지금까지 개발한 웹서버에는 문제점이 있다.**

HTTP 요청과 응답 헤더, 본문 처리와 같은 데 시간을 투자함으로써 비지니스 로직에 투자할 시간이 없고 동적 HTML 만드는게 한계가 있고 데이타가 영구적이지 않다.

따라서 서블릿컨테이너, 서블릿/JSP를 활용해서 문제를 해결해보자.

embedded tomcat 다운 받아서 lib폴더에 jar파일들 의존 시키면 된다.

java소스에서 Tomcat을 생성해서 실행 시키면 톰캣이 실행된다. ( 마치 webserver 역할과 같다. )

그리고 Servlet 클래스 상속받아서 구현하면 된다. ( Controller 역할과 비슷하다. )

Servlet구현클래스 파일은 webapp/WEB-INF/classes 밑에 있어야 된다는 스펙이 있다. (path 설정 바꿔주면 된다. )

서블릿 컨테이너는 @WebServlet 어노테이션으로 요청 URL과 서블릿을 연결하는 Map을 생성한다.

변경된 자바는 톰캣을 재시작 해야 재컴파일해서 정상 작동 된다.

서블릿 컨테이너의 중요한 역할 중의 하나는 서블릿 클래스의 인스턴스 생성,요청 URL과 서블릿 인스턴스 매핑, 클라이언트 요청에 해당하는 서블릿 찾아 서블릿에 작업을 위임하는 역할이다.

그리고 서블릿에 대한 생명주기 관리를 한다.

이 점은 EJB컨테이너와 스프링컨테이너와도 비교된다.

EJB컨테이너는 EJB의 생명주기를 관리하고 스프링은 빈의 생명주기를 관리한다.

서블릿 컨테이너는 멀티스레드로 동작한다.

즉, 접속자마다 각자 스레드를 돌린다.

RequestMapping은 static으로 한번 초기화되면 쭉 재사용된다.

따라서 각자 스레드를 가지지만 같은 서블릿 인스턴스를 사용할 수 있다.

이점은 문제가 발생 할 수 있기에 방어를 잘 해야한다.

오랫동안 서블릿/JSP가 동적웹애플리케이션 개발에 표준이었지만 플레이 프레임워크 처럼 서블릿 표준 따르지 않는 기술도 등장했다.

그만큼 서블릿은 언제든 대체 될 수 있다.

서블릿이 HTTP지원에 많이 제공 되고 있지만 서블릿만 가지고는 빠르게 개발하는데 한계가 있다.

그래서 프레임워크를 많이 쓰는데 MVC패턴 기반이 많다.

서블릿/JSP를 씀으로써

일단 HTML을 동적으로 코딩하는데 어려움은 없애버렸다. JSP덕분에..

근데 옛날에는 JSP에 자바코드를 넣었는데.. 이것도 매우 분업에 어려움이..

따라서 등장한게 JSTL과 EL인데 JSP에서 자바 코드를 완벽히 제거할 수 있었다.

컨트롤러를 담당하는 서블릿이 출력할 데이터를 잘 전달 해주기 때문이다.

이것은 MVC패턴을 잘 지켜야 가능하다는 것이다.

서블릿/JSP로 개발

세션개발

세션은 클라이언트와 서버 간에 상태 값을 공유하기 위해 고유한 아이디를 활용하고, 이 고유한 아이디는 쿠키를 활용해 공유한다.

MVC프레임워크

2000년대 초중반 까지 웹애플리케이션 개발은 JSP에 많은 로직이 담겨져 있었다.

점점 많은 애플리케이션이 웹으로 개발하고 복잡한 요구사항 때문에 유지보수 업무가 증가했다.

JSP에 로직을 포함하면 초기 개발 속도는 빨랐지만 유지보수 비용이 증가했다.

그래서 유지보수 비용줄이기 위해 MVC패턴 기반으로 웹 애플리케이션 개발하는 방향으로 발전했다.

MVC를 통해 JSP는 뷰만 담당하게 됐고 서블릿과 모델만 로직을 담당하게 됐다.

프레임워크를 통해 특정 패턴 기반으로 개발하도록 강제하여 MVC에 대한 역량의 차이가 나더라도 일관성 있게 개발 할 수 있게 해준다.

자주 변하는 부분을 메소드 분리.

공통 라이브러리 부분을 새로운 클래스로 빼기 .

새로뺀 클래스에서 공통적인 건 나두고 변하는 부분을 템플릿 메소드 패턴으로 분리

템플릿 메소드 패턴을 쓰니 단점이 안쓰는 메소드도 구현해야되는 게 있다.

그래서 인터페이스로 빼서 인터페이스를 주입하는 방식으로 구현

점진적 리팩토링이 좋다.

제네릭으로 캐스팅 없애자.
#dev/book