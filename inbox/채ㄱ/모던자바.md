# 모던자바
repo : inee7/study-modern-java.git
함수형인터페이스에서 기본형 특화를 쓰면 언박시이 되지 않아 메모리 유리
함수형 디스크립터 (람다 표현식의 시그니처)
형식추론
자유변수로 람다캡쳐링 → 람다에서 외부변수를 가져다 씀 (지역변수는 final이어야하고 정적변수와 인스턴스변수는 그냥 쓰면 됨)
Comparator인터페이스로 비교하는데
compare(Function ) 정적 메소드로 객체에 특정 필드를 기준으로 비교대상을 정할 수 있다.
List객체.sort(Comparator 구현체) 로 정렬 가능
Comparator 유틸 메소드로 추가 기능 가능 revesed()... thenComparing()..
Predicate 유틸
```java
Predicate<Apple> redApple = apple -> apple.getColor().equals(Color.RED);
Predicate<Apple> notRedApple = redApple.negate(); // 반전 가능
Predicate<Apple> heavy = apple -> apple.getWeight() > 150; // 반전 가능
Predicate<Apple> andPre = heavy.and(notRedApple); // predicate 조합가능 
```
Function 유틸
```java
Function<Apple, Integer> f = Apple::getWeight;
Function<Apple, Byte> appleByteFunction = f.andThen(Integer::byteValue);
```
스트림은 선언적이다.
선언적이라는건 더 간결하고 가독성이 좋음
내부반복을 한다.
병렬도 알아서 한다.
# 5장. 스트림활용
* filter
* distinct
* takeWhile 조건이 거짓전까지만 _**java9**
* dropWhile 조건이 거짓이후 부터만 _**java9**
* limit
* skip 해당 갯수만큼 스킵
* flatmap // 스트림으로 반환 해줘야
* allMatch, anyMatch, noneMatch

쇼트서킷이라는 연산자 limit, allMatch.... 는 and처럼 결과를 다 보지 않아도 처리 할 수 있는 역할을 해서 무한 스트림에서 자주 쓴다.
* findFirst, findAny (병렬일때 꼭 이거 써라)
* 리듀싱연산을 FP에서는 폴드라고 부른다.
  * reduce(초깃값, BinaryOperator)
  * reduce(BinaryOperator) 오버로딩 함수도 있긴한데 반환값이 Optional
  * numbers.stream().reduce(Integer::max) 최댓값
  * reduce를 쓰면 외부 반복을 통해 공유변수로 누적했던것을 넘어 병렬에 유리하다.
* 기본 특화형 스트림에서만 sum, max, average... 쓸 수 있다.
* IntStream.boxed();
* max() 연산 했을때 OptionalInt 처럼 반환해서 값이 없을때를 대응한다.
* 

# 18장. 함수형 관점으로 생각하기
함수형 프로그래밍의 기반인 선언형 프로그래밍
선언형은 HOW에 집중해서 외부 반복과 같은 방법. 코드 자체가 명확
WHAT에 집중해서 내부반복과 같은 방법으로 푸는 방법도 있다
함수형은 선언형을 따르고 부작용이 없는 계산을 지향.
함수 안에서 다른 객체를 변화 시킨다거나 그러면 안된다.
함수와 if then else등만 사용하면 순수함수형프로그래밍
시스템 다른 부분 영향없고 내부적으로 함수형 아닌 기능도 사용하는걸 함수형 프로그래밍
자바는 순수 함수는 아니다
Scanner.nextLine을 하면 파일의 행을 소비 = 외부 시스템 변경
어떤 함수가 진입할때 필드 증가 시켰다가 빠져나올 때 필드 값을 되돌려 놓는다면
lock으로 함수형을 만들수 있는데 다만 병렬을 쓸 수 없게 되고 성능이 줄어든다.
지역 변수만 변경해야 함수형이라 할 수 있다.
참조 객체는 불변이어야 한다.
예외적으로 함수 안에서 생성한 객체는 갱신하고 다만 외부에 노출 하지 않아야 한다.
함수형이면 어떤 예외도 일으키지 않아야한다.
Optional을 써서 함수형에 더 가깝게 할수 있다
로그를 출력하는것이 좋다
함수형은 참조투명성 해야한다. input 이 같으면 output이 같다. "raoul".replace('r', 'R')
List반환하는 메서드를 두 번 호출하면 서로 다른 메모리 공간에 생성된 리스트를 뱉어낸다. 불변리스트로 뱉어내면 두 리스트가 같고 참조 투명성하다.
순수함수에서는 반복문이 포함 되지 않는다. 변화가 자연스럽게 스며 들수 있기에.
대신 재귀로 해결
꼬리재귀로 컴파일러 최적화 해결
# 19장. 함수형 프로그래밍 기법
함수를 값처럼 쓸수 있는게 일급함수
자바 람다에서 일급함수 지원.
Function<String, Integer> stringToInt = Integer::parseInt;
함수를 인자로 받고 함수를 결과로 반환하는걸 고차원 함수라고 한다.
```java
public class Letter {
	public static String addHeader(String text) {
	    return "From Raoul, Mario and Alan:" + text;
	  }

  public static String addFooter(String text) {
    return text + "Kind regards";
  }

  public static String checkSpelling(String text) {
    return text.replaceAll("C\\\\+\\\\+", "**Censored**");
  }
}

Function<String, String> addHeader = Letter::addHeader;
    Function<String, String> transformationPipeline = addHeader
        .andThen(Letter::checkSpelling)
        .andThen(Letter::addFooter);
```
함수를 모듈화하고 코드를 재사용하는 데 도움을 주는 커링. f(x,y) = (g(x))(y)
```java
static DoubleUnaryOperator curriedConverter(double y, double z) {
    return (double x) -> x * y + z;
  }

DoubleUnaryOperator convertCtoF = curriedConverter(9.0 / 5, 32);
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0);
DoubleUnaryOperator convertKmtoMi = curriedConverter(0.6214, 0);
```

갱신하지 않은 함수
```java
class Train {
	int price;
	Train next;
}

static Train badLink(Train a, Train b) {
	if( a==null ) return b; 
	Train t = a; 
	while(t.next != null) {
		t = t.next;
	}

	t.next = b; 
	return a; 
}

static Train goodLink(Train a, Train b) {
	return a==null ? b : new Train(a.price, goodLink(a.next, b);
}
```

#dev/book
#ing