# 리시버를 명시적으로 참조하라
```kotlin
class Node(val name: String) {
	fun makeChild(childName: String ) =
    	create("$name.$childName")
        	.apply { print("Created ${name}") }
            
    fun create(name: String): Node? = Node(name)
}


fun main(){
  val node = Node("parent") 
  node.makeChild("child") // Created parent가 출력됨
}
```
name은 상위 클래스의 name을 참조한다


```kotlin
class Node(val name: String) {
	fun makeChild(childName: String ) =
    	creeate("$name.$childName")
        	.apply { print("Created ${this?.name}") }
            
    fun create(name: String): Node? = Node(name)
}


fun main(){
  val node = Node("parent") 
  node.makeChild("child") // Created parent.child 출력
}
```
this는 apply의 리시버를 가져온다 

하지만 이렇게 nullable을 처리할때는 also 또는 let이 훨씬 좋은 선택지이다 
이유는 리시버를 명시적으로 사용하도록 강제 하기 때문이다 
```kotlin
class Node(val name: String) {
	fun makeChild(childName: String ) =
    	creeate("$name.$childName")
        	.also { print("Created ${it?.name}") }
            
    fun create(name: String): Node? = Node(name)
}


fun main(){
  val node = Node("parent") 
  node.makeChild("child") // Created parent.child 출력
}
```

굳이 쓰고 싶다면 
```kotlin
class Node(val name: String) {
	fun makeChild(childName: String ) =
    	creeate("$name.$childName")
        	.apply { print("Created ${this?.name} in ${this@Node.name}") }
            
    fun create(name: String): Node? = Node(name)
}


fun main(){
  val node = Node("parent") 
  node.makeChild("child") // Created parent.child in parent 출력
}
```
apply를 쓰는데 리시버를 강제화 해서 쓰는 경우
#kotlin 