# 8. 결합
DiscountManager.getDiscountPrice는 일반 할인 가격 계산을 책임지는 메서드이다. 
여름 할인 가격을 책임지기 위해 만들어진 메서드가 아니기에 둘 다 책임지는건 단일책임원칙을 깨는것이다. 

Product에서 상품명과 가격이 타당한지 판단해야한다. 하지만 다른 클래스에서 판단하면 안된다. 

```kotlin
class RegularPrice {
  private static final int MIN_AMOUNT = 0; 
  final int amount;

  Regularprice(final int amount) {
    if (amount < MIN_AMOUNT) {
      throw --
    }
    this.amount = amount;
  }
}

class RegularDiscountedPrice {
    private static final int MIN_AMOUNT = 0;
    private static final int DISCOUNT_AMOUNT = 4000;
    final int amount;

    RegularDiscountedPrice(final RegularPrice price) {
        int discountedAmount = price.amount - DISCOUNT_AMOUNT;
        if (discountedAmount < MIN_AMOUNT) {
            discountedAmount = MIN_AMOUNT;
        }

        amount = discountedAmount;
    }
    
}
```
RegularDiscountedPrice --> RegularPrice 로 느슨한 결합으로 서로 영향을 주지 않는다. 

RegularDiscountedPrice와 비슷한 구조에 룰만 달라지면 어떻게 될까 
DRY원칙으로 중복을 줄이기 위해 작업해야할까 
아니다. 룰이 달라진다는건 개념이 달라지는것이다. 중복을 허용하면 안된다. 
개념적으로 다른 것까지도 무리하게 중복 제거하면 강한 결합니다. 
---
강한 결합을 피해야 *SRP* 가 지켜진다. 상속을 피하자!
~컴포지션~으로 해결하자. 

클래스에 인스턴스변수들이 있고 예약취소, 다크모드전환, 메일보내기가 있다면 
책임분리가 필요하다. 
각 메소드가 인스턴스 변수를 활용하고 있는지를 보고 메소드간에 의존이 있는지 확인한다. 
없다면 각각 클래스로 찢어질수 있다. 

각 인스턴스변수와 메소드의 관계를 알아야한다. 
영향스케치로 의존관계를 그릴수 있는데 jig라는 도구가 있다. 

----
public 처음부터 쓰지 말자 
private 메소드가 너무 많으면 책임이 너무 많다는것 
---
거대 데이터 클래스는 다양한 데이터를 가지고 수많은 유스케이스에 사용한다. 동기화하느라 성능이 저하되고 전역변수와 동일한 폐해가 발생

SRP에 따라 설계된 클래스는 아무리 많아도 100~200줄 정도이다. 
조기리턴, 전략패턴, 일급컬랙션등이 SRP에 도움을 준다. 
#dev/book/내코드가그렇게이상한가요