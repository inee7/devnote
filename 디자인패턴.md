# 디자인패턴

# 데코레이터 패턴

프로토타입 패턴은 속성을
데코레이터 패턴은 동작을 조금씩 다르게 여럿 만들수 있다

수정하면 안되는 클래스에 기능을 추가하고 싶다
상속을 하면 기능 추가 될때마다 새로운 클래스를 만들어야한다 
추가되는 기능들을 클래스로 만들고 조합하는게 데코레이터 패턴

```kotlin
class LoggingGetCaptain(private val repository: StarTrekRepository): StarTrekRepository by repository { 
    override fun getCaptain(starshipName: String): String { 
    printIn("sstarshipName 함선의 선장을 조회 중입니다. ") 
    return repository.getCaptain(starshipName) 
}
```
- 기능 추가하고 싶은 객체를 인자로 받는다
- 상속하지 않기에 super를 사용하지 않는다

데코레이터는 인터페이스를 가지고 있으면서 추가 동작을 하는 클래스들이다
인터페이스 구현체를 가진 데코레이터로 계속 붙일수 있다 
상속을 통해 풀기에 단점도 있다
프록시는 프록시를 모르게하기 위해 실제 구현체를 가진 클래스이다 


# 프록시 패턴

데코레이터 패턴과 마찬가지로 객체의 기능을 확장 
데코레이터는 추가 동작을 하지만 요청한 동작은 항상 그대로 수행
프록시는 완전히 다른 식으로 동작 할 수 있다

예를들어 값비싼 동작을 매번 하지 않게 할 수 있다 
두번째 요청부터 캐시를 쓴다던지.. 
이런게 바로 가상프록시이다.
그외 원격 프록시, 접근제어프록시 등이 있다 
```kotlin
data class CatImage(
    val thumbnailUrl: String,
    val url: String
) {
    val image: ByteArray by lazy {
        println("Fetching image, please wait")
        // Read image as bytes
        URL(url).readBytes()
    }
}
```

스프링aop도 프록시라고 보더라 
횡단관심사를 숨겨버린다


# 명령패턴
객체 내부에 동작을 캡슐화해서 넣어 둔 뒤 나중에 실행 되도록 함.
동작 실행을 지연시키면 한꺼번에 많은 동작을 실행할 수도 실행타이밍을 세밀하게 조절도 가능
```kotlin
typealias Command = () -> Unit

open class Trooper {
    private val orders = mutableListOf<Command>()

    fun addOrder(order: Command) {
        this.orders.add(order)
    }

    fun appendMove(x: Int, y: Int) = apply {
        orders.add(moveGenerator(this, x, y))
    }

    fun execute() {
        while (orders.isNotEmpty()) {
            val order = orders.removeFirst()
            order()
        }
    }
    // More code here

    fun move(x: Int, y: Int) {
        println("Moving to $x:$y")
    }
}

val moveGenerator = fun(
    s: Trooper,
    x: Int,
    y: Int,
): Command {
    return fun() {
        s.move(x, y)
    }
}

fun main() { 
    val t = Trooper()
    t.appendMove(1, 1).appendMove(2, 2).appendMove(3, 3).execute()
}

```

# 전략 패턴
**런타임에 알고리즘을 바꾸어 사용하는 패턴**

상태를 가지지 않는 알고리즘이라면
자바에서 전략패턴을 쓰면 인터페이스 정의하고 모든 구현 클래스를 작성해야해서 클래스가 많아 진다.
코틀린에서는 자바와 다르게 일금객체인 함수이다. 
이점을 이용해 함수를 이용해 클래스 작성없이 알고리즘을 만들수 있어 장점이다
```kotlin

// Weapons라는 네임스페이스를 두기 위해 object로 감쌌다 
object Weapons {
    // Flies straight
    fun peashooter(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a peashooter")
        return Projectile(x, y, direction)
    }

    // Returns back after reaching end of the screen
    fun banana(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a banana")
        return Projectile(x, y, direction)
    }

    // Explodes on contact
    fun pomegranate(x: Int, y: Int, direction: Direction): Projectile {
        println("It's a pomegranate")
        return Projectile(x, y, direction)
    }
}


class OurHero {
    private var direction = Direction.LEFT
    private var x: Int = 42
    private var y: Int = 173

    var currentWeapon = Weapons::peashooter // 알고리즘 변경 

    val shoot = fun() {
        currentWeapon(x, y, direction)
    } // 함수를 프로퍼티로 가지며 위임한다 

}

fun main() {
    val hero = OurHero()
    hero.shoot()
    hero.currentWeapon = Weapons::banana
    hero.shoot()
}

```


# 퍼사드 패턴

지저분한 구현 세부 사항을 감추는데 사용
목적은 서로 연관된 여러클래스나 인터페이스를 더 깔끔하고 간단하게 다룰 수 있도록 하는 것

자바에서는 클래스를 별도로 만들고 모든 로직을 캡슐화한 함수를 만들것이다. 
코틀린에서는 확장함수로도 간단히 퍼사드를 표현할 수 있다. 
```kotlin
fun Server.startFromConfiguration(fileLocation: String) {
    val path = Path(fileLocation)

    val lines = path.toFile().readLines()

    val configuration = try {
        JsonParser().server(lines)
    } catch (e: RuntimeException) {
        YamlParser().server(lines)
    }

    Server.withPort(configuration.port)
}

class Server private constructor(port: Int) {
    companion object {
        fun withPort(port: Int): Server {
            return Server(port)
        }
    }
}

```


# 어뎁터 패턴

어뎁터패턴은 어떤 인터페이스에서 다른 인터페이스로 변환 하고자 할때 사용 한다

확장 함수를 통해 또다른 클래스타입으로 변경한다
```kotlin
fun UsbMini.toUsbTypeC(): UsbTypeC {
    val hasPower = this.hasPower == Power.TRUE
    return object : UsbTypeC {
        override val hasPower = hasPower
    }
}
```

일반적인 어댑터 메소드
`stream.toList()`

# 프로토타입패턴

객체의 일부만 다른 또다른 객체를 만들때 
copy함수로 프로토타입패턴을 나타낼수 있다
```kotlin
data class User(
    val name: String,
    val role: Role,
    val permissions: Set<String>,
) 
val prototype = u.copy(name = _name)

```


# 빌더 패턴 

```kotlin
class Mail internal constructor(
    val to: List<String>,
    val cc: List<String>? = listOf(), 
    val title: String? = "",
    val message: String? = "",
    val important: Boolean = false
)

val mail  = Mail(title = "안녕", message = "잘지내니?")
```

기본 매개변수와 명명인수가 있으면 빌더패턴을 만들 필요 없다. 

# 추상 팩토리 패턴 

팩토리 메서드의 모음이다. 
연관된 객체를 모아서 묶을수 있다. 
```kotlin
class Parser {

    companion object {
        fun server(propertyStrings: List<String>): ServerConfiguration {
            val parsedProperties = mutableListOf<Property>()
            for (p in propertyStrings) {
                parsedProperties += property(p)
            }

            return ServerConfigurationImpl(parsedProperties)
        }

        fun property(prop: String): Property {
            val (name, value) = prop.split(":")

            return when (name) {
                "port" -> IntProperty(name, value.trim().toInt())
                "environment" -> StringProperty(name, value.trim())
                else -> throw RuntimeException("Unknown property: $name")
            }
        }
    }
}


interface Property {

    val name: String

    val value: Any

}


interface ServerConfiguration {

    val properties: List<Property>

}

data class ServerConfigurationImpl(

    override val properties: List<Property>

) : ServerConfiguration

data class StringProperty(

    override val name: String,

    override val value: String

) : Property

data class IntProperty(

    override val name: String,

    override val value: Int

) : Property

```

혹은 인터페이스로도 구현할 수 있다. 
```kotlin
interface Parser2 {
    fun property(prop: String): Property
    fun server(propertys: List<String>): ServerConfiguration
}
```

# 싱글톤패턴
`object` 라는 키워드로 쉽게 싱글톤 객체를 생성 가능 
직접 인스턴스화할 수 없기에 생성자는 정의 하지 않는다
`object NoMoviesList`

당연히 클래스, 인터페이스 상속이 가능하다 
```kotlin
internal object EmptyList : List<Nothing>, Serializable, RandomAccess {
...
}
```

초기화도 가능한데 다만 접근 했을때만 실행하는 lazy 초기화이다 
```kotlin
object Logger {
    init {
        println("I was accessed for the first time")

        // Initialization logic goes here
    }

    fun log(message: String) {
        println("Logging $message")
    }
    // More code goes here
}
```


# 팩토리 메서드 패턴
```kotlin
fun createPiece(notation: String): ChessPiece {
    val (type, file, rank) = notation.toCharArray()
    return when (type) {
        'q' -> Queen(file, rank)
        'p' -> Pawn(file, rank)
        // ...
        else -> throw RuntimeException("Unknown piece: $type")
    }
}
```
notation 이란 문자열받아서 Qeen, Pawn 등 객체를 만들어 낸다. 

# 정적 팩토리 메소드 
생성자에 비해 명시적인 이름을 붙일 수 있다. 

캐시를 적용할 수 있어 장점이다. Long.valueof 에서 파싱 한적있는 객체를 반환한다. 
하위 클래스의 인스턴스도 생성 가능. 

```kotlin
class Server private constructor(port: Long) {

    init {
        println("Server started on port $port")
    }

    companion object {
        fun withPort(port: Long): Server {
            return Server(port)
        }
    }
}
```
동반객체는 object와 다르게 클래스 로딩할때 초기화 된다 

# 관찰자패턴
함수형프로그래밍을 다루는 가교역할 
함수를 키로 쓴다
유연성이 강점이다. 
발행자는 호출할 함수의 시그니처 외에는 구독자에 관해 아무것도 알 필요가 없다. 
중개인패턴과 다르게 구독자가 런타임에 구독 및 구독 취소가 가능 
```kotlin
fun main() {
    val catTheConductor = Cat()

    val bat = Bat()
    val dog = Dog()
    val turkey = Turkey()

//    catTheConductor.joinChoir(bat::screech)
    catTheConductor.joinChoir { bat.screech(HighMessage(2)) }
    catTheConductor.joinChoir(dog::howl)
    catTheConductor.joinChoir(dog::bark)
    catTheConductor.joinChoir(turkey::gobble)

    catTheConductor.conduct()
    catTheConductor.conduct()
}

//class Bat {
//    fun screech() {
//        println("Eeeeeee")
//    }
//}

class Bat {
    fun screech(message: Message) {
        when (message) {
            is HighMessage -> {
                for (i in 1..message.repeat) {
                    println("${message.pitch} 이---")
                }
            }

            else -> println("낼 수 없는 소리")
        }
    }
}

class Turkey {
    fun gobble() {
        println("Gob-gob")
    }
}

class Dog {
    fun bark() {
        println("Woof")
    }

    fun howl() {
        println("Auuuu")
    }
}

class Cat {
    private val participants = mutableMapOf<() -> Unit, () -> Unit>()

    fun joinChoir(whatToCall: () -> Unit) {
        participants[whatToCall] = whatToCall
    }

    fun leaveChoir(whatNotToCall: () -> Unit) {
        participants.remove(whatNotToCall)
    }

    fun conduct() {
        for (p in participants.values) {
            p()
        }
    }
}

typealias Times = Int

enum class SoundPitch { HIGH, LOW }
interface Message {
    val repeat: Times
    val pitch: SoundPitch
}


data class LowMessage(override val repeat: Times) : Message {
    override val pitch = SoundPitch.LOW
}

data class HighMessage(override val repeat: Times) : Message {
    override val pitch = SoundPitch.HIGH
}




```


# 템플릿메서드 패턴
지역함수를 활용
```kotlin
fun main() {
    runSchedule(afterLunch = fun() {
        println("Discuss my lunch with boss' secretary")
        println("Read something not related to work")
    }, beforeLunch = {
        println("Look for my next trip destination")
        println("Read StackOverflow")
    }, bossHook = { println("Boss: Can we talk privately?") })
}


fun runSchedule(
    beforeLunch: () -> Unit,
    afterLunch: () -> Unit,
    bossHook: (() -> Unit)? = fun() { println() }
) {
    fun arriveToWork() {
        println("How are you all?")
    }

    val drinkCoffee = { println("Did someone left the milk out?") }

    fun goToLunch() = println("I would like something italian")

    val goHome = fun() {
        println("Finally some rest")
    }

    arriveToWork()
    drinkCoffee()
    beforeLunch()
    goToLunch()
    afterLunch()
    bossHook?.let { it() }
    goHome()
}

```



# 방문자패턴
합성패턴과 절친. 
쓸모 있을지 논란의 대상. 
장황한 코드 강한 결합 
```kotlin
fun main() {

    val page = Page(
        Container(
            Image,
            Link,
            Image
        ),
        Table,
        Link,
        Container(
            Table,
            Link
        ),
        Container(
            Image,
            Container(
                Image,
                Link
            )
        )
    )

    println(collectLinks(page))
}

fun collectLinks(page: Page): List<String> {
    // No need for intermediate variable there
    return LinksCrawler().run {
        page.accept(this)
        this.links
    }
}


class LinksCrawler {
    private var _links = mutableListOf<String>()

    val links
        get() = _links.toList()

    fun visit(page: Page) {
        visit(page.elements)
    }

    fun visit(container: Container) = visit(container.elements)

    private fun visit(elements: List<HtmlElement>) {
        for (e in elements) {
            when (e) {
                is Container -> e.accept(this)
                is Link -> _links.add(e.href)
                is Image -> _links.add(e.src)
                else -> {
                }
            }
        }
    }
}

private fun Container.accept(feature: LinksCrawler) {
    feature.visit(this)
}

// Same as above but shorter
private fun Page.accept(feature: LinksCrawler) = feature.visit(this)


class Page(val elements: MutableList<HtmlElement> = mutableListOf()) {
    constructor(vararg elements: HtmlElement) : this(mutableListOf()) {
        for (s in elements) {
            this.elements.add(s)
        }
    }
}


sealed class HtmlElement

class Container(val elements: MutableList<HtmlElement> = mutableListOf()) : HtmlElement() {

    constructor(vararg units: HtmlElement) : this(mutableListOf()) {
        for (u in units) {
            this.elements.add(u)
        }
    }
}

object Image : HtmlElement() {
    val src: String
        get() = "https://some.image"
}

object Link : HtmlElement() {
    val href: String
        get() = "https://some.link"
}

object Table : HtmlElement()

```




# 기억패턴
```kotlin
fun main() {
    val michael = Manager()
    michael.think("Need to implement Coconut Cannon")
    michael.think("Should get some coffee")
    val memento = michael.saveThatThought()
    with(michael) {
        think("Or maybe tea?")
        think("No, actually, let's implement Pineapple Launcher")
    }
    michael.printThoughts()
    michael.`what was I thinking back then?`(memento)
    michael.printThoughts()
}

class Manager {
    private var thoughts = mutableListOf<String>()

    fun printThoughts() {
        println(thoughts)
    }

   // 정적중첩클래스와 다르게 내부 클래스는 바깥쪽클래스의 비공개 필드에 접근할 수 있다. 
    inner class Memory(private val mindState: List<String>) {
        fun restore() {
            thoughts = mindState.toMutableList()
        }
    }

    fun saveThatThought(): Memory {
        return Memory(thoughts.toList())
    }

    fun `what was I thinking back then?`(memory: Memory) {
        memory.restore()
    }

    fun think(thought: String) {
        thoughts.add(thought)
        if (thoughts.size > 2) {
            thoughts.removeFirst()
        }
    }
}



```

실무에서 볼 일은 많지 않다. 
하지만 이전의 상태를 복원할 필요가 있는 애플리케이션에서는 유용. 


# 중개인패턴


```kotlin
fun main() {
    val productManager = Michael
    val company = MyCompany(productManager)
    company.taskCompleted(true)
}

interface ProductManager {
    fun isAllGood(majorRelease: Boolean): Boolean
}

object Michael : Canary, ProductManager {
    private val kenny = Kenny(this)
    private val brad = Brad(this)

    override fun isAllGood(majorRelease: Boolean): Boolean {
        if (!kenny.isEating() && !kenny.isSleeping()) {
            println(kenny.doesMyCodeWork())
        } else if (!brad.isEating() && !brad.isSleeping()) {
            println(brad.doesMyCodeWork())
        }
        return true
    }
}

interface Canary {

}

interface QA {
    fun doesMyCodeWork(): Boolean
}

interface Parrot {
    fun isEating(): Boolean
    fun isSleeping(): Boolean
}


class Kenny(private val productManager: ProductManager) : QA, Parrot {
    override fun isSleeping(): Boolean {
        return false
    }

    override fun isEating(): Boolean {
        return false
    }

    override fun doesMyCodeWork(): Boolean {
        return true
    }
}

class Brad(private val productManager: ProductManager) : QA, Parrot {
    override fun isSleeping(): Boolean {
        return false
    }

    override fun isEating(): Boolean {
        return false
    }

    override fun doesMyCodeWork(): Boolean {
        return true
    }
}

object Me
class MyCompany(private val productManager: ProductManager) {
    fun taskCompleted(isMajorRelease: Boolean) {
        println(productManager.isAllGood(isMajorRelease))
    }
}


```

#dev/kotlin/design pattern#
#dev/book/코틀린디자인패턴
#dev/kotlin/design pattern/동작패턴# #dev/design pattern#

# 해석기패턴
특정한 언어를 번역할 때 사용하는 디자인 패턴. 
DSL 특정 도메인에서 사용하기 위한 언어 
```kotlin
fun main() {

    val sql = select("name, age") {
        from("users") {
            where("age > 25")
        } // Closes from
    } // Closes select

    println(sql) // "SELECT name, age FROM users WHERE age > 25"
}

fun select(columns: String, from: SelectClause.() -> Unit):
        SelectClause {
    return SelectClause(columns).apply(from)
}

class SelectClause(private val columns: String) {
    private lateinit var from: FromClause
    fun from(
        table: String,
        where: FromClause.() -> Unit
    ): FromClause {
        this.from = FromClause(table)
        return this.from.apply(where)
    }

    override fun toString() = "SELECT $columns $from"
}

class FromClause(private val table: String) {
    private lateinit var where: WhereClause

    fun where(conditions: String) = this.apply {
        where = WhereClause(conditions)
    }

    override fun toString() = "FROM $table $where"
}

class WhereClause(private val conditions: String) {
    override fun toString() = "WHERE $conditions"
}
```
가장 다루기 어려운 패턴 중 하나이다. 


# 책임사슬패턴
복잡한 로직을 여러 개의 작은 단계로 쪼개고 그 결과에 따라 계속해서 다음 단계로 진행할지 또는 처리하고 끝낼지 반환할지 결정한다. 
웹서버프레임워크에서 인증,인가,로깅 등 횡단 관심사를 다룰때 많이 쓴다. 
```kotlin
fun main() {
    val req = Request(
        "developer@company.com",
        "Why do we need Software Architects?"
    )

    val chain = basicValidation(authentication(finalResponse()))

    val res = chain(req)

    println(res)
}

data class Request(val email: String, val question: String) {
    fun isKnownEmail(): Boolean {
        return true
    }

    fun isFromJuniorDeveloper(): Boolean {
        return false
    }
}

// This is the incorrect implementation of what we want to achieve
fun handleRequest(r: Request) {
    // Validate 
    if (r.email.isEmpty() || r.question.isEmpty()) {
        return
    }

    // Authenticate 
    // Make sure that you know whos is this user 
    if (r.isKnownEmail()) {
        return
    }

    // Authorize
    // Requests from juniors are automatically ignored by architects 
    if (r.isFromJuniorDeveloper()) {
        return
    }

    println("I don't know. Did you check StackOverflow?")
}

val authentication = fun(next: Handler) =
    fun(request: Request): Response {
        if (!request.isKnownEmail()) {
            throw IllegalArgumentException()
        }
        return next(request)
    }

val basicValidation = fun(next: Handler) =
    fun(request: Request): Response {
        if (request.email.isEmpty() || request.question.isEmpty()) {
            throw IllegalArgumentException()
        }
        return next(request)
    }

val finalResponse = fun() =
    fun(request: Request): Response {
        return Response("I don't know")
    }

data class Response(val answer: String)

typealias Handler = (request: Request) -> Response

```


# 상태 패턴
전략 패턴의 일종
전략패턴은 외부의 클라이언트가 전략을 교체하는 반면 상태패턴은 오로지 입력에 의해 내부적으로 변경.
상태패턴을 사용하면 모든것을 통제 아래에 둘 수 있다. 
```kotlin
sealed class Mood {
    // Some abstract methods here, like draw(), for example
}
object Still : Mood()
object Aggressive : Mood()
object Retreating : Mood()
object Dead : Mood()


class Snail : WhatCanHappen {
    private var healthPoints = 10
    private var mood: Mood = Still

    override fun seeHero() {
        mood = when (mood) {
            is Still -> {
                println("Aggressive")
                Aggressive
            }
            else -> {
                println("No change")
                mood
            }
        }
    }

    override fun getHit(pointsOfDamage: Int) {
        println("Hit for $pointsOfDamage points")
        healthPoints -= pointsOfDamage

        println("Health: $healthPoints")
        mood = when {
            (healthPoints <= 0) -> {
                println("Dead")
                Dead
            }
            mood is Aggressive -> {
                println("Retreating")
                Retreating
            }
            else -> {
                println("No change")
                mood
            }
        }
    }

    override fun calmAgain() {
    }
}

```



# 반복자 패턴
[[합성 패턴]] 그 자체로는 다소 불완전하다는 사실이 반복자패턴으로 완성 시킬수 있다. 
```kotlin
for (trooper in platoon) {
    println(trooper)
}
```
은 실행되지 않는다. 
반복자 메서드를 가져야한다. 
`operator fun iterator() =` 를 구현해야한다. 
Iterator<T> 인터페이스를 구현하는 익명 객체를 반환한다

`fun hasNext():Boolean`, `fun next():T` 

```kotlin
class Squad(private val units: List<Trooper>) : Trooper() {
    constructor(vararg units: Trooper) : this(units.toList())
    operator fun iterator(): Iterator<Trooper> {
        return TrooperIterator(units)
    }
}

class TrooperIterator(private val units: List<Trooper>) : Iterator<Trooper> {
    private var i = 0
    private var iterator: Iterator<Trooper> = this
    override fun hasNext(): Boolean {
        if (i >= units.size) {
            return false
        }
        if (i == units.size - 1) {
            if (iterator != this) {
                return iterator.hasNext()
            }
        }
        return true
    }

    override fun next(): Trooper {
        if (iterator != this) {
            if (iterator.hasNext()) {
                return iterator.next()
            } else {
                i++
                iterator = this
            }
        }

        return when (val e = units[i]) {
            is Squad -> {
                iterator = e.iterator()
                this.next()
            }
            else -> {
                i++
                e
            }
        }
    }
}

```


# 브리지 패턴

브리지 패턴은 상속 남용하는걸 방지한다
```kotlin
interface Trooper {
  fun move(x: Long, y: Long)
  fun attackRebel(x: Long, y: Long)
}

class StormTrooper : Trooper {
  override fun move(x: Long, y: Long) {
  // 보통 속도로 이동
  override fun attackRebel(x: Long, y: Long) {
  // 대부분 빗나감
｝
class ShockTrooper: Trooper {
   override fun move(x: Long, y: Long) {
  // 일반적인 StromTrooper보다는 느리게 이동
 ｝
｝
override fun attackRebel(x: Long, y: Long) {
// 명중할 때도
```
인터페이스 함수가 추가되면 다른 모든 구현체에 추가 해야된다

브리지 패턴은 클래스 계층 구조를 얇게 만들어 구체 클래스를 줄이는것이다

move와 attack을 위해 속성으로 스펙을 만들다
```kotlin
data class StormTrooper(
  private val weapon: Weapon,
  private val legs: Legs
) : Trooper {
override fun move(x: Long, y: Long) {
  legs.move(x, Y)
}
override fun attackRebel(x: Long, y: Long) {
  weapon.attack(x, y)
}
```

```kotlin
class Rifle: Weapon{
  override fun attack(x: Long, y: Long) = RIFLE_DAMAGE
}
class Flamethrower:Weapon{
  override fun attack(x: Long, y: Long)= RIFLE_DAMAGE * 2
}
class Batton:Weapon {
  override fun attack(x:Long,y:Long)=RIFLE_DAMAGE * 3
}

class RegularLegs : Legs {
  override fun move() =REGULAR_SPE
}
class AthleticLegs : Legs {
  override fun move()=REGULAR_SPEED
}

val stormTrooper = StormTrooper(Rifle(), RegularLegs())
val flameTrooper = StormTrooper(Flamethrower(), RegularLegs())
val scoutTrooper = StormTrooper(Rifle(), AthleticLegs())
```


# 합성 패턴

```kotlin
class Squad(val units: List<Trooper>)

val bobaFett = StormTrooper (Rifle(), RegularLegs())
val squad = Squad(listOf(bobaFett.copy(), bobaFett.copy(), bobaFett.copy()))

class Squad (private val units: List<Trooper>) {
  fun move(x: Long, y: Long) {
    for (u in units) {
      u. move (x, y)
    }
  }
  fun attack(x: Long, Y: Long) {

```
Tooper가 모여 Squad 를 만든다 
Tooper가 할수 있는 행위를 그대로 가져가려면 인터페이스를 구현하면 된다
```kotlin
class Squad (private val units: List<StormTrooper>): Trooper {
・・・」
```

합성패턴은 반복자 패턴과 짝을 이룬다
UI에서 많이 쓴다 


# 데코레이터패턴

상속이 아닌 구상으로 
OCP

```java
public abstract class Beverage {
		String description = "제목 없음“;
		public String getDescription() {
			return description;
		}
		public abstract double cost();
}
		
```



# 옵져버패턴
![](./이미지/옵져버패턴/image.png)
![](./이미지/옵져버패턴/IMG_8646.png)
![](./이미지/옵져버패턴/IMG_8647.png)
![](./이미지/옵져버패턴/IMG_8648.png)
![](./이미지/옵져버패턴/IMG_8649.png)


# 상태패턴
[상태 패턴 - State Pattern 디자인패턴/코틀린/kotlin](https://kimchanjung.github.io/design-pattern/2020/05/26/state-pattern/)

[Design Pattern State Pattern](https://beomseok95.tistory.com/291)


# 상태패턴과 전략패턴 차이 
상태패턴은 if문을 대체하기 위함이고 전략 패턴은 상속을 대체하기 위함 

#designpattern 